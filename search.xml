<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Playwright 攔截 request 簡易筆記和範例</title>
      <link href="/2024/09/08/2024-easy-playwright-intercept-note/"/>
      <url>/2024/09/08/2024-easy-playwright-intercept-note/</url>
      
        <content type="html"><![CDATA[<p>工作上測試遇到了一個情境是測試 Web SDK，主要類似於 GA 的那種監控網頁事件來發送 request 的受測對象<br>Web SDK 會根據當下使用者的事件觸發順序而產生不同的 request 內容<br>今天準備了一個可以觸發 request 的 HTML、接收 request 的簡單 Node.js Backend API Server<br>還有筆記用的 Playwright 攔截 request 範例程式碼</p><p>所有程式碼都放在這: <a href="https://github.com/SQZ777/playwright-intercept-example">範例程式碼</a></p><p>這張圖應該能表達到今天文章範例中的攔截器概念(?)</p><p><img src="/../img/2024-easy-playwright-intercept-note/1.png" alt="interceptor_meme"></p><p>自動化的執行流程:</p><ol><li>啟動 server.js，讓 html 可以透過本地伺服器瀏覽</li><li>使用瀏覽器瀏覽 localhost:3000</li><li>點擊按鈕觸發 request 發送的動作</li><li>攔截 request 驗證 request 被發送的正確性</li></ol><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p><del>可能不算程式碼…? 沒有人:可是它裡面有 js</del></p><p>此 HTML 會在按下按鈕後擷取當下瀏覽器中的 timezone，將 timezone 夾帶進去 request 發送到 Backend Server</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Playwright Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Playwright Intercept Request Example&lt;/h1&gt;    &lt;button id=&quot;sendRequest&quot;&gt;Send Request&lt;/button&gt;    &lt;script&gt;        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;        document.getElementById(&#39;sendRequest&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;            fetch(&#39;/api/data&#39;, &#123;                method: &#39;POST&#39;,                headers: &#123;                    &#39;Content-Type&#39;: &#39;application/json&#39;                &#125;,                body: JSON.stringify(&#123; location: timezone &#125;)            &#125;)                .then(response =&gt; response.json())                .then(data =&gt; console.log(&#39;Response from server:&#39;, data))                .catch(error =&gt; console.error(&#39;Error:&#39;, error));        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接收 request 以及讓 HTML 可以被瀏覽</p><p>Node.js Server</p><pre><code>const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();const port = 3000;app.use(express.json());// 提供 public 資料夾中的靜態檔案app.use(express.static(path.join(__dirname, &#39;public&#39;)));app.post(&#39;/api/data&#39;, (req, res) =&gt; &#123;    console.log(&#39;Received data:&#39;, req.body);    res.json(&#123; message: &#39;Data received successfully&#39;, receivedData: req.body &#125;);&#125;);// 服務 index.htmlapp.get(&#39;/&#39;, (req, res) =&gt; &#123;    res.sendFile(path.join(__dirname, &#39;index.html&#39;));&#125;);app.listen(port, () =&gt; &#123;    console.log(`Server is running on http://localhost:$&#123;port&#125;`);&#125;);</code></pre><h2 id="Playwright-攔截範例"><a href="#Playwright-攔截範例" class="headerlink" title="Playwright 攔截範例"></a>Playwright 攔截範例</h2><p>先寫一個不改變瀏覽器 timezone 的案例，瀏覽器會依照使用者當前的機器設定來設定 timezone<br>我目前待在台灣，所以 timezone id 會是 <code>Asia/Taipei</code></p><pre><code class="javascript">const &#123; test, expect &#125; = require(&#39;@playwright/test&#39;);test.describe(&#39;test with local and no change&#39;, () =&gt; &#123;    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Asia/Taipei&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>再寫一個改變瀏覽器 timezone 的案例，這個案例會先將 timezone 改為 <code>Europe/Paris</code>，再執行瀏覽 HTML 的動作</p><pre><code class="javascript">test.describe(&#39;test with franch&#39;, () =&gt; &#123;    test.use(&#123; timezoneId: &#39;Europe/Paris&#39; &#125;);    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Europe/Paris&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>兩個案例執行完之後在 console 中可以見到以下結果</p><p><img src="/../img/2024-easy-playwright-intercept-note/2.png" alt="playwright_result"></p><h2 id="額外筆記"><a href="#額外筆記" class="headerlink" title="額外筆記"></a>額外筆記</h2><p>因為這一種會持續監聽瀏覽器事件的 Web SDK，是不會有 request 停止的一刻，所以選擇使用的是 <code>page.waitForTimeout(1000)</code><br>而非 <code>page.waitForLoadState(&#39;networkidle&#39;)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Playwright </tag>
            
            <tag> 攔截Request </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile x Postgres：Materialized View 的 REFRESH 奇幻（？）之旅！</title>
      <link href="/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/"/>
      <url>/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/</url>
      
        <content type="html"><![CDATA[<p><img src="/../img/2024-init-postgres-when-materialized-view-depends-on-remote-table/image1.png" alt="我是小丑"></p><p>遇到這個 Issue 是因為測試上的需求，情境是要做 API Automation<br>而 SUT(System Under Test) 的 API 相依於 Postgres 中的某一個 Materialized View<br>又剛好，這個 Materialized View 會用到 remote table 的資料<br>再剛好，這個 remote table 也是你要做 init DB 的對象（在同一個 image）<br>執行 REFRESH MATERIALIZED VIEW 的時候發生的問題<br>所以就發生了這個問題，錯誤訊息如下</p><pre><code class="shell">2024-06-18 00:51:17.451 UTC [68] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-18 00:51:17.451 UTC [68] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?2024-06-18 00:51:17.451 UTC [68] STATEMENT:  REFRESH MATERIALIZED VIEW test2_db_schema.test2_mvERROR:  could not connect to server &quot;test1_db&quot;DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="這次-issue-的相關檔案"><a href="#這次-issue-的相關檔案" class="headerlink" title="這次 issue 的相關檔案"></a>這次 issue 的相關檔案</h2><p>想要在 local 重現的話，執行一次這裡提到的檔案就可以看到了~</p><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile:"></a>dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sqlCOPY init.sh /docker-entrypoint-initdb.d/init.sh</code></pre><h3 id="init-sh"><a href="#init-sh" class="headerlink" title="init.sh:"></a>init.sh:</h3><pre><code class="shell">psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;</code></pre><h3 id="test1-sql"><a href="#test1-sql" class="headerlink" title="test1.sql:"></a>test1.sql:</h3><pre><code class="sql">CREATE SCHEMA test1_db_schema AUTHORIZATION postgres;-- test1_db_schema.test1_table definition-- Drop table-- DROP TABLE test1_db_schema.test1_table;CREATE TABLE test1_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)</code></pre><h3 id="test2-sql"><a href="#test2-sql" class="headerlink" title="test2.sql:"></a>test2.sql:</h3><pre><code class="sql">CREATE SCHEMA test2_db_schema AUTHORIZATION postgres;CREATE EXTENSION postgres_fdw;CREATE SERVER test1_db        FOREIGN DATA WRAPPER postgres_fdw        OPTIONS (host &#39;localhost&#39;, port &#39;5432&#39;, dbname &#39;test1&#39;);CREATE USER MAPPING FOR postgresSERVER test1_dbOPTIONS (user &#39;postgres&#39;, password &#39;12345&#39;);-- test2_db_schema.test1_table definition-- Drop table-- DROP FOREIGN TABLE test2_db_schema.test1_table;CREATE FOREIGN TABLE test2_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)SERVER test1_dbOPTIONS (schema_name &#39;test1_db_schema&#39;, table_name &#39;test1_table&#39;);-- PermissionsALTER TABLE test2_db_schema.test1_table OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test1_table TO postgres;CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;-- View indexes:CREATE UNIQUE INDEX uix_test2_mv ON test2_db_schema.test2_mv USING btree (cupid_id, outer_id);-- PermissionsALTER TABLE test2_db_schema.test2_mv OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test2_mv TO postgres;</code></pre><p>這裡特別提一下建立 Materialized View 時的細節，以下 script 擷取於上面提到的內容</p><pre><code>CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;</code></pre><p>如果這裡寫的是 WITH DATA，報錯會報在這裡，而不是 REFRESH 的時候，錯誤訊息會像這樣</p><pre><code class="shell">2024-06-23 09:28:15.912 UTC [59] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-23 09:28:15.912 UTC [59] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>根據 <a href="https://github.com/docker-library/postgres/blob/master/Dockerfile-alpine.template#L216">postgres 在 github 上的 dockerfile</a>，可以注意到</p><ol><li>原始 postgres 的 docker-entrypoint.sh 放置於 <code>/usr/local/bin</code></li><li>你的 dockerfile 中，位於 <code>/docker-entrypoint-initdb.d/</code> 的 shell script，會早於 postgres 啟動的時間點</li></ol><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><ol><li>init.sh 中啟動 postgres，並確認 postgres 啟動後再執行我們的原本要執行的 script，並讓 image 保持啟動狀態</li><li>dockerfile 改為 <code>RUN init.sh</code>，而非原本將 init.sh 放進 <code>/docker-entrypoint-initdb.d/</code> 的方式</li></ol><h3 id="改變後的-init-sh："><a href="#改變後的-init-sh：" class="headerlink" title="改變後的 init.sh："></a>改變後的 init.sh：</h3><pre><code class="shell">#!/bin/bashecho &quot;Starting PostgreSQL...&quot;/usr/local/bin/docker-entrypoint.sh postgres &amp; # 將 postgres 啟動until pg_isready -h localhost -p 5432; do # 檢查 postgres 啟動狀態  echo &quot;Waiting for PostgreSQL to start...&quot;  sleep 1done# psql -U postgres -c &quot;CREATE DATABASE test1;&quot;psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;tail -f /dev/null # 讓 container 保持運作狀態</code></pre><h3 id="改變後的-dockerfile"><a href="#改變後的-dockerfile" class="headerlink" title="改變後的 dockerfile:"></a>改變後的 dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sql# COPY init.sh /docker-entrypoint-initdb.d/init.shCOPY init.sh /init.shRUN chmod +x /init.shCMD [&quot;/init.sh&quot;]</code></pre><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我真的沒想到會遇到這種問題，一開始單純只是想要快樂 init DB schema 而已，所以就單純放在 <code>/docker-entrypoint-initdb.d/</code> 裡面<br>這個過程讓我學到 Dockerhub 上的 image 中，他的 Dockerfile 是如何被執行的<br>以及我們自己放在 <code>/docker-entrypoint-initdb.d/</code> 裡面的 shell script 的執行順序</p><p>不過我不知道我這個解法到底是對的還是錯的 XD</p><p>所以，最後想問一下<br>透過 Dockerfile 建置 postgres DB schema 的 best practice 是什麼？<br><del>不要跟我說透過 dockerfile 建置 postgres DB 本身就是錯的 XDD</del></p><p>如果有更好的解法或是有寫錯的地方，歡迎告訴我<br>感謝大家</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Postgres </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻譯】5 件與測試有關的難搞事</title>
      <link href="/2024/06/10/2024-five-tricky-things-with-testing/"/>
      <url>/2024/06/10/2024-five-tricky-things-with-testing/</url>
      
        <content type="html"><![CDATA[<p><img src="/../img/2024-five-tricky-things-with-testing/image.jpg"></p><p>這是一篇翻譯文，文末才會有一些個人的心得與見解<br>原文連結:<br><a href="https://thetesteye.com/blog/2016/09/five-tricky-things-with-testing/">Five Tricky Things With Testing - Rikard Edgren</a></p><h2 id="內文翻譯"><a href="#內文翻譯" class="headerlink" title="內文翻譯"></a>內文翻譯</h2><p>今天我去了哥德堡的 SAST Väst，進行了一個可以翻譯為 <em>5 件與測試有關的難搞事</em> 的<a href="https://thetesteye.com/presentations/Edgren_SASTVAST2016_FemBesvarligaSakerMedTestning.pdf">演講</a>。<br>這是一個非常愉快的日子，我見到了舊友和新朋友。這也是我好久以來第一次寫 Blogs 的機會，下面是非常簡潔的版本：</p><ol><li><p><strong>人們不懂測試</strong>，但都有自己的見解。<br>他們認為測試是一種成本，沒有考慮到它的價值。<br>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</p></li><li><p><strong>心理上的困難</strong><br>你找到的問題越多，完成的時間就會越長。<br>解決方法：強調長期利益，對自己和他人都一樣。</p></li><li><p><strong>你永遠不會完成</strong><br>總有更多的東西需要測試，但你必須停止。<br>解決方法：多與同事交流，進行更豐富的測試。</p></li><li><p><strong>隱性知識。</strong><br>極少數情況下，你能寫下如何測試，然後進行良好的測試。<br>解決方法：更多的深層的討論</p></li><li><p><strong>有需求，但薪水低。</strong><br>解決方法：用正確的詞語談論測試的價值，並用小的努力而不僅僅是找到漏洞來提供價值。</p></li></ol><p>總結：確保你的測試能提供價值，這也有助於測試社群。</p><p>演講中有一些好問題，其中一個特別困難：<br><strong>如何確保訊息傳達到應該接收的人？</strong></p><p>回答：對於離你近的人，這並不困難；從一開始就討論要報告哪些訊息以及如何報告。<br>我不喜歡模板，所以我通常為每個項目製作一個新模板，並詢問是否包含了正確的訊息。</p><p>但我猜你的意思是對於那些離你較遠的人，尤其是階層較高的人，這可能非常困難。這可能是一些你「不能」直接交談的人，你也不被邀請參加他們的會議。<br>我嘗試過的一個技巧是以一種容易傳播的格式報告，這樣很容易複製和貼上精華部分，使你的話語能夠傳達到你無法直接交談的參與者。</p><p>更好的答案需要你在自己的情境中找到。</p><p>作者: Rikard Edgren<br>日期: September 27, 2016</p><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>到了 2024 年，測試的工作仍然會遇到上面這些難搞事<br>測試相關的工作者永遠必須抱持的態度就是「持續溝通」<br>並且不斷地談論「測試價值」這件事</p><h3 id="關於第一點的個人看法"><a href="#關於第一點的個人看法" class="headerlink" title="關於第一點的個人看法"></a>關於第一點的個人看法</h3><blockquote><p><em>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</em></p></blockquote><p>這部分我個人認位作者想要表達的是測試人員應該不斷的與相關利益者或者團隊成員討論他們對於「測試結果」的需求，以及「測試」可以幫助他們瞭解的重要事項</p><p>這樣的討論就可以幫助到大家更好地理解測試的價值，而不單單只是將「測試」視為一種成本</p><h3 id="關於第四點的個人看法"><a href="#關於第四點的個人看法" class="headerlink" title="關於第四點的個人看法"></a>關於第四點的個人看法</h3><blockquote><p><em>「極少數情況下，你能寫下如何測試，然後進行良好的測試。」</em></p></blockquote><p>我認為非常的貼切，因為大部分的 bug，發生在你意料之外的地方，而不是你預想的地方<br>這一句話所代表的是，開發者在大多數的情況下，會依照功能的描述進行開發<br>測試者則必須同時保證功能描述與開發者的實作成果一致之外，還得探索功能以外的可能性<br>以確保功能在完成時給予客戶的是驚訝，而不是驚嚇</p><p>Photo by <a href="https://unsplash.com/@icons8?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Icons8 Team</a> on <a href="https://unsplash.com/photos/man-teaching-woman-while-pointing-on-gray-laptop-yTwXpLO5HAA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 翻譯系列 </tag>
            
            <tag> 測試相關 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 ChatGPT 進行部落格文章搬遷的我會被 AI 取代嗎?</title>
      <link href="/2024/06/08/2024-migrate-blog-by-chatgpt/"/>
      <url>/2024/06/08/2024-migrate-blog-by-chatgpt/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2024-migrate-blog-by-chatgpt/image0.png"><br>圖是使用<a href="https://memes.tw/">梗圖產生器</a>產生的，AI 真的可以取代我們嗎? 讓我們繼續看下去</p><p>最近自己使用了 ChatGPT 進行部落格文章的搬遷<br>搬站的原因很膚淺，想知道的話再去<a href="https://sqz777.com/about/">關於我</a>看，就不多做贅述 🤣<br>原本這篇只是單純想記錄搬遷的過程，但剛好最近社團討論很熱烈就把文章的撰寫方式稍微改變一下<br>讓這篇可以更符合社團最近討論度很高的主題： </p><blockquote><p>因為 AI 的出現，工程師會不會失業?</p></blockquote><p><strong>本文使用的 ChatGPT 模型是 GPT-4o</strong></p><h2 id="正文開始，我的第一步是拆分需求"><a href="#正文開始，我的第一步是拆分需求" class="headerlink" title="正文開始，我的第一步是拆分需求"></a>正文開始，我的第一步是拆分需求</h2><p>需求很簡單</p><ul><li>提供 URL 將部落格的文章內容轉成 markdown</li><li>取得舊部落格的所有文章 URL</li><li>讓第一個需求可以批次處理</li></ul><p>這種一次性的 script，就不考慮維護性了<br>所以基本上所有 code 都讓 ChatGPT 產生再做細節的調整就好</p><h2 id="第二步，描述需求讓-ChatGPT-產生程式碼"><a href="#第二步，描述需求讓-ChatGPT-產生程式碼" class="headerlink" title="第二步，描述需求讓 ChatGPT 產生程式碼"></a>第二步，描述需求讓 ChatGPT 產生程式碼</h2><p>直接讓 ChatGPT 幫我產生一段關於文章內容轉成 markdown 的 Node.js Code</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image1.png"></p><p>以下是 ChatGPT 產生的 Node.js Code</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);const fs = require(&#39;fs&#39;);const URL = &#39;https://dotblogs.azurewebsites.net/Im_sqz777/2022/10/06/223559&#39;;axios.get(URL)  .then(response =&gt; &#123;    const html = response.data;    const $ = cheerio.load(html);    // 假設文章內容在 class 為 &#39;post-content&#39; 的元素中    const postContent = $(&#39;.post-content&#39;).html();    if (!postContent) &#123;      throw new Error(&#39;未能找到文章內容，請檢查選擇器是否正確&#39;);    &#125;    // 將 HTML 轉換為 Markdown 格式    const markdownContent = convertToMarkdown(postContent);    // 將 Markdown 內容寫入文件    fs.writeFileSync(&#39;article.md&#39;, markdownContent);    console.log(&#39;文章已成功轉換為 Markdown 格式並儲存至 article.md&#39;);  &#125;)  .catch(error =&gt; &#123;    console.error(&#39;發生錯誤:&#39;, error);  &#125;);function convertToMarkdown(html) &#123;  // 這裡使用 turndown 庫來轉換 HTML 為 Markdown  const TurndownService = require(&#39;turndown&#39;);  const turndownService = new TurndownService();  return turndownService.turndown(html);&#125;</code></pre><h2 id="第三步，修正-ChatGPT-的程式碼"><a href="#第三步，修正-ChatGPT-的程式碼" class="headerlink" title="第三步，修正 ChatGPT 的程式碼"></a>第三步，修正 ChatGPT 的程式碼</h2><p>我發現了 ChatGPT 提供的 code 中有一個「假設」</p><pre><code>// 假設文章內容在 class 為 &#39;post-content&#39; 的元素中const postContent = $(&#39;.post-content&#39;).html();</code></pre><p>這一個假設讓我需要回到文章的頁面中找到文章內容的 class 為 <code>article__content</code>，如圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image2.png"></p><p>將 <code>.post-content</code> 取代為 <code>.article__content</code> 了之後執行程式碼</p><blockquote><p>記得在<code>article__content</code>前面加上點: <code>.</code></p></blockquote><p>驗證產生出來的 markdown 有幾個小問題</p><ol><li>舊文章日期&#x2F;標籤&#x2F;標題，沒有被寫進我預期的格式中</li><li>檔案名稱是寫死的，舊文章產生的檔案名稱應該依照文章年份及對應名稱</li></ol><h2 id="第四步，修正小問題，讓-ChatGPT-重新產生程式碼"><a href="#第四步，修正小問題，讓-ChatGPT-重新產生程式碼" class="headerlink" title="第四步，修正小問題，讓 ChatGPT 重新產生程式碼"></a>第四步，修正小問題，讓 ChatGPT 重新產生程式碼</h2><p>依照小問題 1，我需要道舊文章中找到文章對應的標題&#x2F;標籤&#x2F;日期的 html，然後產生 prompt 讓 GPT 幫我改 code<br>prompt 如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image3.png"></p><p>避免文章太長，就不貼 GPT 產生的 code 了<br>接著再解小問題 2<br>這個問題很簡單，直接讓 GPT 修正並且改掉先前提到的文章內容 class 的問題</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image4.png"></p><p>小問題解完之後，執行了 script，確認 markdown 可以被 hexo 解析就可以進到下一步了</p><h2 id="第四步，讓-URL-可以批次輸入"><a href="#第四步，讓-URL-可以批次輸入" class="headerlink" title="第四步，讓 URL 可以批次輸入"></a>第四步，讓 URL 可以批次輸入</h2><p>為了讓舊站的連結可以透過 git 記錄，所以決定透過檔案的方式來進行批次處理<br>這樣一來我有紀錄的同時又可以透過檔案來進行文章的轉換，prompt 如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image5.png"></p><p>在檔案中隨便貼上兩個舊站的文章測試一下，確認沒問題之後就往下一步</p><h2 id="第五步，取得舊站所有文章的-URL"><a href="#第五步，取得舊站所有文章的-URL" class="headerlink" title="第五步，取得舊站所有文章的 URL"></a>第五步，取得舊站所有文章的 URL</h2><p>在舊站首頁中可以觀測到 title 的 class 為 <code>article__title</code><br>然後可以在 URL 觀測到頁面會因為尾數不同而換頁，URL 如下</p><blockquote><p><a href="https://dotblogs.com.tw/Im_sqz777/1">https://dotblogs.com.tw/Im_sqz777/1</a> &lt;&lt; 這個 1 就是頁數</p></blockquote><p>我們就可依照這個狀況產生對應的 prompt:</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image6.png"></p><p>產生的程式碼如下</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);async function fetchArticleTitles(variable) &#123;    const url = `https://dotblogs.com.tw/Im_sqz777/$&#123;variable&#125;`;    try &#123;        const &#123; data &#125; = await axios.get(url);        const $ = cheerio.load(data);        // 選擇所有 class 為 article__title 的元素        $(&#39;.article__title a&#39;).each((index, element) =&gt; &#123;            const titleUrl = $(element).attr(&#39;href&#39;);            console.log(titleUrl);        &#125;);    &#125; catch (error) &#123;        console.error(`Error fetching data from $&#123;url&#125;:`, error);    &#125;&#125;// 迭代變數 1 到 8for (let i = 1; i &lt;= 8; i++) &#123;    fetchArticleTitles(i);&#125;</code></pre><p>接著執行產生的程式碼會發現他並沒有符合我們的需求，如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image7.png"></p><p>我們的需求是需要讓 text file 中描述 URL，所以只需要在第 14 行加入 <code>&#39;https://dotblogs.com.tw&#39; + </code> 就可以了<br>執行結果如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image8.png"></p><h2 id="第六步，修復-hexo-解析的問題"><a href="#第六步，修復-hexo-解析的問題" class="headerlink" title="第六步，修復 hexo 解析的問題"></a>第六步，修復 hexo 解析的問題</h2><p>接著就會發現 hexo 解析的 2 個錯誤</p><ol><li>title 格式的問題<br><img src="/img/2024-migrate-blog-by-chatgpt/image9.png"></li><li>舊文中出現大括弧 <code>&#123;&#125;</code> 時的解析問題</li></ol><p>title 的格式問題很簡單，在原程式碼中的 title 中加入單引號即可，如下</p><pre><code>---title: &#39;$&#123;title&#125;&#39;date: $&#123;date&#125;tags: $&#123;tags.map(tag =&gt; `  - $&#123;tag&#125;`).join(&#39;\n&#39;)&#125;---</code></pre><p>第 2 個問題直接讓 ChatGPT 解決</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image10.png"><br>但是 ChatGPT 提供的程式碼有問題，關鍵程式碼如下</p><pre><code>  // 替換文章內容中的 &#123; 和 &#125; 字符  markdownContent = markdownContent.replace(/(&#123;|&#125;)/g, &#39;\\$1&#39;);</code></pre><p>我預期和描述的 prompt 斜線是 <code>/</code>，但 ChatGPT 睜眼說瞎話的寫成了 <code>\</code>，改掉之後確認解析沒問題後</p><p>還剩下一個細節的需求，是一開始需求分析時沒有寫到的:</p><ul><li>圖片應該要下載下來，並且在 markdown 中顯示</li></ul><p>但這一段 ChatGPT 完美的解決了我的問題，所以就不記錄了，想要看最後的程式碼的話可以到 Github 上看<br>連結附上</p><ul><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/dotblogTurnMarkdown.js">DotBlogs 文章轉 markdown</a></li><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/getDotblogPostsURLs.js">取得 DotBlogs 的文章 URLs</a></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>總結一下透過 ChatGPT 搬遷 blogs 文章會需要的技能</p><ol><li>知道網站相關的知識<ul><li>知道在程式碼中描述 class 前面要加上 <code>.</code></li><li>知道 URL 中哪個值是對應頁數</li></ul></li><li>知道如何使用 Chrome 的開發者工具</li><li>知道 regex 的組成</li><li>知道錯誤訊息怎麼看<ul><li>如何快速定位哪一篇是發生錯誤的文章</li></ul></li><li>知道 hexo 解析錯誤的原因<ul><li>在 {} 前要加上 <code>/</code> 而非 <code>\</code></li><li>在標題中出現 <code>&#39;</code> 要在 script 中針對標題兩側加上 <code>&#39;</code></li></ul></li><li>…之後想到再補充</li></ol><p>以上程式碼的內容，要我自己寫是完全沒問題，有 AI 之後<br>原本可能要花 1 小時左右的時間，最後壓縮成 20 分鐘內甚至更短就解決了<br>依照今天這樣子的搬遷紀錄來看，我應該還不至於被「純粹的 AI 工具」或是「無基礎但使用 AI 工具的人」取代</p><p>不過要注意的是那些努力且能夠善用 AI 工具的人，這些人的生產力可能會是 AI 出現前的好幾倍</p><p>不說了，我要睡了，明早再修這個 blog theme 程式碼會置中的問題了 🙈🙈🙈<br>感謝大家收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改 Chrome 時區的方法</title>
      <link href="/2024/06/06/2024-how-to-change-time-zone-in-chrome/"/>
      <url>/2024/06/06/2024-how-to-change-time-zone-in-chrome/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2024-how-to-change-time-zone-in-chrome/image.png" alt="checkTimeZone"></p><p>最近測試時遇到驗證不同時區狀況的需求</p><p>直覺上認為開啟 VPN 或是更改電腦的設定是不合理的<br>所以嘗試找看看 Chrome 有沒有辦法更改 Chrome 自身的時區設定<br>然後就讓我找到了 <a href="https://developer.chrome.com/docs/devtools/settings/locations?hl=zh-tw">Chrome 的文件</a> !</p><h2 id="設定前確認時區"><a href="#設定前確認時區" class="headerlink" title="設定前確認時區"></a>設定前確認時區</h2><p>更改之前，透過 F12 的 Console 來確認當前的時區</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image1.png" alt="checkTimeZone"></p><h2 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h2><p>於右上角三個點 &gt; More tools &gt; Sensors</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image2.png" alt="settingLocation"></p><p>接著在下方的 Sensors tab 就可以找到複寫 Location 的設定，我們這裡選擇 Tokyo</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image3.png" alt="settingLocation"></p><h2 id="確認結果"><a href="#確認結果" class="headerlink" title="確認結果"></a>確認結果</h2><p>在 Console 中確認時區是否已被覆寫</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image4.png" alt="settingLocation"></p><p>這樣就可以完成時區的修改啦!<br>當前端會根據 Chrome 本身設定的時區進行時區顯示上的修改時，就會需要用到這一個 Chrome 的覆寫時區功能了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 時區 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API 自動化的技術選擇與 Modules 的分層思考</title>
      <link href="/2022/10/06/2022-223559/"/>
      <url>/2022/10/06/2022-223559/</url>
      
        <content type="html"><![CDATA[<p>今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。</p><p><a href="https://github.com/SQZ777/jest-for-api-automation-template.git">https://github.com/SQZ777/jest-for-api-automation-template.git</a></p><p>各個 subtitle 如下</p><ul><li>為何不使用 Postman 來做 API Automation</li><li>語言選擇</li><li>測試框架選擇</li><li>Modules 的分層</li><li>各個 Modules 的介紹與實作</li><li>結語和本篇沒提到的事</li></ul><p>首先在使用程式碼撰寫 API 自動化的測試案例時，一定會先遇到這個問題</p><h2 id="為何不使用-Postman-來做-API-Automation？"><a href="#為何不使用-Postman-來做-API-Automation？" class="headerlink" title="為何不使用 Postman 來做 API Automation？"></a>為何不使用 Postman 來做 API Automation？</h2><p><img src="/img/2022-223559/1665066616.png.png"></p><p>所以就先來列一下 Postman 的優&#x2F;缺點吧</p><p>優點如下</p><ul><li>UI 介面容易使用，門檻極低</li><li>可以透過 JavaScript 來實作檢查 response 的 script</li><li>各個平台（Mac, Windows）都可以使用</li><li>可以透過 newman（CLI）來建置 CI 的流程</li></ul><p>接著列一下使用 Postman 執行管理自動化案例會遇到的問題</p><ul><li>大量自動化案例會產生極大的維護成本<ul><li>無法重用的 test script</li><li>受測 API 如果新增 required fields，會需要手動更新大量既有的 script</li></ul></li><li>執行 collection runner 再透過 csv 檔案來匯入測試資料的過程過於繁瑣</li></ul><p>Postman 在實作小型的 API 驗證時，是一個非常好用的工具，但需要實作大量 API 測試案例時，在 Postman 上管理這些案例會產生很大的維護成本，不信的話你可以試試，所以我們需要透過撰寫程式的方式來管理這些即將被實作的 API 測試案例。</p><h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>首先要選擇的是語言，依照公司內部現有的技術而選，策略是以不增加公司同事之間跨越職能障礙為主要目標，其次是這個語言的資源，再其次是學習的門檻，因為有尚未開發過自動化的 QA ，所以選擇語言起手的難易度也需要列為考量。</p><p><img src="/img/2022-223559/1665066630.png.png"></p><p>抱歉了 Java XD</p><p>公司內部的 backend 是 Java，而 front-end 則是 Vue.js，所以就剩下 JavaScript 及 Java 的選項能夠選擇，考量到學習的難易度與學習資源取得的容易度，就選了 JavaScript 了，其中考量到 JavaScript 的原因還有就是公司是有需要驗證 Web 上面顯示資料正確性的需求，所以如果學會了 JavaScript ，就可以 JavaScript 實作一些工具直接在 console 上執行來協助測試。</p><h2 id="測試框架選擇"><a href="#測試框架選擇" class="headerlink" title="測試框架選擇"></a>測試框架選擇</h2><p>接下來就可以找 JavaScript 在 2021 的統計，可以參考<a href="https://2021.stateofjs.com/en-US/">這個網站</a>，可以從圖表看到使用率最高的是 Jest。</p><p><img src="/img/2022-223559/1665066647.png.png"></p><p>使用率最高不代表他就是一個值得讓人使用的框架，所以再次參考了「時間推移體驗」這個數據，也可以觀察到 Jest 是一個會讓人願意再次使用的框架。</p><p><img src="/img/2022-223559/1665066655.png.png"></p><p>所以依照上面的數據，問了幾個身邊的朋友，得到的回饋也是好的，所以就選擇了 Jest 作為這次實作自動化的框架。</p><h2 id="Modules-的分層"><a href="#Modules-的分層" class="headerlink" title="Modules 的分層"></a>Modules 的分層</h2><p>為了解決 Postman 所遇到的痛點，所以我們需要</p><ul><li>tests 層<ul><li>使用其他 modules 來組成 test case 的地方</li></ul></li><li>request API 的部分要抽成 apis 的 module</li><li>request payloads 的部分要抽成 requestPayloads 的 module</li><li>有一些需要共用的 lib 抽成 common 的 module</li></ul><p>相依的關係可以畫成這個樣子</p><p><img src="/img/2022-223559/1665066676.png.png"></p><p>資料夾結構如下</p><pre><code>├─apis│      apis1.js│      apis2.js│      api/&#123;.../&#125;.js│      index.js│      requestHelper.js├─common│      jestExtend.js│          ├─requestPayloads│      apis1Request.js│      apis2Request.js│      apis/&#123;.../&#125;Request.js│      index.js│      └─tests    │   singleApi1.test.js    │   singleApi2.test.js    │   singleApi/&#123;.../&#125;.test.js    │          └─stories           stories.test.js</code></pre><h2 id="各個-Modules-的介紹與實作"><a href="#各個-Modules-的介紹與實作" class="headerlink" title="各個 Modules 的介紹與實作"></a>各個 Modules 的介紹與實作</h2><h3 id="requestPayloads-資料夾"><a href="#requestPayloads-資料夾" class="headerlink" title="requestPayloads 資料夾"></a>requestPayloads 資料夾</h3><p>requestPayloads 資料夾中的 indejx.js 是用來統整各個 API 的預設 request payloads</p><pre><code>const apis1= require(&#39;./apis1Request&#39;);const apis2= require(&#39;./apis2Request&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>預設 request payloads 的定義為：Server 不會回應「lack of fields response」的 payload</p><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis1Request.js 內容就會如下：</p><pre><code>const products = /&#123;  product_id: 1,  product_info: /&#123;    product_name: &#39;Car Engine&#39;,  /&#125;,/&#125;;module.exports = /&#123;  products,/&#125;;</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 4 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="apis-資料夾"><a href="#apis-資料夾" class="headerlink" title="apis 資料夾"></a>apis 資料夾</h3><p>apis 資料夾中的 index.js 是用來統整 apis1, apis2…等 api 的地方</p><pre><code>const apis1 = require(&#39;./apis1&#39;);const apis2 = require(&#39;./apis2&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>apis 資料夾中的 requestHelper.js 是用來管理 request API 的 HTTP method 的一層，如 get, post 等 在這一層會與 report 那一層作結合，多讓 jest 的 report 多帶一些在打 api request 的相關結果 程式碼單純以 post 為例子</p><pre><code>const axios = require(&#39;axios&#39;);/** * @param /&#123;string/&#125; baseURL for base URL * @param /&#123;object/&#125; headers for request headers * @param /&#123;object/&#125; data for request payload */async function postRequest(baseURL, headers, data) /&#123;  const result = await axios(/&#123;    method: &#39;post&#39;,    url: baseURL,    headers: headers,    data: data,  /&#125;)      .then((result) =&gt; /&#123;        return result;      /&#125;)      .catch((err) =&gt; /&#123;        console.log(err);      /&#125;);  return result;/&#125;module.exports = /&#123;  postRequest,/&#125;;</code></pre><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis.js 中則會引用到 requestHelper.js 來 request API，apis.js code 如下</p><pre><code>const /&#123;postRequest/&#125; = require(&#39;./requestHelper&#39;);require(&#39;dotenv&#39;).config();/** * @param /&#123;object/&#125; request payload * @return /&#123;object/&#125; response */**async function products(data) /&#123;  const result = await postRequest(      `$/&#123;configs.BASE_URL/&#125;/apis1/products`,      /&#123;        &#39;x-api-key&#39;: process.env.API_KEY,        &#39;content-type&#39;: &#39;application/json&#39;,      /&#125;,      data,  );  return result;/&#125;**</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 5 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="common-資料夾"><a href="#common-資料夾" class="headerlink" title="common 資料夾"></a>common 資料夾</h3><p>這一層主要是放一些官方沒有提供的 library 實作，或是共用的 function，以 jest 沒有提供的 object contain 為例，就會新增 jestExtend.js，其 code 如下，在 scenario API test 中將會用到。</p><pre><code>expect.extend(/&#123;  toContainObject(received, argument) /&#123;    const pass = this.equals(        received,        expect.arrayContaining([expect.objectContaining(argument)]),    );    if (pass) /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; not to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: true,      /&#125;;    /&#125; else /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: false,      /&#125;;    /&#125;  /&#125;,/&#125;);</code></pre><h3 id="tests-資料夾"><a href="#tests-資料夾" class="headerlink" title="tests 資料夾"></a>tests 資料夾</h3><p>這一層就是 Jest 的使用層了，會在這一層中使用各個 modules 來組成 test case。</p><p>API 測試種類大致上可以分成兩種</p><ul><li>單一 API 測試 (Single API test)</li><li>API 情境測試 (Scenario API test)</li></ul><p>單一 API 測試是指純粹只有這隻 API 是受測項目，完成測試的條件與其他 API 無關，是一個只需要使用單一一個 API 的測試項目，舉例來說 &#x2F;products API，帶給他 payload，其中會 lack fields，或是沒有帶 header，就稱之為 single API test。</p><p>API 情境測試是指要完成一個測試情境而需要用到多個 API，這裡就會需要引用到多個不同的 API 來達成某種目的，舉例來說 call &#x2F;prodcuts&#x2F;update 更新一個 product 然後再透過 &#x2F;products API 來取得預期被更新的 API，這邊就會引用到兩隻 API，這時候就稱之為 API 的情境測試。</p><p>Single API test，以 &#x2F;products API 為例子，其 code 如下</p><pre><code>const apis = require(&#39;../apis&#39;);test(&#39;Get products, should return 200&#39;, async () =&gt; /&#123;  const result = await apis.products.get();  expect(result.status).toBe(200);/&#125;);</code></pre><p>Scenario API test，以 &#x2F;products, &#x2F;products&#x2F;create 為例子，其 code 如下</p><pre><code>require(&#39;../../common/jestExtend&#39;);const apis = require(&#39;../../apis&#39;);const requestPayloads = require(&#39;../../requestPayloads&#39;);test(&#39;Create product, should get the product at /products&#39;, async () =&gt; /&#123;  const createResult = await apis.products.create(      requestPayloads.products.create,  );  expect(createResult.status).toBe(200);  const result = await apis.products.get();  expect(result.data).toContainObject(requestPayloads.products.create);/&#125;);</code></pre><h2 id="結語和本篇沒提到的事"><a href="#結語和本篇沒提到的事" class="headerlink" title="結語和本篇沒提到的事"></a>結語和本篇沒提到的事</h2><p>在這一篇中沒提到的有以下幾個事情</p><ul><li>json schema 的 validate</li><li>config</li></ul><p>依照目前的架構要擴充這兩件事情都可以很輕鬆，所以就沒有額外再寫出來記錄了</p><p>以上就是這一次整個 API automation 的思考與選擇的筆記<br>感謝各位大大看到這裡，如果有任何建議都可以跟我說，感謝 &lt;(_ _)&gt;</p><p>再次附上 repo: <a href="https://github.com/SQZ777/jest-for-api-automation-template">SQZ777&#x2F;jest-for-api-automation-template (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Automation </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prettier ESLint 出現的錯誤：Error: r is not a constructor</title>
      <link href="/2022/02/25/2022-180145/"/>
      <url>/2022/02/25/2022-180145/</url>
      
        <content type="html"><![CDATA[<p>最近做基礎建設踩到的雷</p><p>在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息</p><blockquote><p><strong>Error: r is not a constructor</strong></p></blockquote><p>目前在 github 上可以看到這個 issue ，而發生這個原因是因為目前 Prettier ESLint 還沒有支援到 eslint 8.0 以上，所以建議將版本降到 7.32.0，如圖</p><p><img src="/img/2022-180145/1645783122.png.png"></p><p><a href="https://github.com/idahogurl/vs-code-prettier-eslint/issues/26">官方的 GitHub issue</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> vs-code-prettier-eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robot Framework - Suite Setup V.S Test Setup</title>
      <link href="/2021/11/16/2021-224604/"/>
      <url>/2021/11/16/2021-224604/</url>
      
        <content type="html"><![CDATA[<p>這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義</p><p>Test Setup</p><p><em><strong>a test setup is something that is executed before a test case, and a test teardown is executed after a test case.</strong></em></p><p>Suite Setup</p><p><em><strong>A suite setup is executed before any test cases or sub test suites in that test suite, and similarly a suite teardown is executed after them.</strong></em></p><p>原文連結：<a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#id594">Robot Framework User Guide #id594</a></p><p>簡單來說</p><ul><li>Test Setup 會在每次 case 開始前執行一次</li><li>Suite Setup 是 robot file 開始執行 test case 前執行一次</li></ul><p>Suite 單位為 .robot file<br>Test 的單位為 test case</p><p>廢話不多說，先上 code，Test Setup 的 code 如下</p><pre><code>*** Settings ***Test Setup    Log To Console    Setup in Test!*** Test Cases ***Test Setup 1    Log To Console    Test Case 1Test Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的 code 如下</p><pre><code>*** Settings ***Suite Setup    Log To Console   Setup in Suite!*** Test Cases ***Suite Setup 1    Log To Console    Test Case 1Suite Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073888.png"></p><p>Test Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073897.png"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從 Code 的執行結果來看，如果一個 robot file 中有多個 Test Case</p><ul><li>Suite Setup 只會被執行一次</li><li>Test Setup 會被執行多次</li></ul><p>以上為簡單的筆記，感謝收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> RobotFramework </tag>
            
            <tag> SuiteSetup </tag>
            
            <tag> TestSetup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robot Framework - 使用 config.ini 管理環境變數</title>
      <link href="/2021/11/08/2021-204911/"/>
      <url>/2021/11/08/2021-204911/</url>
      
        <content type="html"><![CDATA[<p>這篇會介紹：</p><ul><li>為何要使用 config.ini</li><li>Variables 在 *** Settings ***</li><li>如何使用 config.ini</li></ul><p>安安 我來填坑了</p><p><img src="/img/2021-204911/1636375721.png"></p><h2 id="為什麼要使用-config-ini"><a href="#為什麼要使用-config-ini" class="headerlink" title="為什麼要使用 config.ini"></a>為什麼要使用 config.ini</h2><p>透過 config.ini 可以</p><ul><li>根據環境定義不同的環境變數</li><li>避免將機敏資料寫在程式碼中</li><li>避免第三方服務變更時，有大量的檔案需要被變更</li></ul><p>一般來說在開發任何的程式時都會有環境的區別，使用 config 檔案可以，除了環境的區別之外，還有不適合直接寫在程式碼中的資料例如：token、API 的 URL 等</p><h2 id="Variables-在-Settings"><a href="#Variables-在-Settings" class="headerlink" title="Variables 在 *** Settings ***"></a>Variables 在 *** Settings ***</h2><p>在知道如何使用 config.ini 之前須要先知道 Variables 在 Settings 中的作用是什麼</p><p>根據 <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variable-files">Robot Framework 的文件</a>可以看到 Variables 有兩種方式可以透過 .py 引入變數</p><ul><li>Getting variables directly from a module</li><li>Getting variables from a special function</li></ul><h3 id="Getting-variables-directly-from-a-module-的方式"><a href="#Getting-variables-directly-from-a-module-的方式" class="headerlink" title="Getting variables directly from a module 的方式"></a>Getting variables directly from a module 的方式</h3><p>官方定義：</p><p><em>Variables are specified as module attributes. In simple cases, the syntax is so simple that no real programming is needed. For example, creates a variable with the specified text as its value. One limitation of this approach is that it does not allow using arguments.MY_VAR &#x3D; ‘my value’$&#x2F;{MY_VAR&#x2F;}</em></p><p>以官方定義來說就可以直接看到這個方式的缺點就是沒有支援使用 arguments.MY_VAR 的方式使用變數</p><p>以範例來看使用這種方式的結果會是這樣</p><p>python 的程式碼：</p><pre><code>MY_NAME = &quot;SQZ777&quot;</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;_MY_NAME/&#125;</code></pre><p>執行結果就可以看到</p><p><img src="/img/2021-204911/1636374905.png"></p><h3 id="Getting-variables-from-a-special-function-的方法"><a href="#Getting-variables-from-a-special-function-的方法" class="headerlink" title="Getting variables from a special function 的方法"></a>Getting variables from a special function 的方法</h3><p>官方定義：</p><p><em>An alternative approach for getting variables is having a special function (also camelCase syntax is possible) in a variable file. If such a function exists, Robot Framework calls it and expects to receive variables as a Python dictionary or a Java with variable names as keys and variable values as values. Created variables can be used as scalars, lists, and dictionaries exactly like when getting variables directly from a module, and it is possible to use and prefixes to make creating list and dictionary variables more explicit. The example below is functionally identical to the first example related to getting variables directly from a module.get_variablesgetVariablesMapLIST__DICT__</em></p><p>簡單來說，透過這個方式就可以使變數有「環境」這一層的定義，除此之外還要注意的是，python 的檔案中要定義 function 的名稱為 <strong>get_variables</strong></p><p>直接來示範吧！</p><p>python 的程式碼：</p><pre><code>def get_variables():    var = &quot;BLOG_ENV.MY_NAME&quot;    variables = /&#123;/&#125;    variables[var] = &quot;SQZ777&quot;    return variables</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;BLOG_ENV.MY_NAME/&#125;</code></pre><p>在這裡就可以注意到我的變數已經可以隸屬於不同的環境了（BLOG_ENV 中的 MY_NAME）</p><h2 id="如何使用-config-ini"><a href="#如何使用-config-ini" class="headerlink" title="如何使用 config.ini"></a>如何使用 config.ini</h2><p>了解了兩種不同的引入環境變數的方式終於來到最後了解如何使用 config.ini 的部分啦！</p><p>透過 configparser 讀取 config.ini ，再將檔案中所有被定義好的變數回傳給 Robot Framework 就可以達成使用 config.ini 的方法</p><p>python 的程式碼：</p><pre><code>import configparserdef get_variables(config_path=&quot;./config.ini&quot;):    config = configparser.ConfigParser()    config.read(config_path)    variables = /&#123;/&#125;    print(config.sections)    for section in config.sections():        for key, value in config.items(section):            var = &quot;%s.%s&quot; % (section, key)            variables[var] = value    return variables</code></pre><p>config.ini 內容：</p><pre><code>[BLOG_ENV]MARVEL_URL = &lt;http://gateway.marvel.com/&gt;MARVEL_PUBLIC_KEY = 你的 public keyMARVEL_PRIVATE_KEY = 你的 private key</code></pre><p>在 robot 中使用 config，如下圖</p><p><img src="/img/2021-204911/1636374936.png"></p><p>在這裡就會出現一個疑問，這樣不就等於環境被寫死了嗎？</p><p><img src="/img/2021-204911/1636374948.png"></p><p>所以這邊為了讓使用上更方便，環境的定義可以透過 command line 來傳入，在執行 Robot Framework 時，代入參數，如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><p>而 .robot 的檔案則須要改成取用 ENV 這個在 command line 中傳入的變數。</p><p><img src="/img/2021-204911/1636374966.png"></p><p>這樣就能執行到指定的環境與變數囉!</p><p>感謝收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> config </tag>
            
            <tag> RobotFramework </tag>
            
            <tag> 環境變數 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Robot Framework - 介紹一下</title>
      <link href="/2021/10/17/2021-191743/"/>
      <url>/2021/10/17/2021-191743/</url>
      
        <content type="html"><![CDATA[<p>最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩</p><p>這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的</p><p><img src="/img/2021-191743/1634469178.png"></p><h2 id="介紹與使用場景"><a href="#介紹與使用場景" class="headerlink" title="介紹與使用場景"></a>介紹與使用場景</h2><p>Robot Framework 是一個基於 python 的 自動化框架，基本上可以用 python 達成的事情，Robot Framework 都可以做到，其應用的場景是 ATDD (Acceptance Test Driven Development)、BDD (Behavior Driven Development) 以及可以被機器化的流程。</p><p><img src="/img/2021-191743/1634469201.png"></p><h2 id="為何使用-Robot-Framework"><a href="#為何使用-Robot-Framework" class="headerlink" title="為何使用 Robot Framework?"></a>為何使用 Robot Framework?</h2><ul><li>學習資源易於取得</li><li>易於理解與學習的介面</li><li>已有豐富的 Keyword 可以使用</li></ul><p>Robot Framework 對於沒有程式基礎的人來說是「相對」易於理解的，因為他有最接近人類自然語言的介面讓人閱讀，在政治條件（？）上比較能夠說服他人使用這個工具。</p><p>你通常不太需要再自行開發 Keyword 就可以完成你需要執行的自動化流程，如果需要，你也能夠透過實作 Python 來完成你需要做的事。</p><h2 id="看懂-Robot-Framework"><a href="#看懂-Robot-Framework" class="headerlink" title="看懂 Robot Framework"></a>看懂 Robot Framework</h2><p>先來張圖，這張圖是 Robot Framework 的文件，紅框的部分：</p><p><img src="/img/2021-191743/1634469224.png"></p><h2 id="Settings"><a href="#Settings" class="headerlink" title="*** Settings ***"></a>*** Settings ***</h2><p>這裡是引入 library 以及初始化的地方</p><p><img src="/img/2021-191743/1634469248.png"></p><ul><li>如果你在別的 .robot 中定義好了需要被引入的 library 或是 Keywords 可以透過 Resource 來達成引入的動作</li><li>Suite Setup 則是在測試跑起來時會做的初始化動作</li></ul><p>這邊幫自己挖個坑，會再發一篇 Suite Setup 跟 Test Setup 的差別。<br>此坑已補上： <a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Robot Framework - Suite Setup V.S Test Setup | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a>  </p><p><img src="/img/2021-191743/1634469266.png"></p><p>看一下 settings.robot</p><p><img src="/img/2021-191743/1634469282.png"></p><p>會使用 settings.robot 來統一引入 library 的原因是為了避免 .robot 的檔案多了，每一個檔案都要重新引入那些 library 實在是麻煩，所以乾脆由一個 file 來控制需要被引入的 library，這樣簡單得多。<br>Variables 讓你可以直接透過檔案的形式讓你引入環境變數<br>Library 則是讓你可以引入 python 或是 Robot Framework 的 library<br>RequestsLibrary 是別人開發好的 Robot Framework 的 Library，需要使用以下指令安裝後才能使用，這個 library 可以讓我們省掉開發 Requests Keyword 的時間。</p><pre><code>python -m pip install robotframework-requests</code></pre><p><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html">RequestsLibrary Keyword 使用方法的文件點我</a></p><h2 id="Variables"><a href="#Variables" class="headerlink" title="*** Variables ***"></a>*** Variables ***</h2><p>這裡是定義這個檔案中會用到的常數</p><p><img src="/img/2021-191743/1634469327.png"></p><p>通常這裡的變數不會直接寫死在這裡，而是會在另一個檔案中定義 config.ini 之類的然後在透過變數來做取用</p><p>所以我這邊也是再挖一個坑，會再發一篇如何定義 config.ini 然後在 robot 裡面中引用那個環境變數<br>此坑已補上：<a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">Robot Framework - 使用 config.ini 管理環境變數 | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a></p><p><img src="/img/2021-191743/1634469353.png"></p><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="*** Keywords ***"></a>*** Keywords ***</h2><p>這裡是自定義關鍵字的地方，可以在這裡定義好關鍵字後，在 Test Case 中使用</p><p><img src="/img/2021-191743/1634469372.png"></p><p>Get Character With Beginning Of The Name，這個是 Keyword 的名稱</p><p>[Arguments] 讓 Keyword 被定義成是可以被傳入參數的，而這個參數名稱是 character_name，定義完成後即可在 Test Case 中使用</p><p>而 Keyword 再往下一層則是 python 的程式碼，以圖中行號 13 的 Get Md5 Hash 為例，這個 Get Md5 Hash 是我自行實作在 <a href="http://common.py/">common.py</a> 的一段 python code</p><p>P.S. <a href="http://common.py/">common.py</a> 已在 settings.robot 中引入。</p><pre><code>import hashlibdef get_md5_hash(data):    hasher = hashlib.md5()    hasher.update(data.encode(&quot;utf-8&quot;))    return hasher.hexdigest()</code></pre><p>以此為例，你可以使用 Get Md5 Hash 或是 get_md5_hash 都可以，只要文件內有統一的格式即可。</p><p>其他的 Keyword 對應官方文件有</p><ul><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Get%20Time">Get Time</a><br>可以指定格式取得 Datetime</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Create%20Dictionary">Create Dictionary</a><br>建立 Dictionary</li><li><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html#GET%20On%20Session">Get On Session</a><br>建立於 Session 上來 request 其方法為 Get</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Return%20From%20Keyword">Return From Keyword</a><br>Get Character With Beginning Of The Name 這一個 Keyword 即將返回的值</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal%20As%20Strings">Should Be Equal As Strings</a><br>斷言（Assert）兩個值的型態為 string 時會是相同的。</li></ul><h2 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="*** Test Cases ***"></a><strong>*** Test Cases ***</strong></h2><p>這裡是定義 Test Case 的地方，會透過使用 Keyword 來組合成需要被自動化的流程</p><p><img src="/img/2021-191743/1634469384.png"></p><h2 id="開發準備"><a href="#開發準備" class="headerlink" title="開發準備"></a><strong>開發準備</strong></h2><p>開發前要準備的就是環境啦</p><ul><li><p>python</p></li><li><p>python package: robotframework</p></li><li><p>python package: robotframework-requests</p><p>python -m pip install robotframework robotframework-requests</p></li></ul><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><p>package 安裝完成後，就可以開始寫一些需要自動化的項目了，開始寫之前先決定要做的自動化項目是什麼</p><ul><li>準備 request 過去 Marvel API 的 token 資訊，Marvel API 的 token 申請，可以參考 repo 中的 readme </li><li>透過 Marvel 的 API 取得角色名稱開頭為 “Tony” 的角色資訊</li><li>唯一一個角色開頭為 “Tony” 的人就是 Tony Stark 所以必須要能取得 Tony Stark 這個名字</li></ul><p>robot 的 Test Suite 如下</p><pre><code>*** Settings ***Resource    settings.robotSuite Setup    Create Session    MARVEL_API    $/&#123;$/&#123;ENV/&#125;.MARVEL_URL/&#125;*** Variables ***$/&#123;api_private_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PRIVATE_KEY/&#125;$/&#123;api_public_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PUBLIC_KEY/&#125;*** Keywords ***Get Character With Beginning Of The Name    [Arguments]    $/&#123;character_name/&#125;    $/&#123;timestamp/&#125;=    Get Time    epoch    $/&#123;hash/&#125;=    Get Md5 Hash    $/&#123;timestamp/&#125;$/&#123;api_private_key/&#125;$/&#123;api_public_key/&#125;    $/&#123;params/&#125;=    Create Dictionary    ts=$/&#123;timestamp/&#125;    apikey=$/&#123;api_public_key/&#125;    hash=$/&#123;hash/&#125;    nameStartsWith=$/&#123;character_name/&#125;    $/&#123;response/&#125;=    Get On Session    alias=MARVEL_API    url=/v1/public/characters    params=$/&#123;params/&#125;    expected_status=200    Return From Keyword    $/&#123;response/&#125;*** Test Cases ***Get Beginning With Tony&#39;s Character Name Info    $/&#123;result/&#125;=    Get Character With Beginning Of The Name    Tony    Should Be Equal As Strings    $/&#123;result.json()[&quot;data&quot;][&quot;results&quot;][0][&quot;name&quot;]/&#125;    Tony Stark</code></pre><h2 id="Repo-點我"><a href="#Repo-點我" class="headerlink" title="Repo 點我"></a><a href="https://github.com/SQZ777/robotframework-marvel">Repo 點我</a></h2><h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><p>若要執行指令如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><h2 id="執行中"><a href="#執行中" class="headerlink" title="執行中"></a>執行中</h2><p><img src="/img/2021-191743/1637074430.png"></p><h2 id="執行後"><a href="#執行後" class="headerlink" title="執行後"></a>執行後</h2><p>在執行後可以看到 Robot Framework 產出的 report</p><p><img src="/img/2021-191743/1637074439.png"></p><p>在 report 中可以看到執行的時間與成功數量等，除此之外，你也能夠透過 report 看見執行的細節，例如 API 的 response json、該步驟的執行時間等</p><p><img src="/img/2021-191743/1637074452.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這一篇介紹了為何要使用 Robot Framework，再到如何看懂 Robot Framework 的文件，希望大家可以因為這篇而看得懂 Robot Framework &lt;(_ _)&gt;</p><p>已補坑：</p><ul><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Suite Setup V.S. Test Setup</a></li><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">在 Robot Framework 中，使用 config.ini 的檔案定義環境變數</a></li></ul><p>2021&#x2F;11&#x2F;16：補充執行所需的環境準備以及實際的題目應用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RobotFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 4/17 技術管理者論壇－商業與技術的平衡</title>
      <link href="/2021/04/18/2021-235858/"/>
      <url>/2021/04/18/2021-235858/</url>
      
        <content type="html"><![CDATA[<p>好久沒參加社群了，筆記一下！ </p><p>昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了</p><p>這天講的內容印象最深刻有 2 個+1個</p><ul><li>Gipi 講的上游理論</li><li>91 來我們這組討論</li><li>我自己提出的問題（群組沒討論，但是我自己想了一輪 XD）</li></ul><h2 id="上游理論"><a href="#上游理論" class="headerlink" title="上游理論"></a>上游理論</h2><p>Gipi 描述了問了大家一個問題</p><blockquote><p>「今天你待的地方是在中游，有一天你發現上游的人開始丟垃圾、拉屎在河裡，讓你平常用的水變成垃圾水、糞水，請問你們會怎麼做？」</p></blockquote><p>台下的人很踴躍的回答了</p><p>「找上游的人理論」</p><p>「烙下游的人一起去找上游的人理論」</p><p>「找別條河」</p><p>．．．</p><p>最後有一個人回答了關鍵的答案 我猜是樁腳</p><blockquote><p>「去幫助上游的人」</p></blockquote><h3 id="為什麼是去幫助上游的人？"><a href="#為什麼是去幫助上游的人？" class="headerlink" title="為什麼是去幫助上游的人？"></a>為什麼是去幫助上游的人？</h3><p>因為上游的人讓河流變髒了，肯定是有原因的，沒有人平白無故把珍貴的資產－河流變糟<br>在幫助他們時，你就必須去了解他為什麼要把這些垃圾、排泄物丟進河裡 這會使你更能體諒他們為何這樣做，也會讓他們知道你不是來出一張嘴的</p><h3 id="和他們一起解決問題是最容易的"><a href="#和他們一起解決問題是最容易的" class="headerlink" title="和他們一起解決問題是最容易的"></a>和他們一起解決問題是最容易的</h3><p>就算你最後沒辦法和他們一同解決這些問題，你仍然能夠在這個幫助的過程中獲得一些經驗，而這些難得的經驗能夠成為你在抵達下一條河流時的養分。<br>千萬不要在發現河流中出現異樣時，只抱怨，不做事，這樣不但沒辦法改變現狀，也無法學習到任何事情。 上述所提到的河流可以替換成公司，中游則是你自己在公司所代表的角色，而上層可以替換成任何與你合作的對象。</p><h2 id="小組討論"><a href="#小組討論" class="headerlink" title="小組討論"></a>小組討論</h2><p>我們這組提到了不少問題，其中有被拿出來討論的就是</p><blockquote><p>如何讓技術能夠量化並且順利推動？</p></blockquote><p>91：「你要做到的是用他的語言來去描述你想做的事情，你所提出的事情要能夠打到他在意的點，舉例來說你要推 CI&#x2F;CD、TDD，商業的人，像是業務、老闆要怎麼懂？」<br>「你要做的是『你跟老闆說你做 OOXX 事情，目的可以節省多少時間』，而使用這個節省的時間來推算能夠節省的金錢」<br>「如果某些提出來的功能很急而影響到你目前的實作進度，你也可以透過埋 log、埋 GA，觀察他所謂『很急』的功能的使用率，讓數據說話」</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li>用對方在乎的事情解釋<ul><li>用時間推算金錢成本，花下去的成本用多少時間可以回收？</li></ul></li></ul><h2 id="我自己提出的問題"><a href="#我自己提出的問題" class="headerlink" title="我自己提出的問題"></a>我自己提出的問題</h2><p>我提出的問題沒有被我們這一組的其他人選擇，因為我自己提出的問題比較沒有符合今天的主題「商業與技術的平衡」（也許是因為菜味十足的我還沒碰到技術與商業平衡的問題 🤡🤡）</p><p>因為最近才剛開始在團隊中整理一些程式碼，幫忙寫一些 Unit Test，在這個過程中發現了一些現象，所以我提出的問題是</p><blockquote><p>如何讓團隊有一個更完整（良好）的開發規範</p></blockquote><p>例如：在 C# 中偏好使用 var 來做變數的宣告等…</p><p>這兩天我思考了一下，我覺得像這樣的程式語言的「使用偏好」，比較像是「傳教」，而不是商業與技術中的平衡，所以沒被拿出來很正常w</p><p><img src="/img/2021-235858/artworks-000118550301-1jpyp5-t500x500.jpg" alt="玖壹壹- 歪國人( 小八2015.5.25 ReMiX - ) by Dj小八Taiwan"></p><p>今天跟我弟討論了一輪，在對話的過程中，我找到了一個…出入，或許說是一個…題目？</p><blockquote><p>如何傳教成功？</p></blockquote><p>首先我必須先認知到傳教不是吵架辯論，而是你認為這個東西超讚，所以你覺得其他人也應該要跟我一起信仰他<br>如果我透過吵架辯論的方式，我應該永遠無法傳教成功，甚至會把他推得更遠（尤其是這個跟我辯論的人，是我的同事）<br>你應該很難想像騎腳踏車上路的傳教士跟機車騎士在路邊爭論打架吧？  </p><p>在這邊先打住，在這邊列一下今天我跟我弟的討論內容</p><p>我：「你覺得到底該怎麼樣，才能讓團隊裡面的人使用到這些偏好？」<br>他：「我覺得沒有必要推這件事，這件事（以偏好使用 var 來說）對於最後所產出的價值並不會影響到很大」<br>我：「所以你的意思是說這些偏好其實都是沒有價值的嗎？」<br>他：「也不能這樣說，舉個我前公司的例子，他們有一個規範是為了方便找到這個 Function 所以在 Class 中的所有 Function 排序是有一定規則的，當我問到我的 Team Lead 時，他就是這麼跟我解釋的，所以我也會認同這件事，因為這個規範就已經是存在，而且我們團隊的人都認同這件事。」 <br>我：「也就是說如果有一個規範，他是由團隊內德高望重的人在專案中使用，那他就會被大家遵守囉？」<br>他：「是」<br>我：「那假設你今天是團隊中德高望重的人，你要怎麼讓大家使用這些偏好？」<br>他、我：「…」</p><p>這個空氣靜默的時間很短，大概有一秒那麼長</p><p>我就想出了一個解答並說：</p><blockquote><p>「這件事並不是由團隊中德高望重的人來讓大家使用，而是在你做這件事情的時候，大家也都認同，在這個情況之下，你也不用『讓』大家使用這些偏好了，他們自己就會『自動』使用這些偏好了」</p></blockquote><p>所以最後的問題就不會是「如何傳教成功？」了</p><p>而是</p><blockquote><p>你在團隊中如何建立 Credit，影響到其他人？</p></blockquote><p>知道真正的問題是這個，做法就變得顯而易見了！</p><p>雖然心中有一些答案但是仍然想問大家的就是，我最後所提到的問題</p><p><strong>你在團隊中如何建立 Credit，影響到其他人？</strong></p><p>以上是今天的筆記，感謝大家收看，如有錯誤麻煩提出來讓我修正 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 社群 </tag>
            
            <tag> 筆記 </tag>
            
            <tag> 商業與技術 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記－什麼是時序耦合（Temporal Coupling）？</title>
      <link href="/2021/04/18/2021-what-is-temporal-coupling/"/>
      <url>/2021/04/18/2021-what-is-temporal-coupling/</url>
      
        <content type="html"><![CDATA[<p>最近在看 <a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式</a><br>其中第四章提到了時序耦合（Temporal Coupling）<br>覺得是一個值得寫下來筆記的東西，所以就產出了這篇。</p><p>第一次看到時序耦合這個詞的時候還以為是…Dio?</p><p><img src="/img/2021-what-is-temporal-coupling/1618680807.png"></p><p>結果並不是，讓我太失望了（並沒有失望）</p><h2 id="正文開始"><a href="#正文開始" class="headerlink" title="正文開始"></a>正文開始</h2><p><strong>耦合是指程式中模組及模組之間資訊或參數依賴的程度。</strong><br><strong>其相對的一個概念的詞叫做聚合性，也就是說低耦合性代表高內聚性。</strong></p><p>時序耦合是多種耦合分類中的其中一種　<a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>時序耦合指的是這個 Class 中含有的 Functions 有隱性的「先後順序」的耦合性，這是一個「Design Smell」<br>舉參考資料的程式碼為例</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public void Initialize(string fileName)  /&#123;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>使用這個程式碼，會是這樣</p><pre><code>var fileName = &quot;C:\test.txt&quot;;var fileLogger = new FileLogger();fileLogger.Initialize(fileName);fileLogger.Write(&quot;Log message.&quot;);</code></pre><p>假設這個 fileLogger 沒有在呼叫 Write 這個 Function 之前先呼叫 Initialize 就會造成 fileLogger 在 Write 訊息的時候造成無法找到檔案名稱的錯誤<br>而這樣子的程式碼所造成的結果就稱之為時序耦合。</p><h2 id="如何避免時序耦合"><a href="#如何避免時序耦合" class="headerlink" title="如何避免時序耦合?"></a>如何避免時序耦合?</h2><h3 id="透過-Constructor-Injection-的方式"><a href="#透過-Constructor-Injection-的方式" class="headerlink" title="透過 Constructor Injection 的方式"></a>透過 Constructor Injection 的方式</h3><p>在這個案例中，可以透過 Constructor Injection 的方式進行注入 fileName 即可<br>範例程式碼</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public FileLoger(string fileName)  /&#123;    if(string.IsNullOrEmpty(fileName))    /&#123;      throw new ArgumentNullException(&quot;fileName&quot;);    /&#125;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>這樣的方式除了可以避免時序耦合之外，也能夠減少外部呼叫的次數（不需要再呼叫 Initialize）。<br>另外也能夠透過建構子的方式觀察到這個 FileLogger 本身所依賴的事情有哪些。</p><p>參考資料：<br><a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br><a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式 (Dependency Injection: Principles, Practices, Patterns, 2&#x2F;e)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>備註：<a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br>這篇當中有提到另一個避免時序耦合的方式（抽象工廠 <strong>abstract factory</strong>），但如果沒有特殊限制的話，我會比較偏好使用本篇所記錄的 constructor injection 的方式來避免時序耦合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 筆記 </tag>
            
            <tag> DI </tag>
            
            <tag> CodeSmell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# - Dotnet core 的 DI 如何在註冊時帶給建構子未註冊進 DI 的服務</title>
      <link href="/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/"/>
      <url>/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/</url>
      
        <content type="html"><![CDATA[<p>因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體</p><h2 id="註冊已經註冊進-DI-的實體"><a href="#註冊已經註冊進-DI-的實體" class="headerlink" title="註冊已經註冊進 DI 的實體"></a>註冊已經註冊進 DI 的實體</h2><h2 id="程式碼準備"><a href="#程式碼準備" class="headerlink" title="程式碼準備"></a>程式碼準備</h2><p>準備 interface IAction 跟 class Action</p><pre><code>public interface IAction/&#123;    void ShakeHands();/&#125;public class Action : IAction/&#123;    public void Dance()    /&#123;        Console.WriteLine(&quot;Dancing!&quot;);    /&#125;/&#125;</code></pre><p>準備一個 dog 的 interface 跟 他的 class，並且需要透過建構子注入 IAction 這個服務</p><pre><code>public interface IDog/&#123;    void DogDance();/&#125;public class Dog : IDog/&#123;    IAction _action;    public Dog(IAction action)    /&#123;        _action = action;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;/&#125;</code></pre><p>蛤? 你說狗不會跳舞怎麼可以繼承 IAction 然後 Dance?</p><p>這不是在跳了嗎(誤</p><p>主程式碼 長這個樣子</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog, Dog&gt;();    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();/&#125;</code></pre><p>就可以看到執行結果</p><pre><code>Dog isDancing!</code></pre><p>如果是已經註冊進 DI 的服務，服務在啟動時會自動幫忙注入已經註冊的實體，所以只要<code>serviceCollection.AddScoped&lt;IDog, Dog&gt;();</code>即可</p><h2 id="註冊時，代入未註冊進-DI-的實體"><a href="#註冊時，代入未註冊進-DI-的實體" class="headerlink" title="註冊時，代入未註冊進 DI 的實體"></a>註冊時，代入未註冊進 DI 的實體</h2><p>這時就需要將原本的 Dog 多新增一點需要依賴的服務啦，最近 Cyberpunk 2077 很紅，那就讓它變成機器狗吧</p><p><img src="/img/2021-DotnetCoreDIConstructorWithParameters/4137968e6d4fab392ba7db14017ec100.jpg" alt="Dogenator | Cyberpunk, Cyberpunk 2077, Dog communication"></p><p>所以就先定義一個 Machine 的 class 吧!</p><pre><code>public class Machine/&#123;    public void Glow()    /&#123;        Console.WriteLine(&quot;Glowing!&quot;);    /&#125;/&#125;</code></pre><p>機器人的特色就是會發光 所以就讓他可以 Glow!</p><p>接下來將狗的 Constructor 變成需要多依賴 Machine 這個 class 吧!</p><pre><code>public interface IDog/&#123;    void DogDance();    void DogGlow();/&#125;public class Dog : IDog/&#123;    IAction _action;    Machine _machine;    public Dog(IAction action, Machine machine)    /&#123;        _action = action;        _machine = machine;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;    public void DogGlow()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _machine.Glow();    /&#125;/&#125;</code></pre><p>主程式碼修改成這樣</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();    dog.DogGlow();/&#125;</code></pre><p>關鍵在於這一行，</p><pre><code>serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));</code></pre><p><code>svc</code> 的類別是 <code>IServiceProvider</code><br><code>new Dog</code> 的意思可以理解為 將 Dog 註冊至 IDog 中<br>而<code>svc.GetService&lt;IAction&gt;(), new Machine()</code>這部分可以理解為取得已經註冊的實體並注入進 new Dog 的這個 constructor 中</p><p>就可以看到執行結果</p><pre><code>Dog isDancing!Dog isGlowing!</code></pre><p>以上為今天的筆記<br>感謝收看!</p><p>本篇的 github 連結:<br><a href="https://github.com/SQZ777/DotnetCoreDIWithParamter">SQZ777&#x2F;DotnetCoreDIWithParamter (github.com)</a><br>Refrence:<br><a href="https://blog.darkthread.net/blog/aspnet-core-di-notes/">筆記 - 不可不知的 ASP.NET Core 依賴注入-黑暗執行緒 (darkthread.net)</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-5.0&WT.mc_id=DOP-MVP-37580#Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_AddScoped__1_Microsoft_Extensions_DependencyInjection_IServiceCollection_System_Func_System_IServiceProvider___0__">ServiceCollectionServiceExtensions.AddScoped 方法 (Microsoft.Extensions.DependencyInjection) | Microsoft Docs</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> Constructor </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# - 如何在 AWS lambda 裡面使用 dotnet core 的 DI</title>
      <link href="/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/"/>
      <url>/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/</url>
      
        <content type="html"><![CDATA[<p>dotnet core 的 DI 很好用</p><p>所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI</p><p>首先先建立一個 interface, 就叫 ITalkService 好了~</p><pre><code>namespace AWSLambdaAndDI/&#123;    public interface ITalkService    /&#123;        string SayHello(string name);    /&#125;/&#125;</code></pre><p>再寫一個他的實體 TalkService</p><pre><code>namespace AWSLambdaAndDI/&#123;    public class TalkService : ITalkService    /&#123;        public string SayHello(string name)        /&#123;            return name + &quot;: hello!&quot;;        /&#125;    /&#125;/&#125;</code></pre><p>這樣一來我們已經有了 interface 也有實作他的 class，接下來就來看一下如何在一般的 function 使用 dotnet core 的 DI 吧</p><p>首先需要使用 dotnet core CLI 來新增 package</p><pre><code>dotnet add package Microsoft.Extensions.DependencyInjection</code></pre><p>裝完之後就可以看到相依性裡面的套件出現 Microsoft.Extensions.DependencyInjection</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615732181.png"></p><p>我使用了 Visual Studio 來建立了一個 AWS Lambda 的專案，初始的程式碼會長這樣，並將這個 lambda 的 function 相依於前面已經實作好的 interface</p><pre><code>using Amazon.Lambda.Core;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    private readonly ITalkService _talkService;    public class Function    /&#123;                /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return input?.ToUpper();        /&#125;    /&#125;/&#125;</code></pre><p>如果要加入 DI ，需要在 constructor 中將需要用的 instance 跟對應到的 interface 進行註冊</p><p>constructor 的 code 會長這個樣子</p><pre><code>public Function()/&#123;  // 建立 DI  var serviceCollection = new ServiceCollection();  // 將 TalkService 註冊進 DI  serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();  var serviceProvider = serviceCollection.BuildServiceProvider();  // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface  this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();/&#125;</code></pre><p>確定好 talkService 註冊並且注入進 this._talkService 之後，就將 talkService 放進 FunctionHandler 中吧!<br>目前的 Lambda Function code 就會長這個樣子</p><pre><code>using Amazon.Lambda.Core;using Microsoft.Extensions.DependencyInjection;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    public class Function    /&#123;        private readonly ITalkService _talkService;        public Function()        /&#123;            // 建立 DI            var serviceCollection = new ServiceCollection();            // 將 TalkService 註冊進 DI            serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();            var serviceProvider = serviceCollection.BuildServiceProvider();            // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface            this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();        /&#125;        // 如果需要 unit test 可以利用這個 constructor 來進行 mock talkService        public Function(ITalkService talkService)        /&#123;            this._talkService = talkService;        /&#125;        /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return this._talkService.SayHello(input);        /&#125;    /&#125;/&#125;</code></pre><p>接著來使用 Mock Lambda Test Tool 來執行看看吧</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615734335.png"></p><p>以上就可以看到結果囉 “SQZ777: hello!”</p><p>如果以上訊息有任何錯誤麻煩告知 感謝各位大大 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> awsLambda </tag>
            
            <tag> dependencyInjection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 將自己做好的 Discord bot 放在 Heroku 上</title>
      <link href="/2020/11/24/2020-putDiscordBotToHeroku/"/>
      <url>/2020/11/24/2020-putDiscordBotToHeroku/</url>
      
        <content type="html"><![CDATA[<p>Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子</p><p>這一篇以 Discord bot 為示範</p><p>首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972847.png"></p><p>點選 Create new app，命名自己的 app</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972936.png"></p><p>新增完畢之後就可以看到這個畫面，接著點選 GitHub</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973124.png"></p><p>這邊要輸入自己要建置的 bot repo name然後按下 Search 之後再按下旁邊那個 Connect 的按鈕<br><a href="https://dotblogs.com.tw/Im_sqz777/2020/11/21/DiscordSetupHelloWorld">如何建置 Discord bot 點這裡</a></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973433.png"></p><p>連結完畢之後會看到這個畫面，下面那個 Deploy Branch 按下去就是把機器人建置起來了<br><strong>但是先等一下!!!</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973597.png"></p><p>這邊需要先設定環境變數，我的機器人範例程式碼是這樣寫的，可以看到我需要環境變數 <strong>DISCORD_TOKEN</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973739.png"></p><p>所以我需要在 Heroku 上面設定 <strong>DISCORD_TOKEN</strong> 這個環境變數，在上面那排欄位中找到 Settings 進來之後點選 Reveal Config Vars</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973843.png"></p><p>點完之後，輸入變數名稱跟變數的值按下 Add 就可以成功新增環境變數</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974007.png"></p><p>在按下 Deploy 前請先確定自己的 package.json 中，有沒有設定好 npm start 要建置的 js file，如下</p><p>Heroku 在 Node.js 的專案中會執行 npm start 來執行專案</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974115.png"></p><p>確認完畢之後就可以回到這個頁面按下 Deploy Branch 囉!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974271.png"></p><p>回到 Discord 就可以看到自己的機器人上線啦!!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974342.png"></p><h2 id="澳門首家線上賭場上線啦"><a href="#澳門首家線上賭場上線啦" class="headerlink" title="澳門首家線上賭場上線啦"></a>澳門首家線上賭場上線啦</h2><p>以上是今天的筆記 感謝大家。</p>]]></content>
      
      
      
        <tags>
            
            <tag> discord </tag>
            
            <tag> heroku </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - Node.js 環境變數套件 dotenv</title>
      <link href="/2020/11/21/2020-231542/"/>
      <url>/2020/11/21/2020-231542/</url>
      
        <content type="html"><![CDATA[<p>開發時一定會用到環境變數，確保 config 可以快速被切換、程式碼不要包含機敏資料等等目的，所以就會透過 config 檔的方式來讀取各種機密資料</p><p>而 Node.js 可以透過 dotenv 來達成這件事</p><p>開始前你需要先安裝套件 dotenv</p><pre><code>npm install dotenv</code></pre><p> 在程式碼中引入這個套件</p><pre><code>require(&#39;dotenv&#39;).config()</code></pre><p>在使用前你需要建立一個檔案叫做 <strong>.env</strong><br>這個套件會去讀取這個檔案，讓這個檔案成為可以被 process.env 讀取的變數，格是為 &#x2F;{&#x2F;{變數名稱&#x2F;}&#x2F;}&#x3D;&#x2F;{&#x2F;{變數資料&#x2F;}&#x2F;}</p><pre><code>BLOG_NAME=SQZ777der技術小本本SECRET_TOKEN=secret tokenDB_CONNECTION=db connection</code></pre><p>透過 dotenv 讀取變數的程式碼如下</p><pre><code>require(&#39;dotenv&#39;).config()console.log(process.env.BLOG_NAME)console.log(process.env.SECRET_TOKEN)console.log(process.env.DB_CONNECTION)</code></pre><p>執行結果如下</p><p><img src="/img/2020-231542/1605971407.png"></p><p>以上是 dotenv 的簡單筆記<br>這邊是上面那些寫的程式碼 repo<br><a href="https://github.com/SQZ777/nodejs_dotenv_for_blog">https://github.com/SQZ777/nodejs_dotenv_for_blog</a></p><p>在一般專案開發時，請勿將 .env 這個檔案 commit 上去，此 repo 只是為了筆記而 commit .env 這個檔案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> config </tag>
            
            <tag> dotenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 透過 Node.js 建置 Discord BOT</title>
      <link href="/2020/11/21/2020-DiscordSetupHelloWorld/"/>
      <url>/2020/11/21/2020-DiscordSetupHelloWorld/</url>
      
        <content type="html"><![CDATA[<p>筆記一下如何透過 Node.js 建置 Discord 機器人</p><h2 id="什麼是-Discord"><a href="#什麼是-Discord" class="headerlink" title="什麼是 Discord"></a>什麼是 Discord</h2><p>Discord 是一個聊天通訊軟體，pc&#x2F;mobile 都可以使用，跟以前的 RC、TS 的軟體蠻像的</p><p>大部分的使用者都是遊戲玩家居多</p><p>他跟 Line 一樣也有提供相關的 API 可以使用!</p><p>本文範例程式碼：<a href="https://github.com/SQZ777/discord_bot_for_blog">https://github.com/SQZ777/discord_bot_for_blog</a></p><h2 id="環境-前置"><a href="#環境-前置" class="headerlink" title="環境&amp;前置"></a>環境&amp;前置</h2><ul><li><a href="https://nodejs.org/zh-tw/download/">Node.js</a></li><li><a href="https://discord.js.org/#/">discord.js</a></li><li><a href="https://discord.com/">Discord account</a></li></ul><h2 id="建立-Discord-Application"><a href="#建立-Discord-Application" class="headerlink" title="建立 Discord Application"></a>建立 Discord Application</h2><p>進到 discord 管理 application 的頁面 <a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a></p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944300.png"></p><p>可以看到自己已經建立的機器人，你的畫面應該是還沒有，所有要點擊右上角 <strong>New Application</strong>，之後命名一下自己的機器人名稱</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944370.png"></p><p>建立完成之後可以看到自己的機器人相關的 token 等等的東西</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949979.png"></p><p>再來左邊的欄位選 bot 之後按下 Add Bot </p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949763.png">選 Yes, do it!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949840.png"></p><p>把 token 先存起來，等等要利用 nodejs 開發機器人的功能時會用到這個 token</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><h2 id="把機器人加入自己的伺服器"><a href="#把機器人加入自己的伺服器" class="headerlink" title="把機器人加入自己的伺服器"></a>把機器人加入自己的伺服器</h2><p>按下左邊欄位 OAuth2 之後 scopes 選擇 bot, 因為目前只有傳送訊息 所以 bot permissions 選擇 Send Messages，箭頭處的部分就是邀請 bot 加入伺服器的連結，把它複製起來。</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950673.png"></p><p>把剛才那個邀請連接用瀏覽器連結過去之後就會詢問你要將機器人放進哪個伺服器，選好之後按下繼續即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950830.png"></p><p>然後會問你是否需要授權，按下授權即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950878.png"></p><p>在伺服器就會看到機器人加入的訊息</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950936.png"></p><h2 id="開始透過-Node-js-建置機器人"><a href="#開始透過-Node-js-建置機器人" class="headerlink" title="開始透過 Node.js 建置機器人"></a>開始透過 Node.js 建置機器人</h2><p>先使用 npm init 建立 package.json，再透過 npm 安裝 <a href="https://discord.js.org/#/">discord.js</a></p><pre><code>npm i discord.js</code></pre><p>建立一個檔案 app.js，範例原始碼來自於 <a href="https://discord.js.org/#/">discord.js</a> </p><pre><code>const Discord = require(&#39;discord.js&#39;);const client = new Discord.Client();client.on(&#39;ready&#39;, () =&gt; /&#123;  console.log(`Logged in as $/&#123;client.user.tag/&#125;!`);/&#125;);client.on(&#39;message&#39;, msg =&gt; /&#123;  if (msg.content === &#39;ping&#39;) /&#123;    msg.reply(&#39;Pong!&#39;);  /&#125;/&#125;);client.login(&#39;token&#39;);</code></pre><p>以上程式碼將最下方 client.login(‘token’) 的 ‘token’ 取代成剛才複製起來的 token 就可以了，忘記在哪這邊圖片附上複製位置</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><p>將機器人加入伺服器之後會發現機器人都是離線狀態(如圖)，是因為機器人目前沒有登入，我們需要執行我們的程式碼讓機器人登入</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951075.png"></p><p>執行 npm start，就會發現機器人登入了</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951375.png"></p><p>這時候就可以透過自己傳送 訊息 “ping” 來讓機器人回應你 “pong”，這樣就成功完成了一個機器人的 Hello World 囉!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951410.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://discord.com/developers/docs/intro">Discord 官方文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> bot </tag>
            
            <tag> discord </tag>
            
            <tag> discord.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 使用 PowerShell 安裝 aws cli</title>
      <link href="/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/"/>
      <url>/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/</url>
      
        <content type="html"><![CDATA[<p>最近蠻常用到 AWS 的服務，而且需要在建機器的時候透過 powershell 來安裝 aws cli，所以就記錄一下這篇</p><p>本篇記錄時間為 2020&#x2F;09&#x2F;24，aws cli 的版本會隨著時間更新，今天示範的版本是 aws cli v2<br>請注意以下 $dlurl 的檔案位置是否已被 AWS 官方變更!</p><pre><code>#https://docs.aws.amazon.com/zh_tw/cli/latest/userguide/install-cliv2-windows.html$dlurl = &quot;https://awscli.amazonaws.com/AWSCLIV2.msi&quot;$installerPath = Join-Path $env:TEMP (Split-Path $dlurl -Leaf)Invoke-WebRequest $dlurl -OutFile $installerPathStart-Process -FilePath msiexec -Args &quot;/i $installerPath /passive&quot; -Verb RunAs -WaitRemove-Item $installerPath</code></pre><p>執行結果如下</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600961818.png"></p><p>會發現透過 aws –version 來確認是否安裝完成時，會出現錯誤，這時候如過不想要重開 powershell 就執行<a href="https://dotblogs.com.tw/Im_sqz777/2020/09/24/ReloadThePathInPowerShell">上一篇記錄</a>的程式碼</p><pre><code>$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;Machine&quot;)+ &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;User&quot;)</code></pre><p>執行之後再執行一次 aws –version 就可以成功執行囉~</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600962069.png"></p><p>source: <a href="https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf">https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> cli </tag>
            
            <tag> install </tag>
            
            <tag> powershell </tag>
            
            <tag> 安裝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell - 如何重新 load 環境變數</title>
      <link href="/2020/09/24/2020-ReloadThePathInPowerShell/"/>
      <url>/2020/09/24/2020-ReloadThePathInPowerShell/</url>
      
        <content type="html"><![CDATA[<p>最近在寫 powershell 來安裝一些哩哩摳摳的東西然後使用，所以遇到了需要不在重新開啟 powershell 的時候 re-load 環境變數的狀況</p><p>今天就紀錄一下在不關閉 powershell 的情況下，用指令重新 load 環境變數的方式</p><p>首先要知道如何看到得到目前的 環境變數，在 powershell 裡面用這個指令就可以得到環境變數</p><pre><code>$env:Path</code></pre><p>這次用 powershell 安裝 python 為示範</p><p><img src="/img/2020-ReloadThePathInPowerShell/1600957666.jpg"></p><p>可以看到安裝完 python 之後，使用 python –version 沒辦法找到 python，因為需要 reload 環境變數</p><p>這時候就需要用到以下指令</p><pre><code>$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;Machine&quot;)+ &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;User&quot;)</code></pre><p>下完指令就可以成功使用 python 的指令了</p><p><img src="/img/2020-ReloadThePathInPowerShell/1600957696.jpg"></p><p>source: <a href="https://stackoverflow.com/questions/17794507/reload-the-path-in-powershell/31845512">https://stackoverflow.com/questions/17794507/reload-the-path-in-powershell/31845512</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python - Mutable Default Arguments 筆記</title>
      <link href="/2020/09/04/2020-090843/"/>
      <url>/2020/09/04/2020-090843/</url>
      
        <content type="html"><![CDATA[<p>過去遇到毛毛蟲總是會想著「為什麼」這個要出現毛毛蟲，而這一次出現毛毛蟲也同樣想了這個「為什麼」，而且覺得比較特別，所以就把他筆記一下w</p><p>先來寫了以下這段 code</p><pre><code>def add_something_to_array(element, array=[]):    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)</code></pre><p>結果也會很簡單的回覆給我 [‘a’]</p><p><img src="/img/2020-090843/1599181601.png"></p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>如果第二次呼叫他的時候，問題就會出現了</p><p>把 code 先改成以下的樣子</p><pre><code>def add_something_to_array(element, array=[]):    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)my_array_b = add_something_to_array(&quot;b&quot;)print(my_array_a)print(my_array_b)</code></pre><p>來看看執行的結果</p><p><img src="/img/2020-090843/1599181616.png"></p><p>就會發現到裡面這個 array，會被外部重複使用，原因是什麼呢?</p><p>Python 在定義 function 的預設參數時，只會被定義一次，而不是在每次呼叫的時候重新定義一次，所以上面這一小段 code: array &#x3D; [] 才會一直被重複使用。</p><h2 id="那該怎麼做呢"><a href="#那該怎麼做呢" class="headerlink" title="那該怎麼做呢?"></a>那該怎麼做呢?</h2><p>你應該要避免在預設的參數裡面設定一個可變動的變數，將可變動的預設參數改為 None，在程式碼裡面判斷並賦予原本預設的可變動變數，如下</p><pre><code>def add_something_to_array(element, array=None):    if array is None:        array=[]    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)my_array_b = add_something_to_array(&quot;b&quot;)print(my_array_a)print(my_array_b)</code></pre><p>當初在 code review 的時候遇到這樣寫法，還以為是在炫技，抱歉是我錯了</p><p>執行結果如下，這樣一切就會跟我們預想的結果相同啦!</p><p><img src="/img/2020-090843/1599181631.png"></p><h2 id="感謝網友陳信宏補充，使用-frozenset-也能夠避免此-code-lint-警告"><a href="#感謝網友陳信宏補充，使用-frozenset-也能夠避免此-code-lint-警告" class="headerlink" title="感謝網友陳信宏補充，使用 frozenset() 也能夠避免此 code lint 警告"></a>感謝網友陳信宏補充，使用 frozenset() 也能夠避免此 code lint 警告</h2><pre><code>def aa(a, b=frozenset()):  return [*b, a]print(aa(&quot;1&quot;))# [&#39;1&#39;]print(aa(&quot;2&quot;, frozenset([&quot;a&quot;, &quot;v&quot;])))# [&#39;v&#39;, &#39;a&#39;, &#39;2&#39;]</code></pre><p><img src="/img/2020-090843/1599230662.png"></p><p>參考來源: <a href="https://docs.python-guide.org/writing/gotchas/">https://docs.python-guide.org/writing/gotchas/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mutable Default Arguments </tag>
            
            <tag> Python </tag>
            
            <tag> 筆記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 您預計要執行 .Net Core 程式，但 dotnet-ef 並不存在。</title>
      <link href="/2020/09/03/2020-220256/"/>
      <url>/2020/09/03/2020-220256/</url>
      
        <content type="html"><![CDATA[<p>有點久沒寫 dotnet core</p><p>今天重新把環境都裝回來，然後趁機更新到最新版本的 dotnet core</p><p>於是在開發的第一步要執行 dotnet ef 就發生了錯誤</p><p>如圖</p><p><img src="/img/2020-220256/1599141736.png"></p><p>原來是因為在 dotnet core 3.0 之後 .NET SDK 就不再包含 dotnet ef，所以如果要在 dotnet 裡面用 dotnet ef 的指令，必須要先進行安裝</p><pre><code>dotnet tool install --global dotnet-ef</code></pre><p>執行安裝後就可以看到安裝完成的畫面啦</p><p><img src="/img/2020-220256/1599141755.png"></p><p>歡迎回來 dotnet-ef!</p>]]></content>
      
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - ASP.NET Core 使用 LibMan CLI</title>
      <link href="/2020/09/03/2020-222746/"/>
      <url>/2020/09/03/2020-222746/</url>
      
        <content type="html"><![CDATA[<p>用 libman 來管理需要的前端程式庫</p><h2 id="libman-是甚麼"><a href="#libman-是甚麼" class="headerlink" title="libman 是甚麼?"></a>libman 是甚麼?</h2><p><em>程式庫管理員 (LibMan) 是輕量型的用戶端程式庫取得工具。 LibMan 會從檔案系統或內容傳遞網路 (CDN)下載熱門的程式庫和架構。 支援的 Cdn 包括 CDNJS、 jsDelivr和 unpkg。 所選程式庫檔會擷取並放置在 <a href="http://asp.net/">ASP.NET</a> Core 專案中的適當位置。</em></p><p>source: <a href="https://docs.microsoft.com/zh-tw/aspnet/core/client-side/libman/?view=aspnetcore-3.1">https://docs.microsoft.com/zh-tw/aspnet/core/client-side/libman/?view=aspnetcore-3.1</a></p><p>環境準備</p><ul><li>.NET Core 2.1 SDK 以上</li></ul><p>安裝指令</p><pre><code>dotnet tool install -g Microsoft.Web.LibraryManager.Cli</code></pre><p><img src="/img/2020-222746/1599143155.png"></p><p>使用指令來確認是否安裝成功</p><pre><code>libman --version</code></pre><p><img src="/img/2020-222746/1599143175.png"></p><p>使用指令來建立 libman.json</p><pre><code>libman init</code></pre><p>預設就直接用 cdnjs 即可 (直接按下 Enter)</p><p><img src="/img/2020-222746/1599143190.png"></p><p>會看到目前的資料夾出現 libman.json，內容為</p><pre><code>/&#123;  &quot;version&quot;: &quot;1.0&quot;,  &quot;defaultProvider&quot;: &quot;cdnjs&quot;,  &quot;libraries&quot;: []/&#125;</code></pre><h2 id="以安裝-jquery-為例"><a href="#以安裝-jquery-為例" class="headerlink" title="以安裝 jquery 為例"></a>以安裝 jquery 為例</h2><p>使用以下 libman 指令來安裝 jquery 到指定資料夾中</p><pre><code>libman install jquery@3.2.1 --provider cdnjs --destination wwwroot/scripts/jquery --files jquery.min.js</code></pre><p><img src="/img/2020-222746/1599143216.png"></p><p>安裝完成後 libman.json 的內容會如下</p><pre><code>/&#123;  &quot;version&quot;: &quot;1.0&quot;,  &quot;defaultProvider&quot;: &quot;cdnjs&quot;,  &quot;libraries&quot;: [    /&#123;      &quot;library&quot;: &quot;jquery@3.2.1&quot;,      &quot;destination&quot;: &quot;wwwroot/scripts/jquery&quot;,      &quot;files&quot;: [        &quot;jquery.min.js&quot;      ]    /&#125;  ]/&#125;</code></pre><p>之後只要根據這一個 libman.json 即可使用以下指令來重新還原專案需要的檔案</p><pre><code>libman restore</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> libman </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 使用 Windows 的 command 建立指定大小檔案</title>
      <link href="/2020/05/21/2020-171333/"/>
      <url>/2020/05/21/2020-171333/</url>
      
        <content type="html"><![CDATA[<p>近期因為工作的關係所以需要測試到電腦 full disk 的狀態，所以紀錄一下該如何使用 command 的指令產生指定大小的檔案</p><p>這次要記錄的是指令 “fsutil”，data_length 的單位是 bytes</p><pre><code>fsutil file createnew &lt;file_name&gt; &lt;data_length&gt;</code></pre><p>1KB &#x3D; 1 * 1024 bytes &#x3D; 1024</p><p>1MB &#x3D; 1 * 1024 * 1024 bytes &#x3D; <a href="tel:1048576">1048576</a></p><p>1GB &#x3D; 1 * 1024 * 1024 * 1024 bytes &#x3D; <a href="tel:1073741824">1073741824</a></p><p>1TB &#x3D; 1 * 1024 * 1024 * 1024 * 1024 bytes &#x3D;<a href="tel:1099511627776">1099511627776</a></p><p>以建立 100MB 為例</p><p>因為 100MB &#x3D; 100 * 1024 * 1024 &#x3D; 104857600</p><p>所以，指令如下</p><pre><code>fsutil file createnew test 104857600</code></pre><p>產生檔案之後就可以右鍵看一下檔案的大小囉</p><p><img src="/img/2020-171333/1590052327.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> command </tag>
            
            <tag> file </tag>
            
            <tag> shellScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>測試 - 從哲學解釋測試</title>
      <link href="/2020/04/23/2020-224619/"/>
      <url>/2020/04/23/2020-224619/</url>
      
        <content type="html"><![CDATA[<p>最近因為看了一本書 _Lessons Learned in Software Testing_，其中有一堂課說學習哲學的其中一個分支－知識論，它可以幫助測試的工作，於是就開啟了我關注「哲學」的開關，然後就產生了這篇紀錄。</p><p><img src="/img/2020-224619/1587652681.png"></p><p>首先來簡單描述一下知識論，知識論要問的是「你如何評斷這個知識是 100% 正確的」</p><h2 id="何謂知識"><a href="#何謂知識" class="headerlink" title="何謂知識"></a>何謂知識</h2><p>在知識論中是這樣子論述的，知識是一件被相信且經過證實的事實</p><p><img src="/img/2020-224619/1587652731.png">- 知識既是真的，又被相信是真的，是交集。圖來自於維基百科</p><blockquote><p>知識並不會因為自己相信就等同於真實 就如同你相信這個系統沒有 bug，並不會因為你的相信而沒有 bug 所有不能稱為「知識」的，只能稱之為「可能的觀點」</p></blockquote><h2 id="橋可不可以過？"><a href="#橋可不可以過？" class="headerlink" title="橋可不可以過？"></a>橋可不可以過？</h2><p>有一天小明與小華在散步，散步到了橋的入口，小明有去過並且知道過了橋之後，可以看見名山勝水的風景</p><p>小明說「這個橋，可以過」</p><p>小華卻說「這個橋，不能過」</p><p><img src="/img/2020-224619/1590136255.png"></p><p>在他們講話的過程中，有一群人走了過去，很不幸的，然後橋就斷了</p><p><img src="/img/2020-224619/1590136353.gif">   </p><p>我們可以在這個事件中得知，知識與信仰是不同的。</p><p>而小明的相信，是錯的，因為這個橋就是不安全的，如果要讓「橋是否為安全」這件事情成為一個「知識」，那我們就必須得確認「每一次過橋是安全還是不安全」，實際上也不可能完全的「有效」確認的，原因是人類尚無法「測得」宇宙所有不可見粒子(因子)。</p><blockquote><p>_故而信仰（英語：Faith）與相信（英語：Believe）不同，信仰是即使普遍經驗顯示是錯的，但憑著信仰與累積的「特殊經驗」或「個人經驗」等「超自然經驗」，卻「繼續相信」下次會轉變為對的，顯示出「偶發狀況」或一連串持續性地「偶發狀況」。_自維基百科</p></blockquote><h2 id="知識與測試"><a href="#知識與測試" class="headerlink" title="知識與測試"></a>知識與測試</h2><p>我認為產品的知識，以知識的角度來出發理解會是如下圖，通過 <em>測試行為</em> 來驗證 <em>系統實作</em> 是否符合預期，就可以獲得 <em>產品知識</em></p><p><img src="/img/2020-224619/1590136382.png"></p><p>系統實作：紅色（左邊），產品知識：黃色（交集處的圓圈），測試（預言）：藍色（右邊），交集卻不是產品知識的部分定義為：非產品知識</p><p>P.S. 我認為，測試這回事是沒有限制的，所以不應該有如圖中的外框限制，但為了方便解釋所以加了外框</p><h3 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h3><p><img src="/img/2020-224619/1590136437.png"></p><p>在軟體開發的世界中，測試所得出的「產品知識」是會因為 Release 之後讓「系統實作」的不同而導致「產品知識」有「時間性」</p><p>意思就是，此時此刻的「產品知識」在下一秒就會因為 Release 而導致變化，所以軟體會有「版本」的差異性，讓每一個「產品知識」有了「版本」的概念，就能夠對齊目前某個版本的產品狀態（雖然仍然不能 100% 確定）</p><p>在軟體測試中需要被固定住的「環境因素」非常多，只用圖中的三個名詞其實是不足的，例如：使用者的環境（網路、手機規格、電腦規格等）、資料庫已成載的資料量、伺服器因素（放置位置、雲端還是地端、規格、伺服器系統版本等）、當下伺服器的狀態（CPU 使用率、RAM 使用率、多少人同時在線上等）、程式語言版本等等狀態，都會影響到軟體測試的結果</p><p>以下開放舉例</p><h2 id="那測試人員該怎麼做？"><a href="#那測試人員該怎麼做？" class="headerlink" title="那測試人員該怎麼做？"></a>那測試人員該怎麼做？</h2><p><img src="/img/2020-224619/1587652992.png"></p><p>以橋的那個例子做延伸</p><p>測試人員能做的，就是盡自己的職責（廢話w）</p><p>在橋搭建起來之前，思考這座橋的相關問題，例如：為何需要搭建這座橋？、沒有這座橋可以用什麼替代方案解決要到對面問題？、我們要用什麼材料做這個橋？、這座橋怎麼樣才算是完成？等等…</p><ul><li>為何需要搭建這座橋？－理解蓋這座橋的原因，</li><li>沒有這座橋可以用甚麼替代方案解決要到對面的問題？－或許蓋橋不是唯一的解決方案，有可能會有較低成本的方式解決，甚至發現不需要橋也能方便快速地抵達到對面</li><li>我們要用什麼材料做這個橋？－這個會決定這座橋的年齡、可乘載人數等等</li><li>這座橋怎麼樣才算是完成？－決定這座橋的驗收方式，讓其他蓋這座橋的人也知道 DOD （definition of done）</li><li>…</li></ul><p>在橋搭建起來之後，測試人員要做的就是去即將被交付的這座橋，做各種可能的「檢查」，螺絲有沒有鎖好、橋的寬度是否與當初設計相符、橋的路面上有沒有坑洞、橋的旁邊是否有圍牆、圍牆是否堅固等</p><p>測試人員在盡責的做完各種「檢查」之後，提出詳細的報告，描述著某一個時刻，橋的各種狀態已經檢查完畢沒有問題，而這樣的檢查結果報告出來之後，團隊成員就會有一定的信心，最後才將這座橋交付出來。</p><p><strong>ＯＳ：你認為，測試範圍是有限，還是無限的？</strong></p><p>以上是我的紀錄，感謝閱讀，歡迎大家一起討論</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> 知識 </tag>
            
            <tag> 哲學 </tag>
            
            <tag> 測試 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - Locust 安裝 與 HelloWorld</title>
      <link href="/2020/03/29/2020-locust-helloworld/"/>
      <url>/2020/03/29/2020-locust-helloworld/</url>
      
        <content type="html"><![CDATA[<p>今天要筆記的是 Locust，可以網站的壓力測試的工具。</p><p>Week3 - <a href="https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/">六角學院的鼠年全馬鐵人挑戰</a></p><p>Locust，翻譯成中文是蝗蟲的意思，就是想要模擬像是蝗蟲一般的蜂擁而至某個網站的概念。</p><p>Locust 是以 Python 來撰寫完成的一個工具，其 Script File 也是用Python來撰寫，有 Web UI的簡單界面，因為 Locust 本身是很輕量化的，所以他是一個易於擴展的工具。</p><p>官網連結: <a href="https://locust.io/">https://locust.io/</a> </p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>locust 在  <a href="https://pypi.org/project/locustio/">PyPI</a> 上面可以取得，所以你可以透過 pip 來安裝 locust</p><pre><code>python3 -m pip install locustio</code></pre><p>安裝完成之後使用下列指令確認是否安裝成功</p><pre><code>locust --help</code></pre><p>詳細可參照官方文件：<a href="https://docs.locust.io/en/stable/installation.html">https://docs.locust.io/en/stable/installation.html</a></p><h2 id="寫個簡單的-HelloWorld"><a href="#寫個簡單的-HelloWorld" class="headerlink" title="寫個簡單的 HelloWorld"></a>寫個簡單的 HelloWorld</h2><p>先撰寫一個簡單的 locust file</p><p>引入 locust 中的 HttpLocust, TaskSet, task</p><pre><code>from locust import TaskSet, task</code></pre><p>定義 Locust 要執行的 Task functions</p><p>沒有加入 @task 這個 decorator 將不會在壓力測試執行的過程中被執行</p><pre><code>class HelloLocust(TaskSet):    @task  # 要在壓力測試中被執行的 function 加入 @task 這個 decorator    def say(self):        print(&quot;Hello Locust&quot;)    def will_not_execute_by_locust(self):  # 沒有加入 @task 就不會在執行壓力測試時被執行到        print(&quot;will not executed&quot;)</code></pre><p>定義 Locust 的 User Setting</p><p>在這裡要做的是指定要被 Locust 執行的 Task Set, wait time…等 (這裡沒有指定等待時間，預設為1000ms)</p><pre><code>class User(Locust):    task_set = HelloLocust</code></pre><p>檔名：<a href="http://locustfile.py/">locustfile.py</a> 完整程式碼如下</p><pre><code>from locust import Locust, TaskSet, taskclass HelloLocust(TaskSet):    @task  # 要在壓力測試中被執行的 function 加入 @task 這個 decorator    def say(self):        print(&quot;Hello Locust&quot;)    def will_not_execute_by_locust(self):  # 沒有加入 @task 就不會在執行壓力測試時被執行到        print(&quot;will not executed&quot;)class User(Locust):    task_set = HelloLocust</code></pre><p>執行 Command:</p><pre><code>locust</code></pre><p>執行結果：</p><p><img src="/img/2020-locust-helloworld/1585492589.png"></p><p>即可在 瀏覽器連線到 localhost:8089</p><p><img src="/img/2020-locust-helloworld/1585492601.png"></p><p>Number of users to simulate: 模擬的人數</p><p>Hatch rate: 每秒產生的 User 數量 （最大值為模擬人數）</p><p>Start swarming: 開始進行壓力測試</p><p>按下 Start swarming 之後，就可以看到 terminal 一直出現 Hello Locust （模擬人數為 1, Hatch Rate 為 1）</p><p><img src="/img/2020-locust-helloworld/1585492612.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> w3HexSchool </tag>
            
            <tag> locust </tag>
            
            <tag> loadTesting </tag>
            
            <tag> 壓力測試 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell Script - 如何引用其他 Shell Script 檔案中的 function</title>
      <link href="/2020/03/22/2020-230120/"/>
      <url>/2020/03/22/2020-230120/</url>
      
        <content type="html"><![CDATA[<p>此篇同樣是筆記，這個指令大概是過去一年中很常在 shell script 用的一個 keyword</p><p>Week2 - <a href="https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/">六角學院的鼠年全馬鐵人挑戰</a></p><p>本篇記錄的東西說穿了就只是一個指令就是 source</p><p>但這篇特別拿出來寫的目的是覺得這一個指令是在做 CI 的時候很常用的技巧(吧?</p><p>在做 CI 的時候，常常會寫了好大一串的 shell script ，但為了要讓程式碼可以更好被呼叫、提高可讀性，常常有些一串 shell script 會被包裝成檔案或是 function，這一篇要記錄的就是如何呼叫被包裝成檔案的 shell script</p><p>先寫一段 Code</p><p>file name: hello_world.sh</p><pre><code>#!/bin/shfunction HelloWorld /&#123;  echo &quot;Hello World!&quot;/&#125;</code></pre><p>這時在 command line 中輸入</p><pre><code> hello_world.sh</code></pre><p>在 command line 中，就可直接使用這個檔案中的 function</p><p><img src="/img/2020-230120/1584889152.png"></p><p>在 shell script 裡面做 source</p><p>在開始前改寫一下 原本 hello_world.sh 的檔案內容 讓他可以帶入參數</p><pre><code>#!/bin/shHelloWorld() /&#123;  echo &quot;$1: Hello World!&quot;/&#125;</code></pre><p>再新增一個檔案叫做 <a href="http://sqz777.sh/">sqz777.sh</a></p><pre><code>#!/bin/shsource ./hello_world.shHelloWorld sqz777</code></pre><p>這時候在 command line 呼叫就會直接出現 <strong>sqz777: Hello World</strong></p><p><img src="/img/2020-230120/1584889159.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> shellScript </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command Line  - 常用的各種基本指令</title>
      <link href="/2020/03/13/2020-224113/"/>
      <url>/2020/03/13/2020-224113/</url>
      
        <content type="html"><![CDATA[<p>快一年沒寫文了，先寫一篇簡單的筆記 OAO</p><p>把這一年以來累積的債務(?)清償一下<br>順便參加<a href="https://www.hexschool.com/2019/11/14/2019-11-14-w3Hexschool-2020-challenge/">六角學院的鼠年全馬鐵人挑戰</a></p><p>今天要記錄的是自己平常常用的指令</p><h2 id="建立檔案-touch"><a href="#建立檔案-touch" class="headerlink" title="建立檔案 - touch"></a>建立檔案 - touch</h2><p>建立名為 hello.txt 的檔案</p><pre><code>touch hello.txt</code></pre><p>建立2個檔案</p><pre><code>touch hello1.txt hello2.txt</code></pre><p>若要建立 3 個檔案則在後面加上另一個檔名即可</p><h2 id="複製檔案-copy-cp"><a href="#複製檔案-copy-cp" class="headerlink" title="複製檔案(copy) - cp"></a>複製檔案(copy) - cp</h2><p>複製 hello.txt 其檔名為 hello2.txt</p><pre><code>cp hello.txt hello2.txt</code></pre><h2 id="移動檔案-move-mv"><a href="#移動檔案-move-mv" class="headerlink" title="移動檔案(move) - mv"></a>移動檔案(move) - mv</h2><p>移動 hello.txt 到 test 這個目錄</p><pre><code>mv hello.txt ./test</code></pre><p>再從 test 移動 回來當前目錄</p><pre><code>mv ./test/hello.txt .</code></pre><h2 id="移除檔案-remove-rm"><a href="#移除檔案-remove-rm" class="headerlink" title="移除檔案 (remove) - rm"></a>移除檔案 (remove) - rm</h2><p>移除名為 hello.txt 的檔案</p><pre><code>rm hello.txt</code></pre><p>如果檔案不存在則會出現錯誤訊息</p><pre><code>rm: cannot remove &#39;hello.txt&#39;: No such file or directory</code></pre><h2 id="建立目錄-make-directory-mkdir"><a href="#建立目錄-make-directory-mkdir" class="headerlink" title="建立目錄 (make directory) - mkdir"></a>建立目錄 (make directory) - mkdir</h2><p>建立名為 hello 的目錄</p><pre><code>mkdir hello</code></pre><h2 id="移除目錄-remove-rmdir"><a href="#移除目錄-remove-rmdir" class="headerlink" title="移除目錄 (remove) - rmdir"></a>移除目錄 (remove) - rmdir</h2><p>移除名為 hello 的目錄</p><pre><code>rmdir hello</code></pre><h2 id="查看檔案及子目錄-ls"><a href="#查看檔案及子目錄-ls" class="headerlink" title="查看檔案及子目錄 - ls"></a>查看檔案及子目錄 - ls</h2><p>列出所有檔案及子目錄</p><pre><code>ls</code></pre><p>列出詳細資料</p><pre><code>ls -l</code></pre><p>列出隱藏資料</p><pre><code>ls -a</code></pre><h2 id="顯示目前目錄-pwd"><a href="#顯示目前目錄-pwd" class="headerlink" title="顯示目前目錄 - pwd"></a>顯示目前目錄 - pwd</h2><pre><code>pwd</code></pre><p><img src="/img/2020-224113/1584110224.png"></p><h2 id="更換當前目錄-cd"><a href="#更換當前目錄-cd" class="headerlink" title="更換當前目錄 - cd"></a>更換當前目錄 - cd</h2><p>到根目錄</p><pre><code>cd /</code></pre><p>到上一層目錄</p><pre><code>cd ..</code></pre><p>若對這個 「..」有疑問可以參考此篇: <a href="https://dotblogs.com.tw/Im_sqz777/2017/07/26/220713">Web 基本觀念 - 相對路徑 和 絕對路徑</a></p><p>Windows 若當前目錄在 C槽想移動到 D槽時直接輸入「槽:」</p><pre><code>D:</code></pre><h2 id="執行-Shell-Script-檔案-sh"><a href="#執行-Shell-Script-檔案-sh" class="headerlink" title="執行 Shell Script 檔案 - sh"></a>執行 Shell Script 檔案 - sh</h2><pre><code>sh 檔案目標</code></pre><p>準備檔案: <a href="http://test.sh/">test.sh</a></p><pre><code>echo Hello</code></pre><p>執行 sh <a href="http://test.sh/">test.sh</a> 結果如下</p><p><img src="/img/2020-224113/1584110244.png"></p><h2 id="清除畫面-clear-cls-for-windows"><a href="#清除畫面-clear-cls-for-windows" class="headerlink" title="清除畫面 - clear (cls for windows)"></a>清除畫面 - clear (cls for windows)</h2><p>如果是 linux 系統使用 clear，windos 使用 cls 清除 console 畫面</p><pre><code>clearcls</code></pre><p><img src="/img/2020-224113/1584110255.gif"></p>]]></content>
      
      
      
        <tags>
            
            <tag> shellScript </tag>
            
            <tag> w3HexSchool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - mobile http request 攔截器攔起來－Charles</title>
      <link href="/2019/05/31/2019-003722/"/>
      <url>/2019/05/31/2019-003722/</url>
      
        <content type="html"><![CDATA[<p>本篇將介紹如何設定 Charles 並使用 Charles 進行 http&#x2F;https request 的攔截</p><p>某些事情，用攔截器其實挺方便的，比方說可以把攔截下來的 api entry point, request content, headers 透過某種方式使其變成可以 daily run 的 api test job</p><p>有幾個地方需要設定</p><ul><li>Windows</li><li>Mobile (iOS) CA設定</li><li>mobile wifi proxy 設定</li></ul><p>廢話不多說 本次使用的就是 Charles</p><p>主要可以透過 proxy的方式來debug web&#x2F;moblie 等裝置用的工具</p><p><img src="/img/2019-003722/1559232899_89347.png">  </p><p>首先到官網把 Charles下載下來，我使用的是試用版，專業版需要付費~<br>但個人目前使用試用版就夠惹</p><p><a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a></p><h2 id="Windows-設定"><a href="#Windows-設定" class="headerlink" title="Windows 設定"></a>Windows 設定</h2><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</p><p><img src="/img/2019-003722/1559231072_68719.png">   </p><h3 id="step-2-安裝憑證"><a href="#step-2-安裝憑證" class="headerlink" title="step 2 安裝憑證"></a>step 2 安裝憑證</h3><p><img src="/img/2019-003722/1559231057_98418.png"></p><p>存放位置使用目前使用者即可</p><p><img src="/img/2019-003722/1559231134_07366.png"></p><p>憑證存放區選擇受信任的憑證授權單位</p><p><img src="/img/2019-003722/1559231186_13219.png"></p><p>按下完成</p><p><img src="/img/2019-003722/1559231207_18453.png"></p><p>就會出現匯入成功的畫面</p><p><img src="/img/2019-003722/1559231234_80837.png"></p><p>可以到控制台右上角輸入憑證 -&gt; 點選管理使用者憑證</p><p><img src="/img/2019-003722/1559231323_99948.png"></p><p>再到受信任的跟憑證授權單位確認 Charles Proxy CA是否有成功匯入</p><p><img src="/img/2019-003722/1559231287_72645.png"></p><h2 id="Mobile-iOS-CA設定"><a href="#Mobile-iOS-CA設定" class="headerlink" title="Mobile (iOS) CA設定"></a>Mobile (iOS) CA設定</h2><h3 id="Step-3-mobile-憑證安裝"><a href="#Step-3-mobile-憑證安裝" class="headerlink" title="Step 3 mobile 憑證安裝"></a>Step 3 mobile 憑證安裝</h3><p>Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile or Remote Browser</p><p><img src="/img/2019-003722/1559231389_55187.png"></p><p>點開後即可看到提示</p><p><img src="/img/2019-003722/1559231434_51841.png"></p><p>在 iOS 請使用 safari 開啟並至 <a href="http://chls.pro/ssl">chls.pro&#x2F;ssl</a> 進行憑證下載</p><p><img src="/img/2019-003722/1559231902_7638.png"></p><p>接下來就照以下步驟進行設定</p><p><img src="/img/2019-003722/1559232269_13256.png"></p><p>這樣就好了嗎?</p><h2 id="還沒"><a href="#還沒" class="headerlink" title="還沒"></a>還沒</h2><p>iOS比較嚴謹 所以還要執行以下步驟</p><p><img src="/img/2019-003722/1559232465_78977.png"></p><h2 id="mobile-wifi-proxy-設定"><a href="#mobile-wifi-proxy-設定" class="headerlink" title="mobile wifi proxy 設定"></a>mobile wifi proxy 設定</h2><h3 id="step-4-wifi-proxy-設定"><a href="#step-4-wifi-proxy-設定" class="headerlink" title="step 4 wifi proxy 設定"></a>step 4 wifi proxy 設定</h3><p>到 iPhone的 wifi設定 -&gt; HTTP 代理伺服器 -&gt; 設定 IP 及 連接埠</p><p>自己的 IP 可以在charles 的help中取得</p><p><img src="/img/2019-003722/1559232932_9678.png"></p><p>Hyper-V Virtual Ethernet Adapter #3 的是虛擬的，所以我是選下面那張實體的IP Address (一般應該只會有一個network Interface)</p><p><img src="/img/2019-003722/1559232972_08749.png"></p><p>IP 找到之後，就可以照著以下的步驟進行設定 (charles 的預設連接埠是 8888)</p><p><img src="/img/2019-003722/1559232812_89528.png"></p><p>這樣就好了嗎?</p><h2 id="還沒-1"><a href="#還沒-1" class="headerlink" title="還沒"></a>還沒</h2><p>接著你會發現攔截到的內容都是亂碼，如下圖</p><p><img src="/img/2019-003722/1559233260_66401.png"></p><p>這是因為你的 proxy沒有對SSL進行解密，所以對這一個 request 按下右鍵 然後 Enable SSL Proxying </p><p><img src="/img/2019-003722/1559233335_95942.png"></p><p>按下去之後 mobile 進行重整的動作 就會一樣攔截到 google的 request，這時就不是亂碼了</p><p><img src="/img/2019-003722/1559233412_35957.png"></p><p>但是每次切換不同的domain還要重新按右鍵然後enable ssl proxying<br>真的很麻煩啊…</p><p>所以可以直接利用 charles 的設定來避免這個麻煩</p><p><img src="/img/2019-003722/1559233912_19784.png"></p><p>按下 Add -&gt; Host 輸入 * -&gt; Port 輸入 443 (用於HTTPS的 port)</p><p><img src="/img/2019-003722/1559234007_84399.png"></p><p>按下 OK 後 就完成了~</p><p>文章記錄於此，若有錯誤煩請各位大大糾正 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> API </tag>
            
            <tag> Charles </tag>
            
            <tag> Setting </tag>
            
            <tag> interceptor </tag>
            
            <tag> Http </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 原來 Visual Studio Code 有 文字比對 的功能</title>
      <link href="/2019/05/01/2019-000351/"/>
      <url>/2019/05/01/2019-000351/</url>
      
        <content type="html"><![CDATA[<p>一直以來，找出文件不同之處我都用 <a href="https://www.diffnow.com/compare-clips">diff now</a> 這個網站來去 compare</p><p>直到今天…</p><p>「diff? VS code 就有了啊」同事理所當然的說著</p><p>「…真假啊」我帶著疑惑碎念著並敲下 VS code doc diff 的關鍵字搜尋了 google</p><p><img src="/img/2019-000351/1556639689_91313.png"></p><p>還真的有啊…於是筆記一下這篇..</p><p>先選取你需要比較的第一個檔案，按下右鍵 &#x3D;&gt;「選取用以比較」( 英文: Select for Compare )</p><p><img src="/img/2019-000351/1556639896_89969.png"></p><p>再選擇第二個檔案，按下右鍵 &#x3D;&gt; 「與選取的比較」 ( 英文: Compare with ‘your file name’ )</p><p><img src="/img/2019-000351/1556639953_29311.png"></p><p>tada! 這不就是有diff了嗎!</p><p><img src="/img/2019-000351/1556640052_95357.png"></p><p>原來有這功能…</p><h2 id="這就是-pair-programming-的原力啊"><a href="#這就是-pair-programming-的原力啊" class="headerlink" title="這就是 pair programming 的原力啊"></a>這就是 pair programming 的原力啊</h2>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> Notes </tag>
            
            <tag> DocDiff </tag>
            
            <tag> diff </tag>
            
            <tag> Compare </tag>
            
            <tag> fileCompare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - Windows Docker 與 Android 模擬器共存 設定</title>
      <link href="/2019/01/24/2019-234306/"/>
      <url>/2019/01/24/2019-234306/</url>
      
        <content type="html"><![CDATA[<p>最近在自己的 windows local 裝了  docker</p><p>困擾的是 Hyper V 跟 Android Emulator 衝突</p><p>於是在網路上找到了解法，在這邊記錄一下</p><p>前提</p><ul><li>windows 10 pro(<a href="https://blogs.windows.com/windowsexperience/2018/04/30/how-to-get-the-windows-10-april-2018-update/">2018 4月的更新</a>)</li><li>Android emulator 27.2.7 以上</li></ul><p>設定只需要 3 個步驟</p><h2 id="第一步驟"><a href="#第一步驟" class="headerlink" title="第一步驟"></a>第一步驟</h2><p>到控制台 &#x3D;&gt; 程式集 &#x3D;&gt; 開啟或關閉 Windows 功能</p><p>將 Windows Hypervisor 平台打勾</p><p><img src="/img/2019-234306/1548342673_58605.png"></p><h2 id="第二步驟"><a href="#第二步驟" class="headerlink" title="第二步驟"></a>第二步驟</h2><p>開啟 Android Studio 右上角的 SDK Manager</p><p><img src="/img/2019-234306/1548342748_95288.png">​</p><p>點選 SDK Tools 將 Android Emulator 開起來</p><p><img src="/img/2019-234306/1548342857_0799.png"></p><h2 id="第三步驟"><a href="#第三步驟" class="headerlink" title="第三步驟"></a>第三步驟</h2><p>在 C:\Users\<your user name>\.android 底下創建一個 advancedFeatures.ini 的檔案</p><p>其內容為</p><pre><code>WindowsHypervisorPlatform = on</code></pre><p>然後重開機</p><p>就可以將 Android Emulator開起來囉!</p><h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><p>如果你的錯誤訊息出現</p><pre><code>dsound: Could not initialize DirectSoundCapturedsound: Reason: No sound driver is available for use, or the given GUID is not a valid DirectSound device IDdsound: Attempt to initialize voice without DirectSoundCapture objectdsound: Attempt to initialize voice without DirectSoundCapture objectaudio: Failed to create voice `goldfish_audio_in&#39;</code></pre><p>可以編輯 AVD 的設定，點選鉛筆的 icon</p><p><img src="/img/2019-234306/1548342984_81714.png"></p><p>將 Graphics 設定成 Software</p><p><img src="/img/2019-234306/1548344345_70704.png"></p><p>注意: 如果你的模擬器預設是有 Play Store的話 Graphics 會被強制設定成 Automatic 哦!</p><p>來源:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/39021179">Android emulator与hyper-v共存</a></li><li><a href="https://blogs.msdn.microsoft.com/visualstudio/2018/05/08/hyper-v-android-emulator-support/">Hyper-V Android emulator support</a></li><li><a href="http://stackoverflow.com/questions/44328225/cant-change-emulated-performance-of-avd-in-android-studio">Stackoverflow - Can’t change emulated performance of AVD in Android Studio</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Docker </tag>
            
            <tag> Android </tag>
            
            <tag> Android Emulator </tag>
            
            <tag> HyperV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - Ruby 在 VS Code 上的 自訂義 intellisense 的設定</title>
      <link href="/2019/01/06/2019-151209/"/>
      <url>/2019/01/06/2019-151209/</url>
      
        <content type="html"><![CDATA[<p>簡單的筆記</p><p>寫 Ruby 時 如何在VS Code 上有 intellisense (go to&#x2F;peek definition&#x2F;symbol)</p><p>打開 VS Code 的 settings</p><p>加入settings</p><pre><code>&quot;ruby.locate&quot;: /&#123;    &quot;include&quot;: &quot;**/*.rb&quot;,    &quot;exclude&quot;: &quot;/&#123;**/@(test|spec|tmp|.*),**/@(test|spec|tmp|.*)/**,**/*_spec.rb&quot;/&#125;,</code></pre><p>如果你有安裝 Solargrah (通常都會裝)</p><p>建議再加入這個設定</p><pre><code>&quot;ruby.intellisense&quot;: &quot;rubyLocate&quot;</code></pre><p>最後結果</p><p><img src="/img/2019-151209/1546758503_39584.png"></p><h2 id="如果你很懶惰-你直接裝-Solargraph-就有支援了"><a href="#如果你很懶惰-你直接裝-Solargraph-就有支援了" class="headerlink" title="如果你很懶惰 你直接裝 Solargraph 就有支援了"></a>如果你很懶惰 你直接裝 <a href="https://marketplace.visualstudio.com/items?itemName=castwide.solargraph">Solargraph</a> 就有支援了</h2><p>來源:<a href="https://github.com/rubyide/vscode-ruby">https://github.com/rubyide/vscode-ruby</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>閱讀紀錄 - 關於測試在敏捷轉型中的故事－自動化的價值？</title>
      <link href="/2018/10/11/2018-000031/"/>
      <url>/2018/10/11/2018-000031/</url>
      
        <content type="html"><![CDATA[<p>這是一本記錄騰訊測試轉型敏捷其中一環的一本書</p><p>是用小說的方式來進行所以並不艱澀，不過對簡體有障礙的人或許會有點吃力</p><p>嘛，多看幾本簡體書應該就能解決這問題了 XD</p><p><img src="/img/2018-000031/1539187319_64479.jpg"></p><p>今天這篇只有紀錄了第一篇的…部分內容<br>第一章還會有一篇我覺得十分有趣，應該會再發布一個文章來記錄。</p><p>這本書的故事開頭由一個22歲剛畢業的新鮮人小宇作為開頭，進入的公司即將進行敏捷的變革，公司找了業界知名的敏捷教練，讓整個公司發動變革，然而這場變革，其他人都十分的興奮，但唯有一群人眉頭深鎖，而這群人就是測試人員。</p><p>敏捷轉型意味著必須擁抱變化，如果變化得多，那測試的效率如何提高？測試的質量又如何保證呢？</p><p>小宇作為一枚新人，當然感受不到這樣的疑惑，只意識到敏捷轉型在公司已經是勢在必行的事。</p><p>我的ＯＳ：這一段我真的有一種很重的既視感啊．．．連年齡都一樣</p><p>書中提到，測試人員眼中認為軟體開發應該是這樣的</p><ul><li>需求是清晰的</li><li>流程是固化的</li><li>開發是有序的</li><li>系統是可測的</li><li>測試時間是充足的</li><li>用戶是講道理的</li></ul><p><strong>但現實往往是相反的</strong>，所以對於需求頻繁變化越來越覺得合理和正常，開發人員延遲開發計畫、壓縮測試時間成為常態。加班這件事似乎成了一種習慣。<br>書中提了以下幾個問題</p><ul><li>我們還能隨心所欲的設計大量測試用例？</li><li>還有大量的系統測試和整合測試時間嗎？</li><li>還能要求充足地回歸測試嗎？</li><li>還能期望開發人員提供各種測試建議嗎？</li><li>現實如此，測試還能不能愉快地進行下去？</li></ul><p>問完這個問題後故事接續了下去，全公司接到了這樣的一封信。</p><p>字很多可以，意思大概是這樣。</p><blockquote><p>給技術部門的各位大大們：</p><p>　　我請一位開發人員修改一個公共的方法，只有三行程式碼。但你們測試人員告訴我因為不確定影響了哪些功能，所以要測試所有核心功能加上各種版本問題所以需要２個禮拜的工作量。</p><p>　　這樣我們還是敏捷開發的企業嗎？我也是技術部門出身，以前我深深地以技術部門為榮，今天我不得不以之為恥！</p></blockquote><p><img src="/img/2018-000031/1539183126_74876.jpg"></p><p>在這之後測試部門開了一個會得出了兩個結果。</p><ol><li>縮短回歸測試的範圍</li><li>依靠自動化</li></ol><p>故事中，決定了先嘗試第二種方案。</p><p>最後就發生了自動化過度倚賴ＵＩ，然而ＵＩ大改版後而產生自動化爛掉的情況導致相關人員加班到半夜的狀況也不是稀罕的事。</p><p>而我們公司算是兩個都選擇了，目前仍然進行中，一邊盡力縮短回歸測試的範圍，一邊增加自動化的覆蓋範圍。</p><h2 id="自動化的價值？"><a href="#自動化的價值？" class="headerlink" title="自動化的價值？"></a>自動化的價值？</h2><p>書中是這麼說的<br><em>在傳統的瀑布式開發裡，自動化的推行，是一種進步；而在敏捷開發模式裡，自動化勢必不可少的基礎。</em></p><p>而我是這麼認為的．．．<br>只要你是在軟體開發裡，任何重複的瑣事，都應該要被自動化（如果成本合理），否則這些細小瑣碎的事情遲早會變成龐然大物找你麻煩<br>還是這些麻煩會創造一種職缺？（誤</p><p>備註:自動化依然是有前提的，你仍然需要了解流程還有確認過是否「需要」再進行自動化。</p><p>在這裡先簡單的提一下自動化所涵蓋的東西有哪些</p><ul><li>測試環境的建構和管理</li><li>測試環境的監控</li><li>測試情境的建構還有數據準備</li><li>測試報告的生成</li><li>測試用例的發布和執行</li><li>…還有很多，但主要大概這些</li></ul><p><strong>以下的檢查書中都是寫「測試」喔．．．但我覺得目前這個世代還沒有到自動化「測試」這個階段，所以我還是覺得寫檢查比較好。</strong></p><ul><li>自動化能提高效率，縮短檢查的工作時間。</li><li>自動化和人工檢查相比，每一次的檢查執行操作都是固定的，非常忠實、可靠。</li><li>自動化檢查能加大每一輪回歸的力度，從而提升覆蓋率。</li><li>自動化檢查具備更好的重現軟體缺陷的能力，因為它有很強的一致性和可重複性。</li></ul><p>這樣就可以看出自動化帶來的好處，所以自動化的ＲＯＩ也可以這麼寫。（以下成本的單位我推測應該就是時間）</p><p>自動化的收益＝迭代次數Ｘ全手動執行成本－首次自動化成本－維護次數Ｘ維護成本</p><p>如果迭代次數等於維護次數</p><p>自動化的收益＝迭代次數Ｘ（全手動執行成本－維護成本）－首次自動化成本</p><p>也因為這樣，所以容易說服老闆</p><h3 id="自動化說穿了不過就是將一些人工的執行的瑣碎過程讓機器做而已"><a href="#自動化說穿了不過就是將一些人工的執行的瑣碎過程讓機器做而已" class="headerlink" title="自動化說穿了不過就是將一些人工的執行的瑣碎過程讓機器做而已"></a>自動化說穿了不過就是將一些人工的執行的瑣碎過程讓機器做而已</h3><p>那麼就可以推斷，自動化可能帶來的好處有以下幾點</p><ul><li>幫助回歸，節省人力</li><li>建構手動測時無法建構的場景、數據準備，或執行一些人工做不到的事情，進而提升覆蓋率</li><li>前置檢查，讓測試和開發有可能併行，提升專案敏捷度，降低<strong>測試獨佔週期</strong></li></ul><p><strong>測試獨佔週期</strong>是指從開發正式將版本、迭代、需求移交給測試開始，到版本到發布的時間長度（包含各種測試活動及修改測試出來的bug和臨時變更、新增的需求）</p><p>讀後想問的問題</p><p>各位大大們在自己身處的環境中是如何執行測試的呢?<br>而已經被自動化的東西又有哪些?<br>推動自動化這件事情遇到了甚麼樣的困難？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 讀書心得系列 </tag>
            
            <tag> Automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 在 Postman 使用 CSV 一次完成相同欄位但不同資料的 Request</title>
      <link href="/2018/09/06/2018-222529/"/>
      <url>/2018/09/06/2018-222529/</url>
      
        <content type="html"><![CDATA[<p>這一篇記錄的是 在 Postman 使用 CSV 一次完成相同欄位但不同資料的 Request，還有如果資料讀取的內容全是數字時建議應該如何做</p><p>API  的測試或者是平時打 API，都很有機會會打同一支 API 但資料不同的情況，如果是打 1、2 次換幾個欄位感覺不怎麼樣</p><p>但如果是1、2千次…握草，API 還沒打完自己就先死了欸…</p><p><img src="/img/2018-222529/1536239112_12367.jpg"></p><p>​今天的文章目錄</p><ul><li>資料準備</li><li>資料變數使用</li><li>開啟 Collection Runner</li><li>執行結果</li><li>注意事項</li></ul><p>本文參考於:<br><a href="http://blog.getpostman.com/2014/10/28/using-csv-and-json-files-in-the-postman-collection-runner/">官方文件提到使用 CSV 和 JSON 的資料使用方式</a></p><h2 id="資料準備"><a href="#資料準備" class="headerlink" title="資料準備"></a>資料準備</h2><p>首先準備資料，5 筆欄位為 Number 的資料，存成 CSV 檔</p><pre><code>Number7901387417013188164525923089227781651120</code></pre><h2 id="資料變數使用"><a href="#資料變數使用" class="headerlink" title="資料變數使用"></a>資料變數使用</h2><p>以此資料為例，若要在 request body 或是 url 中使用時，只要使用 &#x2F;{&#x2F;{variable name&#x2F;}&#x2F;} 就可以了，如下</p><p><img src="/img/2018-222529/1536240794_05033.png"></p><p>使用於 pre-request 和 Tests 時，就要使用 “data.variableName”，以下為範例</p><p><img src="/img/2018-222529/1536241653_16418.png"></p><p>在這裡寫了pm.test的原因是想知道目前這個request用了哪一個資料。</p><h2 id="開啟Collection-Runner"><a href="#開啟Collection-Runner" class="headerlink" title="開啟Collection Runner"></a>開啟Collection Runner</h2><p>這時候開啟 Collection Runner 匯入自己的 CSV</p><p>多少資料，就填多少 Iterations </p><p>記得將 Data File Type 改成 text&#x2F;csv</p><p><img src="/img/2018-222529/1536241373_31061.png"></p><h2 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h2><p>執行完畢後可以看到剛才寫的 pm.test 輸出了使用的資料!</p><p><img src="/img/2018-222529/1536241931_28313.png"></p><h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><p>因為 postman 使用的語言 是 javascript，所以在讀取 CSV 的資料時要特別小心，比方說如果你的資料有電話號碼時…</p><p>以此資料為例</p><pre><code>Phone091234567809876543210912345679</code></pre><p>直接打過去不對其資料進行處理的話，他會將你的號碼去除前面的 0</p><p><img src="/img/2018-222529/1536242367_85938.png"></p><p>PS: 我公司的電腦全部的號碼都去除 0 了，不知為何我在家的電腦只有最後一筆變成整數…(如果有大大知道麻煩告訴我..)</p><h3 id="CSV-資料變數建議使用方式"><a href="#CSV-資料變數建議使用方式" class="headerlink" title="CSV 資料變數建議使用方式"></a>CSV 資料變數建議使用方式</h3><p>使用 全域變數或環境變數來存取 data 的資料，然後進行判斷後轉型，程式碼如下</p><pre><code>if(typeof(data.Phone) != &quot;string&quot;)/&#123;pm.globals.set(&quot;Phone&quot;, String(&quot;0&quot; + data.Phone));/&#125;</code></pre><p>以上程式碼加在 Pre-request Script 中，如下圖</p><p><img src="/img/2018-222529/1536243513_51993.png"></p><p>接下來看一下執行結果!</p><p><img src="/img/2018-222529/1536243563_00794.png"></p><p>這樣所有打出去的變數都會跟你預想的一樣了!</p><p>下面的注意事項就是今天採到的雷…實在是很悲劇啊 QAQ</p><p>如果以上有更好的做法歡迎跟我說~</p><p>感謝各位大大收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Automation </tag>
            
            <tag> API </tag>
            
            <tag> Postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 匯出 Postman 執行結果的報表，使用 Newman !</title>
      <link href="/2018/08/18/2018-151800/"/>
      <url>/2018/08/18/2018-151800/</url>
      
        <content type="html"><![CDATA[<p>Newman 就是 postman 的 CLI</p><p>使用 Newman 最大的好處就是能夠讓 使用Postman做完的測試放進 CI 中<br>這一篇的 Collection 會拿<a href="https://dotblogs.com.tw/im_sqz777/2018/08/16/002431">上一篇的</a>來做~</p><h2 id="環境準備"><a href="#環境準備" class="headerlink" title="環境準備"></a>環境準備</h2><ul><li><a href="https://nodejs.org/en/">一樣要 nodeJS</a></li><li><a href="https://www.getpostman.com/apps">Postman</a></li><li><a href="https://www.npmjs.com/package/newman">npm install -g newman</a></li></ul><h2 id="執行前準備"><a href="#執行前準備" class="headerlink" title="執行前準備"></a>執行前準備</h2><p>首先要準備好 1 個 collection 跟 enviroment(如果有) 的json</p><h3 id="Collection-匯出"><a href="#Collection-匯出" class="headerlink" title="Collection 匯出"></a>Collection 匯出</h3><p>準備一個你要使用的 collection <br>可以用 Postman 進行匯出</p><p><img src="/img/2018-151800/1534567580_27402.png"></p><p>再來選擇格式，選他推薦的那一個(Collection v2.1 (recommended))就可以了</p><p><img src="/img/2018-151800/1534567674_27278.png"></p><h3 id="Environment-匯出"><a href="#Environment-匯出" class="headerlink" title="Environment 匯出"></a>Environment 匯出</h3><p>點選右上角齒輪</p><p><img src="/img/2018-151800/1534574005_39127.png"></p><p>會跑出你擁有的那些 environment，點選像是下載的按鈕就可以將 environment 檔案匯出</p><p><img src="/img/2018-151800/1534573953_98567.png"></p><h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><p>使用 newman run ‘collection path’ 來執行要執行的 collection</p><p>如果拿範例檔直接執行該 collection 是不行的，如下圖</p><p><img src="/img/2018-151800/1534574119_14167.png"></p><p>原因是因為你需要在指令加上你的 environment 檔<br>所以你需要這樣下指令</p><p>newman run “collection path” -e “environment path”</p><p>會像是這個樣子</p><p><img src="/img/2018-151800/1534574527_15855.png"></p><p>你的colleciton path 或是 environment path 也可以是 URL 的形式</p><p>以官網的範例為例</p><p> newman run <a href="https://www.getpostman.com/collections/631643-f695cab7-6878-eb55-7943-ad88e1ccfd65-JsLv">https://www.getpostman.com/collections/631643-f695cab7-6878-eb55-7943-ad88e1ccfd65-JsLv</a></p><h2 id="報表"><a href="#報表" class="headerlink" title="報表"></a>報表</h2><p>報表是測試很重要的東西，newman本身也有2個預設的匯出格式</p><ul><li><strong>json</strong></li><li><strong>junit (XML)</strong></li></ul><p>使用匯出報表的指令為 -r ，以下為範例</p><p>newman run “collection path” -r json</p><p>如果要一次匯出 2 種格式的報表則用 “,” 做分隔，以下為範例</p><p>newman run “collection path” -r json,junit</p><p><strong>注意: ,中間不要空白</strong></p><p><strong>下圖來源為 <a href="https://www.npmjs.com/package/newman#reporters">newman npm連結​</a>****<img src="/img/2018-151800/1534575925_51306.png"></strong></p><p>外部的產出報表形式也有好幾種，因為目前只用到 HTML ，所以用HTML來當範例，有興趣的人可以進去其他類型的報表看一看~</p><ul><li><a href="https://github.com/postmanlabs/newman-reporter-html">HTML</a></li><li><a href="https://github.com/leafle/newman-reporter-teamcity">TeamCity</a></li><li><a href="https://github.com/Paramagnetic/newman-reporter-json-light">JSON-Light</a></li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>前置動作需要先安裝 newman reporter</p><p>npm install -g newman-reporter-html</p><p>下個指令</p><p>newman run “collection path” -r html</p><p>執行過程如下圖</p><p><img src="/img/2018-151800/1534576324_58712.png"></p><p>匯出的HTML會長這個樣子</p><p><img src="/img/2018-151800/1534575348_68156.png"></p><h3 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h3><p>如果你覺得匯出報表時在command中也要看到 執行的過程與資訊可以下 -r  的時候附加 cli</p><p>newman run “collection path” -r html,cli</p><p>執行過程如下</p><p><img src="/img/2018-151800/1534576418_06839.png"></p><p>感謝各位收看 &lt;(_ _)&gt;</p><p>如果文章有錯誤 麻煩告知我</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> API </tag>
            
            <tag> CLI </tag>
            
            <tag> Postman </tag>
            
            <tag> Newman </tag>
            
            <tag> Reporter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 幫自己寫一個 CLI 來幫自己建資料夾!  使用 Node.js 的 commander!</title>
      <link href="/2018/08/14/2018-230816/"/>
      <url>/2018/08/14/2018-230816/</url>
      
        <content type="html"><![CDATA[<p>自己的工具自己寫</p><p>最近寫測試需要自動gen一些資料夾跟檔案，覺得很麻煩，所以決定寫個小工具來幫自己</p><h2 id="前置動作"><a href="#前置動作" class="headerlink" title="前置動作"></a>前置動作</h2><ul><li><a href="https://nodejs.org/en/">安裝node js</a></li></ul><p>node js 安裝完畢之後先下個指令創建一個資料夾</p><p>mkdir my-cli</p><p>cd 到 my-cli 初始化 npm 後 安裝 <a href="https://www.npmjs.com/package/commander">commander</a></p><p>npm init</p><p>npm install commander –save</p><p>在 package.json 中加入以下程式碼，這個是用來設定你教要使用的cli名字 跟 cli 切入點</p><pre><code>...,&quot;bin&quot;: /&#123;    &quot;mycli&quot;: &quot;./index.js&quot;/&#125;,...</code></pre><p>創建一個 index.js 的檔案並在其檔案中加入以下程式碼</p><pre><code>#!/usr/bin/env nodevar program = require(&#39;commander&#39;);program  .version(&#39;0.1.0&#39;)  .option(&#39;-s, --spicy&#39;, &#39;要辣辣的, Add spicy&#39;)  .option(&#39;-P, --no-parsley&#39;, &#39;不要香菜, Remove parsley&#39;)  .option(&#39;-t, --teatype [teatype]&#39;, &#39;給我一杯 [紅茶]&#39;, &#39;紅茶&#39;)  .parse(process.argv);console.log(&#39;you ordered:&#39;);if (program.spicy)  console.log(&#39;要辣辣&#39;);else  console.log(&#39;不要辣辣&#39;);if (program.parsley)  console.log(&#39;我要香菜&#39;);else  console.log(&#39;我不要香菜&#39;);console.log(&#39;給我一杯 %s&#39;, program.teatype);</code></pre><p>完成以上動作後 在 command line中下</p><p>npm link</p><p>這個指令將會幫助你把這個資料夾放進你的全域node module 中，這樣妳就不用部屬到 npm 上才能使用，<a href="https://docs.npmjs.com/cli/link">詳細可以參考這裡</a></p><h2 id="範例程式碼說明"><a href="#範例程式碼說明" class="headerlink" title="範例程式碼說明"></a>範例程式碼說明</h2><p>現在開始來解釋一下上面那段code其中代表的意思</p><p>program 是指commander本體<br>version、option則是已經被包裝好的方法</p><p>這裡的 version(‘0.1.0’) 代表著下了 “mycli -V” 或者 “mycli –version” 就會顯示被定義的版本 ‘0.1.0’</p><p>而option的格式為</p><p>.option(‘指令名稱, –指令變數名稱’ , ‘說明’)</p><p>以第一個option來舉例</p><p>.option(‘-s, –spicy’, ‘要辣辣的, Add spicy’)</p><p>寫了這一行之後執行 mycli -s，則會使 spicy 這個變數設為 true (預設為false)</p><p>你就可以使用 program.test 來判斷是否要做這個指令該做的事 只要下 mycli -s</p><p>就會出現以下訊息</p><p><img src="/img/2018-230816/1534256908_25435.png"></p><p>從上面印出的結果可以看出 要下-P這個指令才能夠不要香菜，不然預設一般都會給你香菜  (一般店家也都會加香菜)</p><p>也就是說 如果要預設為 true 的變數，你需要這麼做</p><p>program.option(‘-P, –no-parsley’, ‘不要香菜, Remove parsley’)</p><p>所以如果下了這個指令 -P 才會把 parsley這個指令設為 false</p><p>看看執行結果</p><p><img src="/img/2018-230816/1534257063_59984.png"></p><p>一般餐廳都預設會給你一杯紅茶，除非你有特別說要其他的餐點，不然一般來說都是紅茶，這樣的情況也是有的<br>所以如果你需要這樣做</p><p>program.option(‘指令, –變數名稱 [帶入的值]‘, ‘說明’, ‘預設值’)</p><p>範例程式碼如下</p><p>program.option(‘-t, –teatype [teatype]‘, ‘給我一杯 [紅茶]‘, ‘紅茶’)</p><p>這樣就可以像上面那些輸出結果，每次沒有特別囑咐，就會直接給你一杯紅茶，如果特別囑咐要一杯綠茶則需要這樣下</p><p>mycli -t 綠茶</p><p><img src="/img/2018-230816/1534257384_63245.png"></p><h2 id="使用-fs-來建立資料夾與檔案"><a href="#使用-fs-來建立資料夾與檔案" class="headerlink" title="使用 fs 來建立資料夾與檔案"></a>使用 fs 來建立資料夾與檔案</h2><p>簡單的介紹完了，接下來要使用 filesystem 來建立資料夾跟檔案</p><p>首先要再 index.js上引入 fs 並加上使用 fs 建立資料夾的 code 所以 code會變成這樣</p><h3 id="使用-fs-mkdir-資料夾位置-callback-來建立資料夾"><a href="#使用-fs-mkdir-資料夾位置-callback-來建立資料夾" class="headerlink" title="使用 fs.mkdir(資料夾位置, callback) 來建立資料夾"></a>使用 fs.mkdir(資料夾位置, callback) 來建立資料夾</h3><pre><code>#!/usr/bin/env nodevar program = require(&#39;commander&#39;);fs = require(&#39;fs&#39;);program  .version(&#39;0.1.0&#39;)  .option(&#39;-s, --spicy&#39;, &#39;要辣辣的, Add spicy&#39;)  .option(&#39;-P, --no-parsley&#39;, &#39;不要香菜, Remove parsley&#39;)  .option(&#39;-t, --teatype [teatype]&#39;, &#39;給我一杯 [紅茶]&#39;, &#39;紅茶&#39;)  .parse(process.argv);console.log(&#39;you ordered:&#39;);createFolder(&#39;ordered&#39;);if (program.spicy) /&#123;  console.log(&#39;要辣辣&#39;);/&#125; else  console.log(&#39;不要辣辣&#39;);if (program.parsley)  console.log(&#39;我要香菜&#39;);else  console.log(&#39;我不要香菜&#39;);console.log(&#39;給我一杯 %s&#39;, program.teatype);function createFolder(folderName) /&#123;  fs.mkdir(&#39;./&#39;+ folderName, (err) =&gt; /&#123;    if (err)      console.log(err);    else      console.log(&#39;./&#39; + folderName + &#39; has generated&#39;);  /&#125;);/&#125;</code></pre><h3 id="使用-fs-writeFile-檔案名稱-檔案內容-callback-來建立檔案"><a href="#使用-fs-writeFile-檔案名稱-檔案內容-callback-來建立檔案" class="headerlink" title="使用 fs.writeFile(檔案名稱, 檔案內容, callback)來建立檔案"></a>使用 fs.writeFile(檔案名稱, 檔案內容, callback)來建立檔案</h3><p>所以 code 最後長成這個樣子</p><pre><code>#!/usr/bin/env nodevar program = require(&#39;commander&#39;);fs = require(&#39;fs&#39;);program  .version(&#39;0.1.0&#39;)  .option(&#39;-s, --spicy&#39;, &#39;要辣辣的, Add spicy&#39;)  .option(&#39;-P, --no-parsley&#39;, &#39;不要香菜, Remove parsley&#39;)  .option(&#39;-t, --teatype [teatype]&#39;, &#39;給我一杯 [紅茶]&#39;, &#39;紅茶&#39;)  .parse(process.argv);console.log(&#39;you ordered:&#39;);createFolder(&#39;ordered&#39;);if (program.spicy) /&#123;  createFile(&#39;要辣辣.txt&#39;, &#39;真的要辣辣&#39;)  console.log(&#39;要辣辣&#39;);/&#125; else /&#123;  createFile(&#39;不要辣辣.txt&#39;, &#39;真的不要辣辣&#39;)  console.log(&#39;不要辣辣&#39;);/&#125;if (program.parsley) /&#123;  createFile(&#39;要香菜.txt&#39;, &#39;真的要香菜&#39;)  console.log(&#39;我要香菜&#39;);/&#125; else /&#123;  createFile(&#39;不要香菜.txt&#39;, &#39;真的要不香菜&#39;)  console.log(&#39;我不要香菜&#39;);/&#125;giveMeDrink = &#39;給我一杯 &#39; + program.teatype;createFile(giveMeDrink + &quot;.txt&quot;, giveMeDrink)console.log(giveMeDrink);function createFolder(folderName) /&#123;  fs.mkdir(&#39;./&#39; + folderName, (err) =&gt; /&#123;    if (err)      console.log(err);    else      console.log(&#39;./&#39; + folderName + &#39; has generated&#39;);  /&#125;);/&#125;function createFile(fileName, fileContent) /&#123;  fs.writeFile(&#39;./ordered/&#39; + fileName, fileContent, (err) =&gt; /&#123;    if (err)      console.log(err);    else      console.log(&#39;file:%s&#39;, fileName + &#39; has generated&#39;);  /&#125;);/&#125;</code></pre><p>來執行看看 mycli -s 就會看到他幫你建立完成了</p><p><img src="/img/2018-230816/1534258996_97522.png"><br>檔案建立完成如下</p><p><img src="/img/2018-230816/1534259079_86804.png"></p><h3 id="這裡是-github-連結，歡迎clone下來參考"><a href="#這裡是-github-連結，歡迎clone下來參考" class="headerlink" title="這裡是 github 連結，歡迎clone下來參考~"></a><a href="https://github.com/SQZ777/mycli-demo.git">這裡是 github 連結，歡迎clone下來參考~</a></h3><p>以上是簡單的 commander 介紹，如果有錯誤麻煩大大指教 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLI </tag>
            
            <tag> 自己做工具 </tag>
            
            <tag> npm </tag>
            
            <tag> Node.js </tag>
            
            <tag> commander </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筆記 - 如何在 ASP.NET CORE Web API 中加入 Angular 6</title>
      <link href="/2018/07/15/2018-210610/"/>
      <url>/2018/07/15/2018-210610/</url>
      
        <content type="html"><![CDATA[<p>目前visual studio 專案範本看起來只有出到 angular 4 但是我想用 6 XD</p><p>所以花了不少時間在研究他</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一次實作以 .NET CORE 2.0 來加入angular 6，未來版本可能會有些不同</p><p>文章中若有錯誤的地方麻煩請告知我! &lt;(_ _)&gt;</p><p><a href="https://github.com/SQZ777/AspNetCoreAndAngular6Demo">直接看Code點我(GitHub連結)</a></p><h2 id="前置動作"><a href="#前置動作" class="headerlink" title="前置動作"></a>前置動作</h2><ul><li>確認是否安裝 <a href="https://www.microsoft.com/net/learn/get-started/windows#windowsvs2017">.NET CORE</a></li><li>確認是否安裝 <a href="https://nodejs.org/en/">Node.js 及 npm</a></li><li><a href="https://github.com/angular/angular-cli">Angular CLI</a> 也可參考 <a href="https://angular.io/guide/quickstart">Angular.io 的 quick start</a> 進行安裝</li></ul><p>請使用 node -v 以及 npm -v，確認 node 版本為 8.x 以及 npm 版本為 5.x 或以上</p><h2 id="創建及設定-ASP-NET-CORE-Web-API-專案"><a href="#創建及設定-ASP-NET-CORE-Web-API-專案" class="headerlink" title="創建及設定 ASP.NET CORE Web API 專案"></a>創建及設定 ASP.NET CORE Web API 專案</h2><p>開啟 Visual Studio 新增一個 Web API 的 .NET CORE 專案</p><p><img src="/img/2018-210610/1531624273_58518.png"></p><p>按下 OK 後選取「API」再按下 OK</p><p><img src="/img/2018-210610/1531624347_73999.png"></p><p>成功開啟後，為了只需要讓 Angular CLI 幫我們編譯，所以需要設定專案設定檔</p><p><img src="/img/2018-210610/1531624727_98045.png"></p><p>在 csproj 檔中加入以下的程式碼</p><pre><code>&lt;PropertyGroup&gt;     &lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt;&lt;/PropertyGroup&gt;</code></pre><p>創建 Web API專案時，會預設開啟 api&#x2F;values 這個頁面 所以為了避免這樣的動作，要到 <strong>Properties</strong> 中的 <strong>launchSettings.json</strong> 進行設定，將 launchUrl 設為空就可以了</p><p>所有的 launchSettings.json 的 Code 如下</p><pre><code>/&#123;  &quot;iisSettings&quot;: /&#123;    &quot;windowsAuthentication&quot;: false,    &quot;anonymousAuthentication&quot;: true,    &quot;iisExpress&quot;: /&#123;      &quot;applicationUrl&quot;: &quot;http://localhost:8572/&quot;,      &quot;sslPort&quot;: 0    /&#125;  /&#125;,  &quot;profiles&quot;: /&#123;    &quot;IIS Express&quot;: /&#123;      &quot;commandName&quot;: &quot;IISExpress&quot;,      &quot;launchBrowser&quot;: true,      &quot;launchUrl&quot;: &quot;&quot;,      &quot;environmentVariables&quot;: /&#123;        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;      /&#125;    /&#125;,    &quot;AspNetCoreAndAngular6Demo&quot;: /&#123;      &quot;commandName&quot;: &quot;Project&quot;,      &quot;launchBrowser&quot;: true,      &quot;launchUrl&quot;: &quot;&quot;,      &quot;environmentVariables&quot;: /&#123;        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;      /&#125;,      &quot;applicationUrl&quot;: &quot;http://localhost:8573/&quot;    /&#125;  /&#125;/&#125;</code></pre><p>接著就需要判斷進來的 request 是需要存取網頁還是要api了，所以在Startup.cs中的 Configure 要加入以下的程式碼</p><pre><code>app.Use(async (context, next) =&gt;/&#123;    await next();    if (context.Response.StatusCode == 404 &amp;&amp;                       // 該資源不存在        !System.IO.Path.HasExtension(context.Request.Path.Value) &amp;&amp; // 網址最後沒有帶副檔名        !context.Request.Path.Value.StartsWith(&quot;/api&quot;))             // 網址不是 /api 開頭（不是發送 API 需求）    /&#123;        context.Request.Path = &quot;/index.html&quot;;                       // 將網址改成 /index.html        context.Response.StatusCode = 200;                          // 並將 HTTP 狀態碼修改為 200 成功        await next();    /&#125;/&#125;);</code></pre><p>因為將要使用 Angular CLI會幫助我們編譯出前端網頁的靜態檔案，所以我們需要可以存取靜態檔案的middleware，所以在 Startup.cs 中的 Configure 要加入兩個方法</p><ul><li>app.UseDefaultFiles()</li><li>app.UseStaticFiles()</li></ul><p>目前 Configure 中會變成這個樣子</p><pre><code>public void Configure(IApplicationBuilder app, IHostingEnvironment env)/&#123;    if (env.IsDevelopment())    /&#123;        app.UseDeveloperExceptionPage();    /&#125;    app.Use(async (context, next) =&gt;    /&#123;        await next();        if (context.Response.StatusCode == 404 &amp;&amp;                       // 該資源不存在            !System.IO.Path.HasExtension(context.Request.Path.Value) &amp;&amp; // 網址最後沒有帶副檔名            !context.Request.Path.Value.StartsWith(&quot;/api&quot;))             // 網址不是 /api 開頭（不是發送 API 需求）        /&#123;            context.Request.Path = &quot;/index.html&quot;;                       // 將網址改成 /index.html            context.Response.StatusCode = 200;                          // 並將 HTTP 狀態碼修改為 200 成功            await next();        /&#125;    /&#125;);    app.UseDefaultFiles();    app.UseStaticFiles();    app.UseMvc();/&#125;</code></pre><h2 id="創建-Angular-CLI-專案"><a href="#創建-Angular-CLI-專案" class="headerlink" title="創建 Angular CLI 專案"></a>創建 Angular CLI 專案</h2><p>接下來開始創建Angular CLI 的專案了!</p><p>這邊要注意的是，Angular CLI專案的 ng new 方法會在你所屬的資料夾底下創建一個資料夾然後放進去，所以你如果你照著前面的步驟到這裡來的話，你應該要到有 .sln檔的地方下 ng new 的指令來創建專案</p><p>這裡使用以下指令來創建專案</p><p>ng new AspNetCoreAndAngular6Demo -g –routing</p><ul><li>-g 不建立版控，因為已經建立過了</li><li>--routing 建立路由模組</li></ul><h3 id="補充-來自-Poy-Chang-的建議"><a href="#補充-來自-Poy-Chang-的建議" class="headerlink" title="補充: 來自 Poy Chang 的建議"></a>補充: 來自 Poy Chang 的建議</h3><p><img src="/img/2018-210610/1531665586_38827.png"></p><p>下指令之後會自動執行 npm install</p><p><img src="/img/2018-210610/1531656000_53281.png"></p><p>如果 npm install 失敗，請 cd 進去你的專案(有csproj檔的位置) 再執行一次 npm install，你可能還會被提示需要執行 npm audit fix 然後又被提示要執行 npm audit fix –force</p><h2 id="整合起來"><a href="#整合起來" class="headerlink" title="整合起來"></a>整合起來</h2><p>執行完畢後，有幾個需要修正的地方</p><ul><li>“src” 資料夾的命名建議修改為 “client-src” 這樣方便辨認是否為前端的程式碼</li><li>如果修改了 src資料夾名稱為 client-src 請把所有 angular.json內 “src” 的文字修改為 “client-src”</li><li>outputPath 從 dist&#x2F; [your project name] 修改為 wwwroot (如下圖)</li><li>修改.gitignore檔&#x3D;&gt;新增 &#x2F;wwwroot</li></ul><p><img src="/img/2018-210610/1531656531_71272.png"></p><p>接下來執行</p><ul><li>ng build</li><li>在 visual studio 中執行 ctrl + f5(啟動但不偵錯)</li></ul><p>這時候你就可以看到 angular 的頁面囉!!!</p><p><img src="/img/2018-210610/1531656903_88531.png"></p><p>本篇參考: <a href="https://poychang.github.io/angualr-cli-with-dotnet-core/">Angular CLI 和 ASP.NET Core Web API 專案整合步驟 1 2 3</a></p><h2 id="本篇的-github-連結"><a href="#本篇的-github-連結" class="headerlink" title="本篇的 github 連結"></a><a href="https://github.com/SQZ777/AspNetCoreAndAngular6Demo">本篇的 github 連結</a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Angular6 </tag>
            
            <tag> .NetCore </tag>
            
            <tag> Angular CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 [台北] 保哥 認識 SOLID 物件導向開發原則</title>
      <link href="/2018/07/02/2018-220745/"/>
      <url>/2018/07/02/2018-220745/</url>
      
        <content type="html"><![CDATA[<p>2018 保哥介紹 SOLID 物件導向原則小紀錄</p><p><img src="/img/2018-220745/1530552062_3649.png"></p><p>這次有很幸運地報名到保哥的課程!!! 20個名額 70秒內售完 XDDD</p><p>先前就對SOLID很好奇，而且找了很多的資料也還是不太能理解到底是什麼樣的一個概念</p><p>保哥在一開始時就直接提出了開發時常見的情形</p><ul><li>開發時間較長? 還是除錯時間較長?</li><li>有團隊進行開發 還是一人寫 Code?</li><li>一個長期維護的專案，需求變更的頻繁程度?</li><li>你如何讓程式具備有可讀性與擴充性?</li><li>如何避免在修改程式的過程中引發連鎖反應? (改A壞B)<ul><li>相依性降低就可以改善這個問題</li></ul></li></ul><p>再來說了 OOP 四個特性</p><ul><li>抽象 (Abstraction)<ul><li>將真實世界的需求轉換成 OOP中的類別</li><li>類別可以包含狀態(屬性)與行為(方法)</li></ul></li><li>封裝 (Encapsulation)<ul><li>隱藏&#x2F;保護內部實作的細節，並可以隊屬性或方法設定存取層級(public, private, protected)</li></ul></li><li>繼承 (Inheritance)<ul><li>透過繼承來重複利用、擴充和修改基底類別的定義</li></ul></li><li>多型 (Polymorphism)<ul><li>同樣的類別有多種形體</li></ul></li></ul><p>如果不了解 OOP 的特性 和 SOLID 就甭想了解 Design Pattern 怎麼來的</p><h3 id="後來講內聚力與偶合力-Cohesion-Coupling-之前"><a href="#後來講內聚力與偶合力-Cohesion-Coupling-之前" class="headerlink" title="後來講內聚力與偶合力 (Cohesion &amp; Coupling)之前"></a>後來講內聚力與偶合力 (Cohesion &amp; Coupling)之前</h3><p>先講模組(Module)，一種抽象的概念</p><p>以C#舉例</p><ul><li>可能是一個 「類別」 (class)</li><li>方法(method)</li><li>組件(assembly)</li></ul><h2 id="內聚力-Cohesion"><a href="#內聚力-Cohesion" class="headerlink" title="內聚力 Cohesion"></a>內聚力 Cohesion</h2><p>在一個 “模組” 內完成 “一件工作” 的度量指標</p><h3 id="高內聚力"><a href="#高內聚力" class="headerlink" title="高內聚力"></a>高內聚力</h3><p>在一個模組(類別)內 只完成一件工作</p><p>內聚力高，意味著該模組可以獨立運作，也意味著更容易重複利用</p><h3 id="低內聚力"><a href="#低內聚力" class="headerlink" title="低內聚力"></a>低內聚力</h3><p>在一個”模組”內完成多份工作</p><p>內聚力低，意味著這個模組會造成難以維護測試重用理解</p><p>範例:所有功能寫在一個 class裡面 或一個 method 有5000行的程式碼</p><h3 id="最佳實務"><a href="#最佳實務" class="headerlink" title="最佳實務"></a>最佳實務</h3><p>在設計模組的時候要盡量設計出高內聚力的程式碼</p><p>若要一個模組內完成多項工作，建議拆成多個模組</p><h2 id="耦合力-Coupling"><a href="#耦合力-Coupling" class="headerlink" title="耦合力 (Coupling)"></a>耦合力 (Coupling)</h2><p>意指</p><ul><li>模組與模組之間的關聯強度</li><li>模組之間相互依賴的程度</li><li>衡量兩個模組的緊密連接程度</li></ul><h3 id="高耦合力"><a href="#高耦合力" class="headerlink" title="高耦合力"></a>高耦合力</h3><p>意味著當改了A模組時，相關聯的B模組就會容易被影響(改A壞B)</p><h3 id="低耦合力"><a href="#低耦合力" class="headerlink" title="低耦合力"></a>低耦合力</h3><p>當在修改模組時 有越少模組被影響就意味著耦合力較低</p><h3 id="最佳實務-1"><a href="#最佳實務-1" class="headerlink" title="最佳實務"></a>最佳實務</h3><p>實現DIP就是實現 「降低耦合力」的一個原則</p><h2 id="何謂原則"><a href="#何謂原則" class="headerlink" title="何謂原則?"></a>何謂原則?</h2><p>所謂原則 就是一種 「概念」 或 「價值」 用來引導你產生 「適切的行為」 與 「價值評量方法」</p><p>講白一點的概念就是…</p><p>依循SOLID 可以..</p><ul><li>寫出比較好的程式碼</li><li>較能夠判斷程式碼的好壞</li></ul><p>SOLID原則為以下 5 點</p><ul><li>單一職責原則 Single Responsibility Principle</li><li>開放封閉原則 Open Closed Principle</li><li>里氏替換原則 Liskov Substitution Prinsple</li><li>介面隔離原則 Interface Ssegregation Prinsple</li><li>相依反轉原則 Dependency Inversion principle</li></ul><p>學習 SOLID 物件導向設計原則的好處</p><ul><li>降低程式碼複雜程度</li><li>具有較佳程式碼可讀性</li><li>提升模組可重複利用姓</li><li>讓模組具有高內聚力、低耦合力</li><li>面臨變更需求時可減少破壞現有模組的風險</li></ul><h2 id="小感想"><a href="#小感想" class="headerlink" title="小感想"></a>小感想</h2><p>現實生活中也有很多東西都會運用到SOLID原則，保哥舉裡吹風機的例子，吹風機可以換頭而他本身有馬達跟機身 那是他自己的模組</p><p>而 囧星人之前也是一個工程師，所以她以一個工程師的角度做了他的鬍子XD</p><p><img src="/img/2018-220745/1530551299_30236.png"></p><p>網址連結: <a href="https://youtu.be/7KUbmq_M640?t=4m14s">https://youtu.be/7KUbmq_M640?t&#x3D;4m14s</a></p><p>這一次的介紹讓我真的比較了解 這五大原則的東西了，不然真的沒什麼 feel 尤其是 DI 的部分</p><p>因為今天的介紹後我更了解要如何判斷一個Code的好壞，不過很重要的一點是</p><p>原則是原則，Code 最後會長什麼樣子，是尤 「需求」決定。</p><p>接下來要多做的其實很多都是經驗上的問題，如何寫出高內聚、低耦合的 Code，如何將所有需求合理的抽象化，都需要經驗的累積，只求一件事就是要求自己不斷的進步!!!</p><p>這一篇是一點小小的紀錄，介紹的過程中有很多很多的範例程式，我覺得這個是十分棒的一件事!!<br>感謝各位大大收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> Develop </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「隱藏的質量」聽完邰曉梅老師分享後的心得</title>
      <link href="/2018/05/17/2018-095641/"/>
      <url>/2018/05/17/2018-095641/</url>
      
        <content type="html"><![CDATA[<p>今天聽來聽邰曉梅老師的分享－隱藏的質量</p><p>從開頭一部影片開始</p><p>是一個綜藝節目，在玩傳話遊戲</p><p>從開頭到結尾，漸漸地遺漏了訊息，修改了訊息</p><p>從這個觀點來思考專案似乎也是這個樣子</p><p>進而衍伸出一件事情</p><p>「質量，會經過多個人手之後而劣化」</p><p>為了改善問題，所以測試左移，但測試左移不單單只是將測試人員移到專案的開始，或是團隊裡頭。</p><p>真正應該做的是讓團隊在專案前期就開始關注「質量」</p><p>老師提出了一個問題</p><h2 id="「What’s-Quality-of-your-product」"><a href="#「What’s-Quality-of-your-product」" class="headerlink" title="「What’s Quality of your product」"></a>「What’s Quality of your product」</h2><p>我誤會了這個問題<br>我的回答是<br>“我覺得是客戶滿意度還有團隊測試上的一些完整度(涵蓋率)上的問題 但我覺得還有很多可以改善的 所以我覺得大概六十分”  </p><p>我以為是 “主觀的判斷你現在做的產品的品質”<br>而不是問 “你如何去解釋產品品質?”</p><p>碎碎念: 我的應該要回問我的理解是不是正確的..當下曉梅老師雖然還是有問他想問的問題，但我腦袋當時當機了(倒</p><p>以今天邰曉梅老師分享的內容與我過去在公司裡講關於測試的部分內容是相符合的</p><p>但今天這個演講讓我覺得很好的是</p><p>我驗證了過去我對於 品質這件事的觀念是正確的，因為未知的風險、測試想法(test ideas)是永無止境的</p><p>不斷的探索(Explore)這些未知的未知風險，是測試人員的價值和職責，然後將這些未知的未知風險，變成已知的未知風險，然後將它可視化，應該就可以讓團隊對於品質的概念有相同的方向，也就是 Quality Alignment。</p><p>為了好理解所以我，用小畫家畫了一張圖來表示</p><p><img src="/img/2018-095641/1526521985_80173.png"></p><p>從「已知的未知風險」做可視化，將這些可視化之後就可以讓團隊知道還有多少個已知的未知風險、測試想法(test ideas)，進而讓團隊了解目前還有哪些已經不知道的事情。</p><p>所以 當有人問我</p><p>「What’s Quality of your product」</p><p>我會說 我沒辦法給你答覆</p><p>但我會一直探索，頻繁的提供與目前產品相關的品質訊息，不斷的探索未知的未知，並且將它變成已知的未知。</p><p>然後每一個新發現、新想法就會形成一個「點」，將他們連結起來就會形成一個 Quality Trend，進可能的讓團隊對於品質的方向一致(Quality Alignment)，然後讓所有利益關係的人了解品質，並且依照目前的品質來做選擇 (Adjust and Adapt)</p><p><img src="/img/2018-095641/1526522346_29809.jpg"></p><p>這樣，就是測試人員的價值，也讓團隊對於品質更有相同的方向。</p><h2 id="Action-Item"><a href="#Action-Item" class="headerlink" title="Action Item"></a>Action Item</h2><ul><li>每日站會，盡可能地去嘗試評估今天的產品品質，也盡量讓團隊成員感受目前的”產品品質”是如何。</li><li>盡可能的將已知的未知風險可視化，這樣也能讓團隊對於「品質」更有方向性</li><li>嘗試做了這些「可視化」的動作之後，再把經驗分享出來</li></ul><p>曉梅老師在FB上的回覆</p><p><img src="/img/2018-095641/1526954817_39734.png"></p><p>1．探索未知的质量，不仅仅是测试人员的事儿；</p><p>2. 无需太关注test case,我更喜欢用test ideas这个词<br>(所以文章內的test case都修改了)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 心得 </tag>
            
            <tag> 社群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby - 如果要複製出一樣的物件變數應該怎麼做?</title>
      <link href="/2018/05/03/2018-001921/"/>
      <url>/2018/05/03/2018-001921/</url>
      
        <content type="html"><![CDATA[<p>好久沒有寫這種類似的文章了呢XD</p><p>最近一直在寫自動化，但沒花甚麼時間去理解使用的語言</p><p>看來我依然是離不開這種學習方式呢XD 實在是很有趣</p><p>Ruby 是一個挺有趣的語言，這邊就不詳細介紹 因為其他文章以及他自己本身的 Document 就講了太多太多了</p><p>有興趣的可以到這裡</p><p>官方文件<br><a href="https://www.ruby-lang.org/zh_tw/documentation/ruby-from-other-languages/">https://www.ruby-lang.org/zh_tw&#x2F;documentation&#x2F;ruby-from-other-languages&#x2F;</a></p><p>Ruby 也可這樣寫<br><a href="https://kaochenlong.com/2014/10/16/happy-programming-ruby/">https://kaochenlong.com/2014/10/16/happy-programming-ruby/</a></p><p>今天主要要紀錄的是變數和物件之間的差異</p><p>變數在這個萬物幾乎皆物件的世界裡，變數像是一個物件裡的”標籤 (Label)” </p><p>從code來開始看吧</p><p>我宣告一個 A 為 “abc” (字串物件)</p><pre><code>a = &quot;abc&quot;b = aa.upcase!puts b</code></pre><p>猜猜會輸出怎樣的b?</p><p>答案是出現 “ABC”</p><p>可以看得出來是 a 跟 b 同時指向了同一個物件，而導致了這樣的結果<br>那我們要如何知道是真的這樣的事情發生了呢?</p><p>可以使用object_id來確認這件事</p><p>所以…code 就變這樣</p><pre><code>a = &quot;abc&quot;b = aa.upcase!puts bputs b.object_idputs a.object_id</code></pre><p>這時就可以發現他們兩個的 object_id 就會相同了<br>如果真的要用同一個物件時，就會建議使用 clone方法來做</p><p>所以應該要這樣</p><pre><code>a = &quot;abc&quot;b = aa.upcase!puts bb = a.cloneb.downcase!puts bputs a</code></pre><p>這樣子就不會影響到 a 的物件啦!!</p><p>小小筆記一下這個 避免以下不小心踩到這個雷ˊ_&gt;ˋ</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>閱讀周記 - 測試技術之測試技術分類系統</title>
      <link href="/2018/04/07/2018-180727/"/>
      <url>/2018/04/07/2018-180727/</url>
      
        <content type="html"><![CDATA[<p>測試技術好多種RRR</p><p>根本就像用了魔法卡繁殖的小精靈</p><p><img src="/img/2018-180727/20080306124457.jpg" alt="f:id:immortalnova:20080306124457j:plain">來源:<a href="http://immortalnova.hatenablog.com/entry/2016/06/17/181726">http://immortalnova.hatenablog.com/entry/2016/06/17/181726</a></p><p>我覺得單一個測試技術就像一個小精靈</p><p>一個小精靈一點都沒有威脅性，但是當他搭配了魔法卡「繁殖」之後多了好多個小精靈，根本厲害啊，打也打不完</p><p>這也代表著多個測試技術組合起來的測試方法會更能夠掌握目前產品的風險</p><p>這一篇的心得來自於 <em>微軟測試之鑰 微軟一線測試專家技術精華</em>  這一本書的第5章第1節，以下簡稱為此書</p><blockquote><p><em>如果說測試是為了發現錯誤而執行程式的過程，那麼測試技術就是執行程式並判斷其對錯的具體方法</em></p><hr><p>節錄自此書第 5-2 頁</p></blockquote><p>我覺得，測試就好像在開車，而測試技術就像停車技巧、打檔、踩油門、轉方向盤等等的各種具體開車行為。</p><p>在此書的這一個章節中引用了 Cem Kaner 教授建立的測試技術分類系統來撰寫</p><p><a href="https://en.wikipedia.org/wiki/Cem_Kaner">Cem Karner教授的相關資料 https://en.wikipedia.org/wiki/Cem_Kaner</a></p><p>測試技術會從 7 個方面對測試過程進行指導</p><ul><li><h3 id="範圍-被測對象"><a href="#範圍-被測對象" class="headerlink" title="範圍 &#x3D;&gt; 被測對象"></a>範圍 &#x3D;&gt; 被測對象</h3></li><li><h3 id="覆蓋-測試深度與廣度"><a href="#覆蓋-測試深度與廣度" class="headerlink" title="覆蓋 &#x3D;&gt; 測試深度與廣度"></a>覆蓋 &#x3D;&gt; 測試深度與廣度</h3></li><li><h3 id="測試者-測試者"><a href="#測試者-測試者" class="headerlink" title="測試者 &#x3D;&gt; 測試者"></a>測試者 &#x3D;&gt; 測試者</h3></li><li><h3 id="風險-需要被發現的潛在問題"><a href="#風險-需要被發現的潛在問題" class="headerlink" title="風險 &#x3D;&gt; 需要被發現的潛在問題"></a>風險 &#x3D;&gt; 需要被發現的潛在問題</h3></li><li><h3 id="活動-如何執行測試"><a href="#活動-如何執行測試" class="headerlink" title="活動 &#x3D;&gt; 如何執行測試"></a>活動 &#x3D;&gt; 如何執行測試</h3></li><li><h3 id="評估和測試先知-對測試結果進行評估"><a href="#評估和測試先知-對測試結果進行評估" class="headerlink" title="評估和測試先知 &#x3D;&gt; 對測試結果進行評估"></a>評估和測試先知 &#x3D;&gt; 對測試結果進行評估</h3></li><li><h3 id="結果導向-測試的目標"><a href="#結果導向-測試的目標" class="headerlink" title="結果導向 &#x3D;&gt; 測試的目標"></a>結果導向 &#x3D;&gt; 測試的目標</h3></li></ul><p>Cem Karner 建立了六要素測試分類系統，以下是測試分類系統的六大分之</p><ul><li><h3 id="基於涵蓋的測試技術，關注測試的範圍和涵蓋"><a href="#基於涵蓋的測試技術，關注測試的範圍和涵蓋" class="headerlink" title="基於涵蓋的測試技術，關注測試的範圍和涵蓋"></a>基於涵蓋的測試技術，關注測試的範圍和涵蓋</h3></li><li><h3 id="基於測試者的測試技術，關注誰來執行測試"><a href="#基於測試者的測試技術，關注誰來執行測試" class="headerlink" title="基於測試者的測試技術，關注誰來執行測試"></a>基於測試者的測試技術，關注誰來執行測試</h3></li><li><h3 id="基於風險的測試技術，關注潛在問題"><a href="#基於風險的測試技術，關注潛在問題" class="headerlink" title="基於風險的測試技術，關注潛在問題"></a>基於風險的測試技術，關注潛在問題</h3></li><li><h3 id="基於活動的測試技術，關注如何執行測試"><a href="#基於活動的測試技術，關注如何執行測試" class="headerlink" title="基於活動的測試技術，關注如何執行測試"></a>基於活動的測試技術，關注如何執行測試</h3></li><li><h3 id="基於評估的測試技術，關注如何判斷測試通過"><a href="#基於評估的測試技術，關注如何判斷測試通過" class="headerlink" title="基於評估的測試技術，關注如何判斷測試通過"></a>基於評估的測試技術，關注如何判斷測試通過</h3></li><li><h3 id="結果導向的測試技術，關注於特定目標或檔案"><a href="#結果導向的測試技術，關注於特定目標或檔案" class="headerlink" title="結果導向的測試技術，關注於特定目標或檔案"></a>結果導向的測試技術，關注於特定目標或檔案</h3></li></ul><p>關於這六大分之作者也有對其中相關的測試技術進行列舉</p><h2 id="1-基於涵蓋的測試技術，關注測試的範圍和涵蓋"><a href="#1-基於涵蓋的測試技術，關注測試的範圍和涵蓋" class="headerlink" title="1. 基於涵蓋的測試技術，關注測試的範圍和涵蓋"></a>1. 基於涵蓋的測試技術，關注測試的範圍和涵蓋</h2><p>這個是典型的測試技術，其包含了</p><ul><li>功能測試</li><li>功能或特性的整合測試</li><li>邊界測試</li><li>最佳代表測試</li></ul><p>作者提出了不只這 4 個名詞其主要要表達的是基於涵蓋的測試技術所關注的都是被測對象的功能和功能之間的互動性是否符合預期</p><p>這邊特別可以說的是最佳代表測試</p><blockquote><p><em>最佳代表測試 : 要求從眾多測試範例中選擇最有代表性的測試範例，常見的例子包含使用者最可能使用的資料、給產品最大挑戰的資料、最能暴露風險的資料等</em> </p><hr><p>節錄自此書第 5-3 頁</p></blockquote><p>我想，最佳代表測試，就是拿來自動化測試跑的一種測試範例吧，畢竟他風險最大、最容易暴露風險。<br>當然，並不是只有最佳代表測試才能被自動化執行。</p><h2 id="2-基於測試者的測試技術，關注誰來執行測試"><a href="#2-基於測試者的測試技術，關注誰來執行測試" class="headerlink" title="2. 基於測試者的測試技術，關注誰來執行測試"></a>2. 基於測試者的測試技術，關注誰來執行測試</h2><p>其實這一個基於測試者的測試技術十分常見，在遊戲業界中就會常常聽到要封測，就算是一種用戶的 Beta Test</p><p>這一種測試技術其實也很常見，以下是作者列舉的測試技術的其中幾種</p><ul><li>缺陷大掃除 (Bug Bash)</li><li>結對測試 (Pair Testing) </li><li>內部試用</li></ul><p>缺陷大掃除可以參考我之前在自己團隊所執行的結果與經驗(趁機打廣告XD</p><p><strong><a href="https://dotblogs.com.tw/im_sqz777/2018/02/28/195303">Test - 我舉辦了一場 Bug Bash－大家都進來測試吧!!</a></strong></p><p>結對測試就跟結對編程很像</p><p>由另一個人來觀察、指導與紀錄測試過程，在這一個執行的過程之中就可以獲得對於產品不同角度的Feedback</p><p>內部試用這點可以參考這一篇 wiki</p><p><a href="https://zh.wikipedia.org/wiki/Eating_your_own_dog_food">Eating your own dog food</a></p><p>主要的目的就是讓自己可以在日常中使用自己的產品，讓自己對於產品更有自信心，也可以在日常的開發週期中發現一些實際使用者會遇到的問題。</p><h2 id="3-基於風險的測試技術，關注潛在問題"><a href="#3-基於風險的測試技術，關注潛在問題" class="headerlink" title="3. 基於風險的測試技術，關注潛在問題"></a>3. 基於風險的測試技術，關注潛在問題</h2><p>以風險作為角度的測試，就是用來避免非常態的使用情境來發現問題，以下是作者列出的其中幾種測試技術</p><ul><li>邊界測試</li><li>壓力測試</li><li>負載測試</li><li>可用性測試</li><li>基於歷史的測試</li></ul><p>這幾點可以看得出來都是以非常態的使用狀態來進行測試，這些基於風險的測試，通常都會使用工具來輔助測試人員來進行測試。</p><p>常見的壓力測試及負載測試的工具用google就可以找到很多了~ EX: jmeter、apache bench等等之類的</p><p>甚至有些已經發展成一種服務囉~</p><h2 id="4-基於活動的測試技術，關注如何執行測試"><a href="#4-基於活動的測試技術，關注如何執行測試" class="headerlink" title="4. 基於活動的測試技術，關注如何執行測試"></a>4. 基於活動的測試技術，關注如何執行測試</h2><p>以下是作者列出的其中幾種測試技術</p><ul><li>隨機測試</li><li>猴子測試</li><li>情境測試</li><li>回歸測試</li></ul><p>其實猴子測試也可以算是基於風險的測試技術，但作者將其歸類於基於活動的測試技術。<br>不過我覺得不管測試技術被分類於哪一種分類底下，只要他能夠達成想要達成的測試目的，就可以了。</p><p>這邊可以特別說的是回歸測試，回歸測試的目的就是為了避免產品的程式碼在進行變更之後而產生問題的一種測試技術，但他有一個很大的成本</p><h3 id="其成本就是時間"><a href="#其成本就是時間" class="headerlink" title="其成本就是時間"></a>其成本就是時間</h3><p>時間越長的回歸測試，能涵蓋及避免的問題就越廣，即時間越短的回歸測試，能涵蓋及避免的問題就越狹隘。</p><h2 id="5-基於評估的測試技術，關注如何判斷測試通過。"><a href="#5-基於評估的測試技術，關注如何判斷測試通過。" class="headerlink" title="5. 基於評估的測試技術，關注如何判斷測試通過。"></a>5. 基於評估的測試技術，關注如何判斷測試通過。</h2><p>我認為，基於評估的測試技術，主要是根據用戶的需求，或是訂製出來的規範而進行的一種測試技術。</p><p>不過有趣的是，訂定出來的規範以及用戶需求，都不是測試人員自己所決定的，常常是需要第三方的人、事、物來一同決定其測試是否通過。</p><p>所謂人，就是團隊或客戶</p><p>所謂事、物，就是「討論」、「執行」之後所產出的「文件」</p><p>以下是作者提到諸多的基於評估測試技術的其中兩種測試技術</p><ul><li>比較規格說明或其他權威檔案</li><li>基於診斷的測試</li></ul><p>第 1 個就是依據文件來執行的測試技術，比對文件內容與軟體執行結果是否符合來評估目前測試是否通過</p><p>第 2 個就是依據工具來執行的測試技術，使用工具來進行對於產品的測試，其結果通常會有報告，然後再依據報告結果進行評估目前測試是否通過。</p><h2 id="6-結果導向的測試技術，關注於特定目標或檔案"><a href="#6-結果導向的測試技術，關注於特定目標或檔案" class="headerlink" title="6. 結果導向的測試技術，關注於特定目標或檔案"></a>6. 結果導向的測試技術，關注於特定目標或檔案</h2><p>結果導向的測試技術，就是所謂的「以終為始」，以最終最能夠解決客戶需求的功能，來進行測試，這樣的測試通常是最簡單但很重要的測試。</p><p>有些軟體也會要求須要符合某些認證標準才能夠Release。</p><p>以下測試技術是作者列出的其中 2 種測試技術</p><ul><li>用戶接受測試</li><li>認證測試</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><blockquote><p><em>在學習測試技術時，測試人員可以快速定位它在分類系統中的位置。</em></p><p><em>在選擇測試技術時，他可以同時運用來自不同分支的測試技術，以實施多樣化的測試。</em></p><hr><p>節錄自此書第 5-8 頁</p></blockquote><p>在最後此書也有提到由 Lisa Chrispin 和 Janet Gregory 提出的測試象限的概念，如下圖，該圖拍攝於此書的 5-9 頁</p><p><img src="/img/2018-180727/1523095025_11786.jpg"></p><p>在此圖可以清楚看到它的架構分類四大象限，相較於 Cem Kaner所提出的六大分支來得易於理解許多。</p><p>不過這邊特別要說的是作者不同意 Lisa Chrispin 和 Janet Gregory將探索式測試置於第三象限，原因是因為</p><blockquote><p><em>探索式測試是一種並行地實施測試學習、測試設計、測試執行呵結果評估的測試風格，作為一種測試思維方法，它可以指導測試象限的任何一種測試技術的使用</em></p><hr><p>節錄自此書第 5-9 頁</p></blockquote><p>我覺得…</p><h3 id="探索式測試其實就是一種Interface，而其他執行測試的過程與技術，就是實作這個探索式測試的各種方法"><a href="#探索式測試其實就是一種Interface，而其他執行測試的過程與技術，就是實作這個探索式測試的各種方法" class="headerlink" title="探索式測試其實就是一種Interface，而其他執行測試的過程與技術，就是實作這個探索式測試的各種方法"></a>探索式測試其實就是一種Interface，而其他執行測試的過程與技術，就是實作這個探索式測試的各種方法</h3><p>以上是跟大家分享 <em>微軟測試之鑰 微軟一線測試專家技術精華</em> 5-1 的內容</p><p>最後想問大家一個問題</p><h3 id="不知道大家對於探索式測試的看法及作法是甚麼"><a href="#不知道大家對於探索式測試的看法及作法是甚麼" class="headerlink" title="不知道大家對於探索式測試的看法及作法是甚麼?"></a>不知道大家對於探索式測試的看法及作法是甚麼?</h3><p>感謝各位大大觀看 &lt;(_ _)&gt;</p><p>周記碎碎念</p><p>連續好幾周沒有寫了..要轉動齒輪真的需要比較大的力氣，希望自己可以再持續下去，我想一定是動力還不構，看來要弄個連續寫三周就吃大餐的 Bonus (誤</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 讀書心得系列 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - 變異(Mutation)測試之你的測試到底是寫爽的，還是有效的?</title>
      <link href="/2018/03/15/2018-004634/"/>
      <url>/2018/03/15/2018-004634/</url>
      
        <content type="html"><![CDATA[<p>今天參加了 Agile Community 的變異測試的一個meet up</p><p>覺得很有趣 這算是一個寫Unit Test的後續(吧?</p><p><img src="/img/2018-004634/1521041744_7069.png"><br>變異測試 - 一種改進測試和代碼的 “新” 方法</p><p>講師Joseph表示 其實這不是一種新的方式了，這在1970年就有人提出來了 (我都還沒出生呢….) </p><p>變異測試，所謂的變異，就是從英文的 Mutation 翻譯而來的，意義上就是 病變、突異的意思</p><p>可以想像我們的程式碼就是身體，如果我們的身體出現了突變、病變的話，就代表我們的身體出了問題了，從程式碼的角度來看就是我們的程式碼有變更了</p><p>我們時常寫了許多的測試，但還是很容易出現 Bug 或是有所謂的 「漏網之魚」，或許就可以透過 Mutation Test來找出測試程式碼的漏洞</p><p>我自己稍微寫了一點跟講師一樣的程式碼，但是是C#版本的程式碼與測試程式來講解這樣的情況</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        if (a &gt; 0 &amp;&amp; b &gt; 0)          c = b;        return c;    /&#125;/&#125;</code></pre><p>而我的測試程式碼長這個樣子</p><pre><code>[TestClass]public class TestFoo/&#123;    [TestMethod]    public void input_a_is_1_b_is_1_Should_1()    /&#123;        var someThing = new SomeThing();        Assert.AreEqual(1, someThing.Foo(1, 1));    /&#125;    [TestMethod]    public void input_a_is_1_b_is_n1_should_be_0()    /&#123;        var someThing = new SomeThing();        Assert.AreEqual(0, someThing.Foo(1, -1));    /&#125;    [TestMethod]    public void input_a_is_n1_b_is_1_should_be_0()    /&#123;        var someThing = new SomeThing();        Assert.AreEqual(0, someThing.Foo(-1, 1));    /&#125;/&#125;</code></pre><p>我的測試程式碼事實上已經涵蓋100%了，由內建的工具就可以看得到了</p><p><img src="/img/2018-004634/1521042301_71939.png"></p><p>我的 Code Coverage 已經是100%了 照理來說我改了任何一個程式碼的內容的話，我的測試程式碼都應該要出現錯誤<br>但如果我把我的程式碼改成這個樣子</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        if (a &gt; 0 &amp;&amp; b &gt;= 0)          c = b;        return c;    /&#125;/&#125;</code></pre><p>我把 判斷 b&gt;0 的條件改成 b&gt;&#x3D;0 我的測試程式碼依然是通過的，代表 2 件事</p><ul><li><h2 id="我寫出來的測試程式碼是無效的"><a href="#我寫出來的測試程式碼是無效的" class="headerlink" title="我寫出來的測試程式碼是無效的"></a>我寫出來的測試程式碼是無效的</h2></li><li><h2 id="Code-Coverage-是假的"><a href="#Code-Coverage-是假的" class="headerlink" title="Code Coverage 是假的"></a>Code Coverage 是假的</h2></li></ul><p><img src="/img/2018-004634/be7ab3eab997586ed77619386aacc115-3-350x183.jpg"></p><p>以測試程式碼無效這件事情來說，這是常有的事，所以我們需要 Mutation Test 來改善我們的程式碼，當然讓程式碼變異的方式有很多種，以下列出其中幾種</p><ul><li>條件邊界的變異</li><li>反向條件的變異</li><li>移除條件的變異</li><li>遞增、遞減的變異</li><li>常數的變異</li><li>返回值的變異</li><li>移除程式碼的變異</li></ul><p>條件邊界的變異很明顯的，剛才的寫出來的範例已經提到了，嘗試將 “&gt;” 變成 “&gt;&#x3D;” 或 “&lt;” 變成 “&lt;&#x3D;” 以這樣的異動來說，整個程式碼的敘述已經變得跟原本不同了，那我們的測試程式碼就應該要抓得出來這樣子的錯誤</p><h2 id="反向條件的變異"><a href="#反向條件的變異" class="headerlink" title="反向條件的變異"></a>反向條件的變異</h2><p>如果是反向條件的變異，就可以試試將原本的程式碼變為這個樣子</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        if (!(a &gt; 0 &amp;&amp; b &gt;= 0))          c = b;        return c;    /&#125;/&#125;</code></pre><p>將整個判斷句反向過來，試試看我們的測試程式碼有沒有抓到這樣的錯誤</p><h2 id="移除條件的變異"><a href="#移除條件的變異" class="headerlink" title="移除條件的變異"></a>移除條件的變異</h2><p>如果是移除條件的變異，就可以試試將判斷的語句移除</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        c = b;        return c;    /&#125;/&#125;</code></pre><p>將整個判斷語句移除之後，跑跑看 Unit Test 是否通過</p><h2 id="遞增、遞減的變異"><a href="#遞增、遞減的變異" class="headerlink" title="遞增、遞減的變異"></a>遞增、遞減的變異</h2><p>這個變異是指如果有for迴圈，將其遞增的狀況變更</p><p>好比說 原本是 for(int i &#x3D; 0; i&lt; somethingNumber; i++)</p><p>變更為 for(int i &#x3D; 0; i&lt; somethingNumber; i–)</p><p>變更後再跑一次Unit Test是否通過</p><h2 id="常數的變異"><a href="#常數的變異" class="headerlink" title="常數的變異"></a>常數的變異</h2><p>這個變異是指，假設今天有一個常數已經定義好為 CONST_NUMBER &#x3D; 5</p><p>如今有一段程式碼是 somethingNumber &#x3D; doSomething(CONST_NUMBER);</p><p>將其改成 somethingNumber &#x3D; doSomething(6);</p><p>嘗試看看測試程式碼是否有幫助你找到錯誤</p><h2 id="返回值的變異"><a href="#返回值的變異" class="headerlink" title="返回值的變異"></a>返回值的變異</h2><p>由範例來修改返回值的程式碼如下，將原本的 return c 變為 return 0</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        if (a &gt; 0 &amp;&amp; b &gt; 0)          c = b;        return 0;    /&#125;/&#125;</code></pre><p>再試試看這段程式碼被測試程式碼跑過一遍之後會發生什麼事情</p><h2 id="移除程式碼的變異"><a href="#移除程式碼的變異" class="headerlink" title="移除程式碼的變異"></a>移除程式碼的變異</h2><p>顯而易見的如文字上所說，將程式碼移除，然後再進行測試</p><pre><code>public class SomeThing/&#123;    public int Foo(int a, int b)    /&#123;        var c = 0;        return c;    /&#125;/&#125;</code></pre><p>跑一下Unit Test 看結果會如何</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>當然看完上面簡單的範例之後會發現很多程式碼是可以嘗試看看的，如果你的程式碼被移除，或被更動但沒有出錯那就只代表兩件事</p><ul><li>這些被移除的程式碼根本不重要，有跟沒有一樣</li><li>你的測試程式碼的有效性不足夠，所以要加新的測試</li></ul><p>通常是後者就是了XD</p><p>不過嘗試變異測試是有前提跟原則的</p><p>前提是</p><p><strong>這些將要被異變的程式碼最好都有被測試覆蓋</strong></p><p>第一點的理由很明顯，如果你的程式碼沒有測試覆蓋，你連原本自己寫的 Code 都不知道是否是正確的，你還做了這些異變，也根本不會知道會不會是對的。</p><p>而原則是</p><ul><li><h3 id="異變過後的程式碼要能夠編譯"><a href="#異變過後的程式碼要能夠編譯" class="headerlink" title="異變過後的程式碼要能夠編譯"></a>異變過後的程式碼要能夠編譯</h3></li><li><h3 id="同一個只使用其中一個變異的方式"><a href="#同一個只使用其中一個變異的方式" class="headerlink" title="同一個只使用其中一個變異的方式"></a>同一個只使用其中一個變異的方式</h3></li><li><h3 id="確定異變程式碼過後，執行測試應該要是失敗的"><a href="#確定異變程式碼過後，執行測試應該要是失敗的" class="headerlink" title="確定異變程式碼過後，執行測試應該要是失敗的"></a>確定異變程式碼過後，執行測試應該要是失敗的</h3></li></ul><p>第一點，很明顯的，如果你異變過後的程式碼沒辦法編譯，那你連跑 Unit Test 都沒辦法跑</p><p>第二點，一般說雖然同時更改很多部分的程式碼，有可能會比較貼近實際上的異動，但只選擇一種變異的方法就已經足以讓自己的測試程式碼更加完善了，當然你可以不只做一種異變測試，你可以做很多個，但建議不要「同時」一次做很多個</p><p>第三點，這是一種倒過來思考的方式，有在用TDD的人會想著要如何最小步的讓測試通過，而倒過來就是想著程式碼該如何用最小步的方式讓測試失敗，而語句上要是與原本不同的，大部分的方法已經在上面講了大概了~</p><p>現場很少人聽過”變異測試”，但為什麼還是這麼多人不知道變異測試呢?</p><p>我想應該是 Unit Test 還沒有很普及吧，但變異測試對自己的寫出來的程式碼是確實很有幫助的，如果我有需要維護的案子，且有一定的Code Coverage 那我將會嘗試看看這樣子的方式來試試看我的測試程式碼是否寫的足夠好</p><p>當然，這麼廣大的程式碼要手動異動實在是難上加難</p><p>所以 <a href="https://en.wikipedia.org/wiki/Mutation_testing">wikipedia</a> 上就有介紹很多種不同語言的 Mutation Test 的工具可以使用，至於要不要收費我就不知道了(學講師XD</p><p>PS: 工具找出來的變異測試失敗，不一定是真的失敗，有些情境上是工具無法辨別的，不要被工具限制住了</p><p>感謝各位大大收看 如有錯誤 請告訴我&lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 心得 </tag>
            
            <tag> 社群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>閱讀周記 - 持續進化的測試文件之測試文件並不是孤單一個人</title>
      <link href="/2018/03/11/2018-234606/"/>
      <url>/2018/03/11/2018-234606/</url>
      
        <content type="html"><![CDATA[<p>既然測試沒有完成的一天</p><p>那更新測試文件也是沒有結束的一天呢~</p><p>測試是重複的過程，所以什測試文件只有一種嗎?</p><p>這一篇的心得來自於 <em>微軟測試之鑰 微軟一線測試專家技術精華</em>  這一本書的第3章第1節，以下簡稱為此書</p><p><img src="/img/2018-234606/1520775491_57675.jpg"></p><p>  此書在這一部分介紹了一個測試文件檔案主要分文兩種</p><ol><li>產品</li><li>工具</li></ol><p>產品的測試文件檔案是供他人閱讀和使用的檔案，在某些專案合約中惠要求團隊在交付時同時交付一批規定的文件檔案，其中一些檔案是需要由測試人員來撰寫</p><p>工具的測試文件檔案主要是提供測試小組內部閱讀與使用，或是測試人員個人的文件檔案，其目的就是讓測試小組可以透過這個文件做更好的測試。</p><blockquote><p><em>典型的例子是測試團隊的內部 Wiki 和測試人員的筆記，它們內容廣泛、格式靈活、形式多樣，專注於實際的測試工作，不強求檔案的完備與整齊。</em></p><hr><p>節錄自此書第 3-2 頁</p></blockquote><p>我想作者在這邊想表達的是，測試文件應該要精煉，就算測試文件完備與整齊，依然還是在執行測試之後有遺漏的部分。</p><p>在第3章中作者只會提到關於「工具」類型的測試文件檔案</p><p>作者提到測試人員</p><blockquote><p><em>編寫測試文件時，不但要考慮到文件檔案的實用性，還要考慮讀者，為他們提供有價值的資訊。</em></p><hr><p>節錄自此書第 3-2 頁</p></blockquote><p>在這裡作者把測試文件的內容分為兩部分，而我也會針對作者分別提出的項目來記錄我的想法與心得</p><ol><li>專案範圍的文件檔案</li><li>非專案範圍的文件檔案</li></ol><h2 id="專案範圍的文件檔案"><a href="#專案範圍的文件檔案" class="headerlink" title="專案範圍的文件檔案"></a>專案範圍的文件檔案</h2><p>作者提到常見的專案範圍文件檔案通常包括以下幾個部分</p><ul><li><h3 id="測試計畫"><a href="#測試計畫" class="headerlink" title="測試計畫"></a>測試計畫</h3></li><li><h3 id="測試設計規則"><a href="#測試設計規則" class="headerlink" title="測試設計規則"></a>測試設計規則</h3></li><li><h3 id="測試總結報告"><a href="#測試總結報告" class="headerlink" title="測試總結報告"></a>測試總結報告</h3></li><li><h3 id="缺陷報告"><a href="#缺陷報告" class="headerlink" title="缺陷報告"></a>缺陷報告</h3></li></ul><h3 id="測試計畫-1"><a href="#測試計畫-1" class="headerlink" title="測試計畫"></a>測試計畫</h3><p>測試計畫的內容記錄了指導測試過程的一組想法，其中包含了，產品特性、產品風險、測試任務、測試資源、測試進度、測試團隊、團隊合作，等內容。</p><p>測試計畫是保正測試策略能夠被正確執行的一種方式，其內容可以由開發、測試和產品經理一同評估，在評估的過程中可以就開發人員、測試人員的角度來達成一致的意見，以這件事來說，測試計畫的評估與撰寫是一項合作活動，所以測試計畫是合作的成果。</p><p>然而測試計畫不會是一程不變的，他會隨著專案的演進而有所變化</p><h3 id="測試設計規則-1"><a href="#測試設計規則-1" class="headerlink" title="測試設計規則"></a>測試設計規則</h3><blockquote><p><em>記錄了測試策略(一組指定測試設計的想法)和詳細的測試設計。</em></p><hr><p>節錄自此書第 3-3 頁</p></blockquote><p>在看到書上這樣寫的時候我的臉上滿是問號，到底在講什麼鬼…</p><p>簡單來說，測試策略的目的是減少缺陷的出現和發布</p><p>減少缺陷的出現的解決方式是將測試前移，在需求分析與設計架構時先行發現缺陷</p><p>減少缺陷的發布可以使用各種測試方法、技術來驗證和測試程式完成的功能</p><p><img src="/img/2018-234606/304661784c44457a5964.jpg"></p><p>圖片來源: <a href="https://read01.com/zGePO0.html#.WqU5r2puaUk">https://read01.com/zGePO0.html#.WqU5r2puaUk</a></p><blockquote><p><em>由此可見，「測試策略」並不是只由測試人員定製的，它是由一個團隊的各個角色一起來制定和建立的，目的是保證軟體的質量，減少缺陷。</em></p><hr><p>原文網址：<a href="https://read01.com/zGePO0.html">https://read01.com/zGePO0.html</a></p></blockquote><p>測試設計規則 (我想這裡的測試設計規則應該就是 test case) 會被測試人員、開發人員、產品經理進行評估，在評估的過程中，所有團隊的成員可以獲得關於軟體的各項資訊</p><ul><li>測試人員將會更了解軟體，也會獲得更多的測試想法。</li><li>開發人員將會獲得測試資訊，更好的撰寫單元測試。</li><li>產品負責人將了解測試覆蓋率，以及評估專案目前的風險。</li></ul><h3 id="測試總結報告-1"><a href="#測試總結報告-1" class="headerlink" title="測試總結報告"></a>測試總結報告</h3><p>測試總結報告主要的內容包含</p><ul><li>測試涵蓋的功能</li><li>執行過的測試</li><li>測試的過程中獲得了哪些資訊</li><li>未來的測試行動</li></ul><p>透過閱讀測試總結報告，可以使測試、開發、產品經理了解測試進度、風險以及問題等資訊。</p><h3 id="缺陷報告-1"><a href="#缺陷報告-1" class="headerlink" title="缺陷報告"></a>缺陷報告</h3><p>測試人員透過這項報告內容來表達目前的產品品質，而開發人員可以透過這個報告內容需要被修復的缺陷有哪些。</p><p>好的缺陷報告應該要清楚的表達問題是甚麼，預期的結果是什麼。</p><p>壞的缺陷報告會另開發人員無法理解真正的問題在哪裏。</p><h2 id="非專案範圍的文件檔案"><a href="#非專案範圍的文件檔案" class="headerlink" title="非專案範圍的文件檔案"></a>非專案範圍的文件檔案</h2><blockquote><p><em>除了專案範圍的文件檔案，測試人員會撰寫一些測試小組或個人使用的測試文檔</em></p><hr><p>節錄自此書 3-3 頁</p></blockquote><p>作者將非專案範圍的文件檔案列出了以下幾點</p><ul><li><h3 id="操作檔案"><a href="#操作檔案" class="headerlink" title="操作檔案"></a>操作檔案</h3></li><li><h3 id="測試筆記"><a href="#測試筆記" class="headerlink" title="測試筆記"></a>測試筆記</h3></li><li><h3 id="測試資料"><a href="#測試資料" class="headerlink" title="測試資料"></a>測試資料</h3></li><li><h3 id="移交文件檔案"><a href="#移交文件檔案" class="headerlink" title="移交文件檔案"></a>移交文件檔案</h3></li><li><h3 id="測試知識庫"><a href="#測試知識庫" class="headerlink" title="測試知識庫"></a>測試知識庫</h3></li></ul><h3 id="操作檔案-1"><a href="#操作檔案-1" class="headerlink" title="操作檔案"></a>操作檔案</h3><p>這邊說的操作檔案是指測試的過程透過某些形式來進行記錄，例如螢幕截圖、錄影或是撰寫詳細步驟等</p><p>這樣的文件可以協助測試人員一步一步的按照文件上的資料進行操作，順利完成任務</p><h3 id="測試筆記-1"><a href="#測試筆記-1" class="headerlink" title="測試筆記"></a>測試筆記</h3><blockquote><p><em>測試筆記是最重要的測試文件檔案。我使用它記錄測試想法，回顧測試過程，激發測試靈感</em></p><hr><p>節錄自此書 3-4 頁</p></blockquote><p>測試筆記的內容主要包含測試設計、軟體缺陷、測試發現、測試想法等內容</p><p>通常我自己也很常使用筆記的方式去記錄自己突然發現的一些測試項目。</p><h3 id="測試資料-1"><a href="#測試資料-1" class="headerlink" title="測試資料"></a>測試資料</h3><p>作者這邊提到這個部分是指被測試人員整理過後的「測試支援材料」，他舉出了一個例子，測試人員將要測是一款Windows 8 的應用，於是他在微軟網站獲得一份測試指南。</p><p>這一份測試指南可以幫助他學習並掌握Windows 8 應用的基本策略。</p><p>我的想法是有點類似網路上的攻略本或是官方釋出的一些基本文件，利用這些文件與資料來更加了解被測的項目。</p><h3 id="移交文件檔案-1"><a href="#移交文件檔案-1" class="headerlink" title="移交文件檔案"></a>移交文件檔案</h3><p>這項文件檔案主要記錄了過往測試人員的經驗與建議，透過閱讀這一份檔案，可以使測試人員理解相關的測試資料，從而快速上手。</p><h3 id="測試知識庫-1"><a href="#測試知識庫-1" class="headerlink" title="測試知識庫"></a>測試知識庫</h3><p>記錄了測試小組的知識，通常會是一個共筆的地方，比如說wiki，或是雲端空間，其中放置了許多測試內容與經驗等等的</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>從以上這些測試文件檔案的介紹，可以知道測試文件檔案並不是一個人(X)，他是「一組」文件檔案，在軟體不斷進化的過程中，測試人員為了因應這樣的情形，而撰寫出了形形色色的測試文件檔案，然而要使用哪種測試文件檔案，測試人員必須評估專案狀況再決定要編寫哪一種的測試文件。</p><p>然而在這一章節裡面其實會發現作者有一直提到「測試」這件事情是由團隊來一起完成的，這樣大家才能一同維護產品的品質呢!</p><p>這一次想問大家的是</p><h3 id="大家使用的輔助測試工具有哪些呢"><a href="#大家使用的輔助測試工具有哪些呢" class="headerlink" title="大家使用的輔助測試工具有哪些呢?"></a><strong>大家使用的輔助測試工具有哪些呢?</strong></h3><p>我自己是蠻喜歡用心智圖的方式來表達專案將要被測試的範圍的XD</p><p>我自己是先用手繪的方式再轉成圖檔上傳到雲端上~</p><h3 id="周記碎碎念"><a href="#周記碎碎念" class="headerlink" title="周記碎碎念"></a>周記碎碎念</h3><p>這禮拜回家掃墓，晚上的時候跟國中同學聚了一下就沒時間了，不過還是寫出了這一篇心得XD</p><p>下一次如果假日有事，或許就要提前的把心得寫出來了XD</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 讀書心得系列 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>閱讀周記 - 測試人員如何面對複雜的軟體?</title>
      <link href="/2018/03/03/2018-165348/"/>
      <url>/2018/03/03/2018-165348/</url>
      
        <content type="html"><![CDATA[<p>現在的軟體複雜度已遠遠超越人的理解能力</p><p>身為一個測試人員 該如何面對這樣的情況呢?</p><p><img src="/img/2018-165348/1519571041_84147.jpg"></p><p>這一篇的心得來自於 <em>微軟測試之鑰 微軟一線測試專家技術精華</em>  這一本書的第一章第一節，以下簡稱為此書</p><p><img src="/img/2018-165348/1520059297_73102.png">拍攝於此書的第 1-2 頁</p><p> 此書作者由 Spolsky 提出「抽象漏洞定律」的經驗法則帶入軟體是很容易出現漏洞的</p><p>ps : Spolsky 是 trello 的創建者，想知道更多到 <a href="https://translate.google.com.tw/translate?hl=zh-TW&sl=en&u=https://en.wikipedia.org/wiki/Joel_Spolsky&prev=search">wiki</a> 上看看他的相關資訊~</p><blockquote><p><em>抽象漏洞定律:「所有不平凡的抽象，在某種程度上，都存在漏洞。」</em></p><hr><p>節錄自此書第 1-4 頁</p></blockquote><p>我想 Spolsky 想表達的是，雖然抽象的語言提升了開發者的生產力，但開發者如果對於抽象概念並不熟悉的條件下，是很容易設計出錯誤的程式碼或架構，進而容易出現漏洞</p><p>此書作者再提出另一件事</p><blockquote><p><em>軟體技術只是軟體複雜性的一部分。</em></p><hr><p>節錄自此書第 1-4 頁</p></blockquote><p>這句話想表達的是軟體技術只是軟體的其中一部份，專案相關人員經過「研究」、「創造」、「應用」後選出目前最合適完成專案項目所需的技術，在「研究」、「創造」、「應用」的過程中，團隊就會遭遇到許多的挑戰與困難。</p><p>光是在需求釐清其實就已經是一個困難的挑戰</p><p><img src="/img/2018-165348/1520060667_95529.png">圖片來源: <a href="https://www.youtube.com/watch?v=BKorP55Aqvg">The Expert (Short Comedy Sketch)</a></p><blockquote><p><em>以上討論不難看出，軟體複雜度包含技術、領域、設計等多個方面。</em></p><hr><p>節錄自此書第 1-5 頁</p></blockquote><p>此書作者簡單的陳述一些基本態度和方法來讓測試人員知道該如何面對這樣複雜的軟體，我把它條列成以下幾點</p><ul><li><h3 id="多方管道來理解被測項目"><a href="#多方管道來理解被測項目" class="headerlink" title="多方管道來理解被測項目"></a>多方管道來理解被測項目</h3></li><li><h3 id="重複實施測試"><a href="#重複實施測試" class="headerlink" title="重複實施測試"></a>重複實施測試</h3></li><li><h3 id="累積與學習測試技術"><a href="#累積與學習測試技術" class="headerlink" title="累積與學習測試技術"></a>累積與學習測試技術</h3></li><li><h3 id="拆解被測項目-建立產品模型"><a href="#拆解被測項目-建立產品模型" class="headerlink" title="拆解被測項目(建立產品模型)"></a>拆解被測項目(建立產品模型)</h3></li><li><h3 id="不可對「小量變更」的程式碼掉以輕心"><a href="#不可對「小量變更」的程式碼掉以輕心" class="headerlink" title="不可對「小量變更」的程式碼掉以輕心"></a>不可對「小量變更」的程式碼掉以輕心</h3></li><li><h3 id="利用自動化測試"><a href="#利用自動化測試" class="headerlink" title="利用自動化測試"></a>利用自動化測試</h3></li></ul><p>接下來我針對上述的 6 點來稍微描述一下我的心得和想法</p><h3 id="多方管道來理解被測項目-1"><a href="#多方管道來理解被測項目-1" class="headerlink" title="多方管道來理解被測項目"></a>多方管道來理解被測項目</h3><p>在面對一個複雜軟體或複雜的需求時，我們沒辦法一步到位，無法直接開發到完整，更無法直接測試到完整，甚至有時候在理解需求和軟體時可能會造成一些偏誤。</p><p>為了更加了解軟體與需求，測試人員需要與多方合作，包含PO、RD、UI&#x2F;UX以及測試同事等，透過多方面向來理解被測項目的內容是什麼，哪些部分是需要被測試的，哪些部分事需要多加注意的。</p><h3 id="重複實施測試-1"><a href="#重複實施測試-1" class="headerlink" title="重複實施測試"></a>重複實施測試</h3><p>因為軟體的複雜度，大多數的測試人員在專案的初期都不會太了解軟體，擬定出來的測試策略和項目都很有可能帶有錯誤的理解。</p><p>一個注重實際效益的測試人員，通常會承認他自己的測試方案是不完備的，所以他們會重複的實施測試，並透過持續的測試過程來思考如何加強現有的測試方案。</p><h3 id="累積與學習測試技術-1"><a href="#累積與學習測試技術-1" class="headerlink" title="累積與學習測試技術"></a>累積與學習測試技術</h3><p>在這個軟體複雜度極高的世界中，「窮舉」測試是不可行的，如果給測試人員一個軟體，我相信專業的測試人員可以列出無限個測試項目，但列出這麼多的測試項目是有意義的嗎?</p><p>題外話 : 某一部分的公司會要求測試人員列出N個測試項目來納入他們的KPI，這跟要求開發人員寫幾行程式碼來列入KPI一樣沒有意義。</p><p>所謂的測試技術，就是可以使用他來評估軟體，測試技術五花八門，但任何一種測試技術都有「無法正確評估軟體」的風險<br>所以測試人員必須掌握、學習、累積多種測試技術，綜合運用他們，並隨著專案的不同去挑選適合的測試技術來綜合使用，如此一來才較能夠避免重大的測試遺漏。</p><p>跟開發人員一樣的概念<br>掌握的測試技術越多，那你的測試廣度就越廣。</p><h3 id="拆解被測項目-建立產品模型-1"><a href="#拆解被測項目-建立產品模型-1" class="headerlink" title="拆解被測項目(建立產品模型)"></a>拆解被測項目(建立產品模型)</h3><p>對於複雜的項目進行拆解處理，是人們常用的作法，也是敏捷開發中會使用的方法</p><p>測試也是一樣，針對複雜性高的軟體，測試人員需要將被測項目拆解成各個模型，藉以突出哪一些部分是重要的、必須的。</p><p>邰曉梅老師的書中有特別講述如何Modeling產品，之後會再將她的文章內容寫成自己的心得給大家參考參考~</p><h3 id="不可對「小量變更」的程式碼掉以輕心-1"><a href="#不可對「小量變更」的程式碼掉以輕心-1" class="headerlink" title="不可對「小量變更」的程式碼掉以輕心"></a>不可對「小量變更」的程式碼掉以輕心</h3><p>在大規模的軟體中，對於小量變更的程式碼絕對不能掉以輕心，因為對於開發者、Code Reviewer、Tester 來說，都難以預料這段程式碼被使用的情境和執行後的影響</p><blockquote><p><em>例如，程式設計師要修改網頁瀏覽器(如IE、Chrome、Firefox等)排版引擎的一個排版缺陷，通常需要執行大規模的的回歸測試。<br>因為全世界的網頁千差萬別，很難預測這段程式碼會排版成何種網頁，也很難預測這段程式碼是否會破壞某些精心編排的頁面，只有執行大規模測試，才能保證程式碼變更的正確性。</em></p><hr><p>節錄自此書第 1-6 頁</p></blockquote><p>PS: 我相信很多人應該有因為某些小量變更而不進行測試直接上線之後而造成悲劇的經驗。</p><h3 id="利用自動化測試-1"><a href="#利用自動化測試-1" class="headerlink" title="利用自動化測試"></a>利用自動化測試</h3><p>自動化測試是很值得讓測試人員使用的工具，他可以執行簡單而重複性高的測試內容，這就是電腦能夠且擅長做的事。</p><p>人類對於重複性高的動作容易厭倦，容易犯錯，在面對複雜度高的軟體勢必有更多的地方是重複性高且簡單的動作是可以交給電腦來執行和驗證的</p><p>但並不是每一項東西都能夠或是必須使用自動化測試，測試人員應該謹慎的評估哪些是需要被自動化測試的，哪些是手動測試比較好的。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這本書真的很棒，光是第一章我就覺得十分的有感，未來將會再針對自己很有感覺的部分進行整理和心得分享!!!</p><p>在這裡想問大家 1 個問題</p><h3 id="大家是用甚麼樣的心態來執行測試的呢"><a href="#大家是用甚麼樣的心態來執行測試的呢" class="headerlink" title="大家是用甚麼樣的心態來執行測試的呢?"></a>大家是用甚麼樣的心態來執行測試的呢?</h3><p>以上 感謝各位大大的觀看 &lt;(_ _)&gt;</p><p>如果內容有誤，煩請糾正~ 謝謝</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 讀書心得系列 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - 我舉辦了一場 Bug Bash－大家都進來測試吧!!</title>
      <link href="/2018/02/28/2018-195303/"/>
      <url>/2018/02/28/2018-195303/</url>
      
        <content type="html"><![CDATA[<p>人生中第一次主持團隊中的會議</p><p><img src="/img/2018-195303/1519833850_09932.png"><br>圖片來源 : <a href="https://www.facebook.com/menhou/">【綿峰】重症繪圖者</a> 、 <a href="https://forum.gamer.com.tw/C.php?bsn=24044&snA=34253">巴哈姆特 爐石戰技版-【四格漫畫】大家都進來吧！</a></p><p>大家都進來吧!!!<br>有玩爐石的應該就會知道這張卡XDDD<br>好吧 沒有人玩 嗚嗚</p><h2 id="為什麼要舉辦這個活動"><a href="#為什麼要舉辦這個活動" class="headerlink" title="為什麼要舉辦這個活動"></a>為什麼要舉辦這個活動</h2><p>當初也不知道這個活動，而是有一天閒閒沒事從某位大大的部落格看到了一篇文章是關於 Bug Bash 的覺得可以在團隊中嘗試看看</p><p>其實我在舉辦這個活動時沒有稱這個活動為 Bug Bash 而是叫 Test Together</p><p>無論名字為何，都是請團隊的大家一起進來參與測試</p><h3 id="站在不同角度的來執行軟體是測試的其中一環"><a href="#站在不同角度的來執行軟體是測試的其中一環" class="headerlink" title="站在不同角度的來執行軟體是測試的其中一環"></a>站在不同角度的來執行軟體是測試的其中一環</h3><p>測試不單單只是測試這個軟體是否可運行，常常是需要站在不同角度來執行測試的</p><p>證嚴法師說過一句話「一個缺口的杯子，換一個角度仍然是圓的。」</p><p><img src="/img/2018-195303/1459336546_986.jpg" alt="「不同角度」的圖片搜尋結果"><br>圖片來源 : <a href="http://ezvivi2.com/article/205234.asp">http://ezvivi2.com/article/205234.asp</a></p><p>相反來說，一個看起來沒有缺口的杯子，換一個角度就有可能會出現缺口。</p><p>所以測試人員常常需要站在客戶的角度、PO的角度等等的，還有很常需要人格分裂(?) 讓自己變成其他的軟體旅行者</p><p>比如說我是一個很傲慢的旅行者，我就會針對軟體進行一些不合”正常”邏輯的測試，像是提交訂單並支付後又取消訂單並要求退款、或是提交訂單之後更改送貨地點。</p><p>又或是說我是一個到著名景點後遊歷到周邊地區的旅行者，我就會針對軟體非主要功能進行測試，比如說進入那些不起眼的連結與觀看說明文字等。</p><p>在這一場測試之中，每一個人都是不同的旅行者，有RD、有UI&#x2F;UX、有PO等等不同的團隊角色</p><p>他們會是真正的「旅行者」，而不是測試人員「模擬」出來的旅行者</p><h3 id="Testing-To-Learn"><a href="#Testing-To-Learn" class="headerlink" title="Testing To Learn"></a>Testing To Learn</h3><p>從邰曉梅老師的海盜派測試這本書中我學到了使用測試來學習這件事。</p><p>因為團隊中的有一些人可能只有在做純粹開發並沒有真正實際的使用軟體的經驗，所以希望透過這一次的活動可以讓他們瞭解自己所產出的產品是如何在客戶面前搔首弄姿(?)的</p><p>這樣除了讓團隊中的成員更了解自己的產品之外，也或許能取得到更多的 feed back。 以後也可以讓團隊成員的大家一起來測試了XD</p><h2 id="參加活動的人員"><a href="#參加活動的人員" class="headerlink" title="參加活動的人員"></a>參加活動的人員</h2><p>除了團隊成員邀請進入了這一次的活動之外，我還邀請了QA團隊中的其他成員進來這一場活動。</p><p>為的是希望可以有「沒有使用過這個產品」經驗的QA人員來使用與測試這項產品，就可以取得更多其他角度的 Feed Back</p><h2 id="我如何舉辦這場活動"><a href="#我如何舉辦這場活動" class="headerlink" title="我如何舉辦這場活動"></a>我如何舉辦這場活動</h2><p>這一次的活動總共使用的時間只有40分鐘，因為是第一次執行，並且是針對只 run 了 3 個 sprint 的系統進行測試</p><p>前置的說明(說明為何要進行這場活動等等)、進入系統的方式(測試環境)、使用系統的步驟 (跑一遍我寫的其中一個測試案例) 就花了20~25分鐘之久，可能是因為我太害怕團隊沒跟上操作的動作，不過我想第一次這麼做應該是好事，之後就不用再這麼冗長的說明了。</p><p>再一次前面這些冗長的說明結束之後，讓團隊的成員開始使用軟體。</p><p>我設了大概10分鐘的時間讓參加這次活動的成員進行測試，最後5分鐘的時間讓大家給予 Feed Back。</p><h2 id="舉辦活動後的-Feed-Back"><a href="#舉辦活動後的-Feed-Back" class="headerlink" title="舉辦活動後的 Feed Back"></a>舉辦活動後的 Feed Back</h2><p>這一次活動結束 我有稍微做一點點的 Retro</p><p>因為忘記拍照了，所以那些東西……就掰掰了</p><p>不過我有稍微整理過了 Retro 過後的產出</p><ul><li>這一次的活動找到了很重要的 defect !!</li><li>這一次的活動感覺起來有點嚴肅</li><li>這一次的活動說明的時間有點太長</li><li>如果有機會我會在我的團隊中執行這項活動</li><li>活動讓我更了解自己的產品</li><li>某一個 defect 活動結束過後需要修正</li><li>不知道為什麼我的電腦沒辦法進入系統</li></ul><p>自己給對於再次舉辦這一類型的活動感想與建議</p><ul><li>可以放音樂讓大家心情放鬆，會比較沒那麼嚴肅。</li><li>也可以放食物或飲料給參與這次活動的成員取用，也會比較沒那麼嚴肅。</li><li>前置的過程與步驟過於繁雜導致之後的 solo 測試時間太短，但因為大家都是第一次進入這項系統中，之後應該就不會有這麼繁雜的步驟了。</li><li>下一次邀請外部的QA人員需要跟他們說明更多的相關事項，以及獎勵，對於專業的他們來說，前置的過程與步驟太過於無聊(因為那些東西都是他們日常的動作)。</li><li>如果下一次舉辦的人員夠多，可以分組進行，並以競賽的方式，找到越多bug的團隊或是個人，將有特殊的獎勵。</li></ul><p>這一次的活動其實我個人覺得沒有舉辦的很好，但反應看起來還算預期之內 畢竟沒有零食和飲料</p><p>但我相信下一次如果再一次進行這樣的活動會有更好的反應!!</p><p>這一個活動需要感謝柯仁傑與公司裡的Ruddy老師給予建議和參考連結!! (跪拜</p><p>參考過的文章有</p><p>Bug bash<br><a href="http://kojenchieh.pixnet.net/blog/post/75406105-bug-bash">http://kojenchieh.pixnet.net/blog/post/75406105-bug-bash</a></p><p>网易方法论：手把手教你做Bug Bash（缺陷大扫荡）<br><a href="http://www.woshipm.com/pd/698379.html">http://www.woshipm.com/pd/698379.html</a></p><p>干货总结：敏捷QA实践－Bug Bash<br><a href="https://www.testwo.com/article/517">https://www.testwo.com/article/517</a></p><p>How to run a bug bash<br><a href="http://scottberkun.com/2008/how-to-run-a-bug-bash/">http://scottberkun.com/2008/how-to-run-a-bug-bash/</a></p><p>感謝各位大大觀看 如內容有勘誤或對於這一次的活動有任何的建議都歡迎一起討論 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> 心得 </tag>
            
            <tag> 敏捷開發 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 - 我的閱讀周記，為了成長，為了更強。</title>
      <link href="/2018/02/25/2018-ReedingList/"/>
      <url>/2018/02/25/2018-ReedingList/</url>
      
        <content type="html"><![CDATA[<p>2月快要結束了，剛過完年，我決定要把今年看過的書，要看的書，全都記錄下來。</p><p>最近買了一大堆的書籍，但閱讀速度太慢了，我想是因為沒有壓力的關係，所以我決定要以寫文章的方式來讓自己有壓力一點</p><p>這一篇會置頂到年底，然後重新審視一下今年寫了有關於閱讀心得的文章有多少篇，書籍的照片也會持續更新。</p><p>正所謂 1.01 的 365次方 永遠比 0.99 的 365 次方來得大唄</p><p>每天一點點的成長，總有一天能夠成為強大的人</p><p>這篇會把要看的書籍排出來 由左到右 由上到下 是看書的順序組合</p><p><img src="/img/2018-ReedingList/1519570691_72109.jpg"></p><p>目前已經正在閱讀的是軟體測試之鑰－微軟一線測試專家以及 你會問問題嗎，以下書名的Link皆連至博客來~</p><p>1. <a href="http://search.books.com.tw/redirect/move/key/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6%E4%B9%8B%E9%91%B0/area/mid/item/0010654170/page/1/idx/1/cat/001/pdf/1" title="軟體測試之鑰：微軟一線測試專家技術精華">_軟體__測試__之__鑰_：微軟一線_測試_專家技術精華</a></p><p>在本周(3&#x2F;5)之前將會至少寫一篇其中一章的心得文</p><p><img src="/img/2018-ReedingList/1519571041_84147.jpg"></p><p>以下為書籍閱讀排序</p><p>2. <a href="http://search.books.com.tw/redirect/move/key/%E4%BD%A0%E6%9C%83%E5%95%8F%E5%95%8F%E9%A1%8C%E5%97%8E/area/mid/item/0010478689/page/1/idx/1/cat/001/pdf/1" title="你會問問題嗎：問對問題是成功領導的第一步(作者來台紀念版)">_你__會__問問__題__嗎_：問對問題是成功領導的第一步(作者來台紀念版)</a></p><p>3. <a href="http://search.books.com.tw/redirect/move/key/%E5%9C%98%E9%9A%8A%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BB%98%E6%AD%A3%E7%A2%BA%E7%9A%84%E8%BB%9F%E9%AB%94/area/mid/item/0010644283/page/1/idx/1/cat/001/pdf/0" title="Specification by Example 中文版：團隊如何交付正確的軟體">Specification by Example 中文版：<em>團隊__如何__交付__正確__的__軟體</em></a></p><p>4. <a href="http://search.books.com.tw/redirect/move/key/%E6%8E%A2%E7%B4%A2%E5%BC%8F%E8%BB%9F%E4%BB%B6%E6%B8%AC%E8%A9%A6/area/mid/item/CN10403659/page/1/idx/3/cat/CN1/pdf/0" title="探索式軟件測試"><em>探索__式__軟件__測試</em></a></p><p>5. <a href="http://search.books.com.tw/redirect/move/key/continous+delivery/area/mid/item/0010653820/page/1/idx/1/cat/001/pdf/1/fm/1" title="Continuous Delivery中文版：利用自動化的建置、測試與部署完美創造出可信賴的軟體發佈">Continuous _Delivery_中文版：利用自動化的建置、測試與部署完美創造出可信賴的軟體發佈</a></p><p>6.  <a href="http://search.books.com.tw/redirect/move/key/effective+ruby/area/mid/item/0010688184/page/1/idx/1/cat/001/pdf/1" title="Effective Ruby中文版：寫出良好Ruby程式的48個具體做法"><em>Effective</em> _Ruby_中文版：寫出良好_Ruby_程式的48個具體做法</a></p><p>7. <a href="http://search.books.com.tw/redirect/move/key/%E7%B2%BE%E5%AF%A6%E7%9C%8B%E6%9D%BF/area/mid/item/0010669225/page/1/idx/4/cat/001/pdf/0" title="精實開發與看板方法">_精__實_開發與_看板_方法</a></p><p>8. <a href="http://search.books.com.tw/redirect/move/key/%E5%91%8A%E5%88%A5%E7%80%91%E5%B8%83/area/mid/item/0010647604/page/1/idx/1/cat/001/pdf/1" title="告別瀑布，擁抱Scrum：解析微軟與Adobe如何在30天內開發出新軟體">_告別__瀑布_，擁抱Scrum：解析微軟與Adobe如何在30天內開發出新軟體</a></p><p>9. <a href="https://www.tenlong.com.tw/products/9787115403650">鳳凰計畫：一個IT計畫的傳奇故事 (The Phoenix Project : A Novel about IT, DevOps, and Helping your business win)沙盤演練特別版 凤凰项目:一个IT运维的传奇故事(天瓏書局)</a></p><p>真的買太多書了，不給自己壓力應該是讀不完惹</p><p>儘管平常都輕鬆看，但都不記錄起來實在是太可惜了 哈哈哈哈哈</p><p>PS: <a href="http://search.books.com.tw/redirect/move/key/%E6%B5%B7%E7%9B%9C%E6%B4%BE%E6%B8%AC%E8%A9%A6/area/mid/item/CN11422919/page/1/idx/1/cat/CN1/pdf/0" title="海盜派測試分析：MFQ&amp;PPDCS">_海盜__派__測試_分析：MFQ&amp;PPDCS</a></p><p>海盜派測試分析的心得文章將會在近期寫出，因為書已經借給同事了，等他歸還給我中XD</p>]]></content>
      
      
      
        <tags>
            
            <tag> 讀書心得系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - 在 Ruby + Cucumber 中更改瀏覽器語言之淺談我今天使用者是外國人的重要性(?</title>
      <link href="/2018/02/15/2018-120635/"/>
      <url>/2018/02/15/2018-120635/</url>
      
        <content type="html"><![CDATA[<p>安安~大家新年快樂<br>今年是除夕，在家就是要裝忙一下寫個文章當個文青(x</p><p>前幾日在團隊內開始使用了Ruby + Cucumber</p><p>因為公司內部有其他團隊是針對國外使用者的專案來做開發的，相對開發內容也會有多國語系的問題</p><p>很湊巧的，使用自動化測試也需要更改語系，才能夠測試到不同語系的被測物件</p><p>所以有一天…..</p><p>我的大腿J老大問我說，欸，你有空嗎?<br>:怎麼了<br>:某一個要做國外案子的團隊需要你的幫忙<br>:我說什麼幫忙?<br>:他需要更改瀏覽器的語言，但我太忙了沒辦法處理<br>:哦 好啊，我有空就看看<br>:對了  我這邊有搜到一個資料，但我怎麼試都不行<br>:好喔 那你傳給我看看</p><p>於是我就開啟了更改瀏覽器語言的搜尋之路</p><p>J大提供的歷史源頭:<a href="http://blog.lucywyman.me/setting-a-language-with-selenium-webdriver-in-ruby.html">http://blog.lucywyman.me/setting-a-language-with-selenium-webdriver-in-ruby.html</a></p><p>我就去蕪存菁的把Code改成這個樣子</p><p><img src="/img/2018-120635/1518668530_99643.png"></p><p>執行之後，他就告訴了我這個錯誤</p><p>WARN Selenium [DEPRECATION] :prefs is deprecated. Use Selenium::WebDriver::Chrome::Options#add_preference instead.</p><p>OK，看起來很不錯，它告訴我這個方法已經被棄用了</p><p>於是我就搜尋了他的推薦 Options的方法</p><p><img src="/img/2018-120635/1518663630_40667.png"></p><p>第一個就是他的文件: <a href="http://seleniumhq.github.io/selenium/docs/api/rb/Selenium/WebDriver/Chrome/Options.html">http://seleniumhq.github.io/selenium/docs/api/rb/Selenium/WebDriver/Chrome/Options.html</a></p><p>進到頁面之後我就Ctrl + F 搜尋 “Options” 找尋我要的內容</p><p><img src="/img/2018-120635/1518663777_78226.png"></p><p>這樣子我就找到了使用Options的結構使用方式的細節了</p><p>它的結構看起來就像宣告一個options後用selenium webdriver chrome 來 new 一個帶有很多個參數的東西<br>再來把這個宣告的options丟進driver裡面的options然後帶入這些參數</p><p>所以，要怎麼用呢?</p><p>這時候到我們使用Selenium-Cucumber建構出來的 env.rb 中的最下層找到 begin 後面，加上這兩行</p><p>options &#x3D; Selenium::WebDriver::Chrome::Options.new(args: [‘–lang&#x3D;en’])<br>$driver &#x3D; Selenium::WebDriver.for(:”#&#x2F;{$browser_type&#x2F;}”, options: options)</p><p>圖示:</p><p><img src="/img/2018-120635/1518668994_17205.png"></p><p>就可以了</p><p>現在就來執行一下，就可以發現到，它左上角的提示變成英文了。</p><p><img src="/img/2018-120635/1518668581_24657.png"></p><p>這樣就成功惹</p><p>有興趣可以到<a href="https://github.com/SQZ777/RubyDemoWithGoogle/blob/master/features/support/env.rb">這個GitHub的repositry</a>上看到env.rb檔喔</p><h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><p>這時候我就開始想了，除了英文之外Chrome還有其他語言啊…</p><p>要如何改呢，比如說日文? 之類的</p><p>經過查詢之後，在<a href="https://peter.sh/experiments/chromium-command-line-switches/">官方文件</a>發現了lang後面的縮寫是使用 <a href="https://zh.wikipedia.org/wiki/ISO_639-1%E4%BB%A3%E7%A0%81%E8%A1%A8">ISO-639</a>的格式去做的</p><p><img src="/img/2018-120635/1518666695_61232.png"></p><p>所以如果要使用日文的話..試試看 –lang&#x3D;ja 試試</p><p><img src="/img/2018-120635/1518667217_70336.png"></p><p>果然就變成日文啦!!!</p><p>超酷der</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Selenium </tag>
            
            <tag> ChromeDriver </tag>
            
            <tag> Automation </tag>
            
            <tag> Ruby </tag>
            
            <tag> Cucumber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows - 讓相貌難看的 windwos command 視窗整形(?) －Ansicon 安裝一波!</title>
      <link href="/2018/02/04/2018-001738/"/>
      <url>/2018/02/04/2018-001738/</url>
      
        <content type="html"><![CDATA[<p>因為我覺得這個安裝的方式可以拉出來當一篇文章所以就直接這麼做了 A_A</p><p>使用cucumber時，時常需要下指令，看結果，而每一次的結果都只有黑色的實在是…</p><p><img src="/img/2018-001738/1517674357_47729.png"></p><p>所以就發現了Ansicon這個東西啦，最後我會貼上一個比較圖使用前後的兩張圖</p><p>首先先讓我們下載Ansicon吧!</p><p><a href="https://github.com/adoxa/ansicon/releases">Ansicon Releases 連結在此</a></p><p>進去之後，版本都可以用，我自己是選最新的來用</p><p><img src="/img/2018-001738/1516448889_74666.png"></p><p>下載之後他會是一個zip壓縮檔，把他解壓縮到你平常看不到的地方<br>把他解壓縮之後，記住他的位置，目前我自己是直接放進C槽中，也比較方便</p><p>C:\ansi181</p><p>在安裝之前我們先設定環境變數</p><p>所以我們要先來控制台-&gt;系統及安全性-&gt;系統-&gt;進階設定-&gt;環境變數</p><p><img src="/img/2018-001738/1516449287_33959.png"></p><p>進去之後點選系統</p><p><img src="/img/2018-001738/1516449315_88169.png"></p><p>進去系統之後點選，進階設定</p><p><img src="/img/2018-001738/1516449341_13458.png"></p><p>接下來點選環境變數</p><p><img src="/img/2018-001738/1516449363_23916.png"></p><p>打開來之後點選Path再按下編輯，或是雙擊也可以。</p><p><img src="/img/2018-001738/1516449422_83527.png">輸入你安裝的路徑</p><p>C:\ansi181\x64</p><p>像我的作業系統是64位元的，所以我的結尾是x64，如果你的作業系統是32位元的話就以x86做結尾</p><p><img src="/img/2018-001738/1516449472_51852.png"></p><p>或如下圖，再按下新增</p><p><img src="/img/2018-001738/1517673589_8054.png"></p><p>把他解壓縮出來之後，來開啟我們可愛的 CMD 命令提示字元 </p><h3 id="win-R-輸入-cmd-就可以叫出來了"><a href="#win-R-輸入-cmd-就可以叫出來了" class="headerlink" title="win + R 輸入 cmd 就可以叫出來了"></a>win + R 輸入 cmd 就可以叫出來了</h3><p>叫出來之後，如果你的解壓縮路徑跟我一樣，就輸入這個</p><p>C:\ansicon\x64\ansicon.exe -i</p><p>這樣就可以完成安裝了! (他甚麼事都不會發生</p><p><img src="/img/2018-001738/1517671985_73555.png"></p><p>先來看看使用前的狀況，就拿前一篇寫的範例來執行吧!</p><p><img src="/img/2018-001738/1517673755_26601.png"></p><p>這個是安裝完成後執行的畫面</p><h3 id="如果你安裝完成之後執行還是沒變，請重新開機"><a href="#如果你安裝完成之後執行還是沒變，請重新開機" class="headerlink" title="如果你安裝完成之後執行還是沒變，請重新開機"></a>如果你安裝完成之後執行還是沒變，請重新開機</h3><p><img src="/img/2018-001738/1517673952_76624.png"></p><p>看起來超棒的RRRRRRRRRRRRRRRRRRRRRRR</p><h2 id="綠綠的"><a href="#綠綠的" class="headerlink" title="綠綠的"></a>綠綠的</h2><p>以上是這次的內容，感謝各位大大收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - Ruby + Cucumber 常用的 Selenium-Cucumber Ruby API&#39;s 哦哦哦哦哦</title>
      <link href="/2018/01/30/2018-173146/"/>
      <url>/2018/01/30/2018-173146/</url>
      
        <content type="html"><![CDATA[<p>這一篇來介紹常用的幾個 selenium-cucumber 常用的 API</p><p>知道越多已經存在的東西，就不需要再自己造輪子，或是使用很慢的方法來解決現有的問題。</p><p><img src="/img/2018-173146/busy-1495628423.png" alt="「we are too busy」的圖片搜尋結果"></p><p>有興趣了解更多的可以到他的 git 文件看到更多他的API</p><p>這是個是他的 <a href="https://github.com/sameer49/selenium-cucumber-ruby/blob/master/doc/selenium-cucumber-API.md">git 文件</a></p><p>想知道在更多的話就要到他的 lib 看他底層是如何寫的，會發現更多他原本就寫好的 API~</p><p>這一次要介紹的幾個常用的API分別是</p><ul><li>is_element_displayed</li><li>enter_text</li><li>clear_text</li><li>click</li><li>scroll_page</li><li>wait</li></ul><p>我在這直接寫一個範例進行說明，feature檔就會長這個樣子</p><pre><code>Feature: Demo APIs  Scenario: As a normal user I can search somethingb    Given I input somethingB    When I Click search button    Then I scroll to end</code></pre><p>我們先看實際執行結果</p><p><img src="/img/2018-173146/1517213484_664.gif"></p><p>接下來我們針對每一個Given And When Then的code來解釋</p><p>在開始針對某部分的code開始看之前，先看看在 custom_steps.rb 中的程式碼</p><pre><code>#custom_stepsrequire &#39;selenium-cucumber&#39;google_page = GOOGLEPAGE.newGiven(&#39;I input somethingB&#39;) do  navigate_to(&#39;https://www.google.com/&#39;)  google_page.input_somethinga  google_page.clear_something  google_page.input_somethingbendWhen(&#39;I Click search button&#39;) do  google_page.click_btnendThen(&#39;I scroll to end&#39;) do  google_page.scroll_endend</code></pre><p>在這裡可以看到 custom_steps 中有用到了許多 GOOGLEPAGE 中的方法，來讓 webdriver 做動作，接著要來看看全部的 GOOGLEPAGE 的 code，如下</p><pre><code>#google pageclass GOOGLEPAGE  XPATHS = /&#123;    btn: &#39;//*[@name=&quot;btnK&quot;]&#39;,    textbox: &#39;//*[@name=&quot;q&quot;]&#39;  /&#125;.freeze  def input_somethinga    enter_text(:xpath, &#39;somethinga&#39;, XPATHS[:textbox])  end  def clear_something    clear_text(:xpath, XPATHS[:textbox])  end  def input_somethingb    enter_text(:xpath, &#39;somethingb&#39;, XPATHS[:textbox])  end  def click_btn    is_element_displayed(:xpath, XPATHS[:btn])    click(:xpath, XPATHS[:btn])  end  def scroll_end    scroll_page(&#39;end&#39;)    wait(1)  endend</code></pre><h2 id="現在來關注一下裡面Code的語法吧"><a href="#現在來關注一下裡面Code的語法吧" class="headerlink" title="現在來關注一下裡面Code的語法吧"></a>現在來關注一下裡面Code的語法吧</h2><h3 id="navigate-to-‘url’"><a href="#navigate-to-‘url’" class="headerlink" title="navigate_to(‘url’)"></a>navigate_to(‘url’)</h3><p>這一個方法就是將你傳到某一個網址，由這一行code可以看到是將我們帶到google的首頁</p><h3 id="enter-text-尋找方式-‘輸入文字’-‘xpath路徑’"><a href="#enter-text-尋找方式-‘輸入文字’-‘xpath路徑’" class="headerlink" title="enter_text(尋找方式, ‘輸入文字’, ‘xpath路徑’)"></a>enter_text(尋找方式, ‘輸入文字’, ‘xpath路徑’)</h3><p>這一個方法可以在程式碼中看到我是使用XPATH的尋找方式，在找到的位置輸入somethinga</p><p>enter_text(:xpath, ‘somethinga’, XPATHS[:textbox])</p><h3 id="clear-something-尋找方式-‘xpath路徑’"><a href="#clear-something-尋找方式-‘xpath路徑’" class="headerlink" title="clear_something(尋找方式, ‘xpath路徑’)"></a>clear_something(尋找方式, ‘xpath路徑’)</h3><p>這一個方法一樣的格式，只是少了需要輸入數字，這個方法會幫我們將找到路徑的元素清空</p><h3 id="is-element-displayed-尋找方式-‘xpath路徑’"><a href="#is-element-displayed-尋找方式-‘xpath路徑’" class="headerlink" title="is_element_displayed(尋找方式, ‘xpath路徑’)"></a>is_element_displayed(尋找方式, ‘xpath路徑’)</h3><p>這個方法是為了確認方法是否存在，常常頁面載入完成後，元素還沒出現的可能，所以很常會需要這個方法來確認元素是否出現了</p><h3 id="scroll-‘to’"><a href="#scroll-‘to’" class="headerlink" title="scroll(‘to’)"></a>scroll(‘to’)</h3><p>這個方法是捲動瀏覽器中的捲軸，end是卷到底，top是到最上方，很簡單明瞭</p><h3 id="wait-time"><a href="#wait-time" class="headerlink" title="wait(time)"></a>wait(time)</h3><p>這個方法是為了讓頁面等待時使用，time的單位是秒。</p><p>這一次的git url</p><p><a href="https://github.com/SQZ777/RubyDemoWithGoogle">https://github.com/SQZ777/RubyDemoWithGoogle</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Selenium </tag>
            
            <tag> ChromeDriver </tag>
            
            <tag> Automation </tag>
            
            <tag> Ruby </tag>
            
            <tag> Cucumber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - Ruby + Cucumber 之 惱人的 Duration Error</title>
      <link href="/2018/01/22/2018-215349/"/>
      <url>/2018/01/22/2018-215349/</url>
      
        <content type="html"><![CDATA[<p>惱人的 Duration Error</p><p>這個問題卡了整整我兩個假日的晚上…</p><p>警察叔叔..就是這個問題QAQ</p><p><a href="https://twitter.com/hashtag/%E8%AD%A6%E5%AF%9F%E5%8F%94%E5%8F%94%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E4%BA%BA"><img src="/img/2018-215349/C7WnbWNVAAAIBMN.jpg">圖片轉自:twitter</a></p><p>上週在裝環境的時候其實有碰到一樣的問題<br>因為抱了公司裡的大腿，一下就解決了<br>但沒有及時的把它記下來，浪費了我兩個晚上的青春 嗚嗚</p><p>所以…對我來說</p><h2 id="紀錄這件事是非常重要的"><a href="#紀錄這件事是非常重要的" class="headerlink" title="紀錄這件事是非常重要的"></a>紀錄這件事是非常重要的</h2><p>不然我會忘記…</p><p>好了，現在來開始解決這個問題吧</p><p>今天照著前幾天的環境準備的文章操作了一遍，終於可以開始cucumber一波了嗎? 不<br>你開開心心的 init 了一個專案，然後再開開心心的cucumber一波</p><p>結果發現了下圖這樣的狀況…..</p><p><img src="/img/2018-215349/1516628185_62915.png"></p><p>今天到公司去問大腿該如何解決這個問題，我記得上周是uninstall了某一個套件然後再裝這個套件的另一個版本，但我忘了是哪個版本哪個套件了</p><p>於是我就得到了答案</p><p>是因為appium_lib 的 9.8.3 版本的套件在作祟</p><p>所以就先把這個 appium_lib 解除安裝吧!!!</p><p>在CMD下這個指令</p><p>gem uninstall appium_lib</p><p>他就會問你真的要解除安裝這個套件嗎? 因為他selenium-cucumber-3.1.5相依在他身上<br>這時候按下y就可以了(大小寫都可以</p><p><img src="/img/2018-215349/1516628655_06409.png"></p><p>按下y之後很快的他就解除安裝完成了</p><p>再來就要重新安裝他，版本要選用 9.7.5，在CMD下輸入這個指令</p><p>gem install appium_lib -v 9.7.5</p><p><img src="/img/2018-215349/1516628829_87661.png"></p><p>安裝完成! 接下來就 cucumber 一波看看</p><p>現在終於出現了正常的錯誤訊息</p><p><img src="/img/2018-215349/1516628895_67229.png"></p><p>他的錯誤訊息是因為沒有fifefox的webdriver所以我們把它修復，就可以了<br>修復完成之後就會有這樣的訊息喔(在跑的過程中也會跑出瀏覽器來</p><p><img src="/img/2018-215349/1516629038_98309.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>如果你把appium-lib裝成9.7.5版本之後還是沒有出現跟我一樣的「正常錯誤訊息」的朋友<br>你可以試試看重新安裝cucumber-expression並把他的版本安裝在5.0.7版本看看</p><p>gem uninstall cucumber-expression</p><p>gem install cucumber-expression -v 5.0.7</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Selenium </tag>
            
            <tag> Automation </tag>
            
            <tag> Ruby </tag>
            
            <tag> Cucumber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的手殘遊記 － 極速開發，成為光一般的男人，VsVim</title>
      <link href="/2018/01/22/2018-234222/"/>
      <url>/2018/01/22/2018-234222/</url>
      
        <content type="html"><![CDATA[<p>2018年，第一堂課程，也是人生第一堂自己掏腰包來上的課</p><p>感謝91送了我這本書XD (終於不用再霸占公司的這本書了</p><p><img src="/img/2018-234222/1516634615_42117.png"></p><p>其實要看到這門課之後決定要不要報是很猶豫的 (無奈沒有第一時間看到課程資訊，所以第一個梯次沒有報到)</p><h2 id="我大概猶豫了三秒這麼久"><a href="#我大概猶豫了三秒這麼久" class="headerlink" title="我大概猶豫了三秒這麼久!!!!"></a>我大概猶豫了三秒這麼久!!!!</h2><p>PS:我超級感謝91哥解決我報名完之後的問題，包含我沒注意到我是第一天(1&#x2F;20)上課這件事 (十分的悲劇QAQ</p><p>之前就有耳聞，轉換成VsVim一開始的這一段路會變成手殘，果不其然自己實際使用之後，整個世界都不一樣了，怕爆</p><p>下午有一半的時間都用來每個學員輪流使用VsVim做 Tennis Game 的 Coding dojo</p><h2 id="上台之後，台下的聲音就變成嗡嗡嗡嗡嗡"><a href="#上台之後，台下的聲音就變成嗡嗡嗡嗡嗡" class="headerlink" title="上台之後，台下的聲音就變成嗡嗡嗡嗡嗡"></a>上台之後，台下的聲音就變成嗡嗡嗡嗡嗡</h2><p>而且腦袋一片空白，明明自己寫了至少兩三次啊…..XD</p><p>原本 Visual Studio 用得越順暢的人，轉換的難度就越高</p><p>我自己覺得 Visual Stidio 有很多熱鍵都用得很順，所以轉換的難度可能…就相對變高了吧(自己講XDDD</p><p>整天課的精隨，除了VsVim的使用之外，我覺得最重要的事情就是</p><h2 id="同樣的問題，有很多個解決方法，尋找最適合，最快的那個就對了。"><a href="#同樣的問題，有很多個解決方法，尋找最適合，最快的那個就對了。" class="headerlink" title="同樣的問題，有很多個解決方法，尋找最適合，最快的那個就對了。"></a>同樣的問題，有很多個解決方法，尋找最適合，最快的那個就對了。</h2><p>就跟很多事情一樣，沒有最好的、最厲害的、最強的，只有最適合的。</p><p>找到能夠快速得到 Feed back 的方式，如果沒有人能給你Feed Back，就自己給自己 Feed Back<br>自己錄影，自己看見<br>自己發現，自己修正</p><p>自己錄影的方式讓我想起以前還在打CS比賽賺零用錢的時候，很常會去看國外的選手比賽紀錄，還有自己把自己打比賽的過程錄起來。</p><p>看別人打，就可以發現一些新的東西，然後學起來<br>看自己打，就可以發現自己缺失了甚麼，然後改善它</p><h2 id="這樣，不斷的反覆錄影練習，就可以變強"><a href="#這樣，不斷的反覆錄影練習，就可以變強" class="headerlink" title="這樣，不斷的反覆錄影練習，就可以變強"></a>這樣，不斷的反覆錄影練習，就可以變強</h2><p><img src="/img/2018-234222/1516635401_26682.png"></p><p>雖然現在因為工作的關係，較少使用到 Visual Studio ，日後應該會比較常使用Visual Studio Code<br>但我在課程結束之後就回去 VS Code 裡面找了 Extension 看看有沒有 Vim這種東西，居然有，實在是太狂了，可以拿來玩玩XDD</p><p>然後今天中午在公司遇到公司的其他大腿，Jamis大大</p><p>他就說，報了91的課手殘了沒<br>:摁 不只手殘 腦也殘了XDDD</p><p>然後就開始閒聊了一下他就說有一些好用的東西可以跟我說A_A<br>不過因為下午專案的事情比較忙就沒有找他一起玩了<br>這幾天再去找他玩玩，看有沒有好玩的東西A_________A</p><p>上了這門課更加深了我自己原有的想法</p><h2 id="我們的時間應該浪費在美好的事物上，重複、無聊又簡單的事交給機器處理就好。"><a href="#我們的時間應該浪費在美好的事物上，重複、無聊又簡單的事交給機器處理就好。" class="headerlink" title="我們的時間應該浪費在美好的事物上，重複、無聊又簡單的事交給機器處理就好。"></a>我們的時間應該浪費在美好的事物上，重複、無聊又簡單的事交給機器處理就好。</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Hello91 </tag>
            
            <tag> 心得 </tag>
            
            <tag> Develop </tag>
            
            <tag> 極速開發 </tag>
            
            <tag> VsVim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - Ruby + Cucumber 的 Automation- 環境準備</title>
      <link href="/2018/01/20/2018-172123/"/>
      <url>/2018/01/20/2018-172123/</url>
      
        <content type="html"><![CDATA[<p>測試框架何其多，多學多做多比較</p><p><img src="/img/2018-172123/1516439893_99697.png"></p><p>繼上一次介紹 Automation Test 的工具好像也有一段時間了</p><p>這幾天真的導入了我目前的工作之中，雖然同樣是使用 Selenium 但是是使用語言不是 Java ，而是 Ruby</p><p>會選用 Ruby 是因為公司裡面有大腿可以抱</p><p>首先要準備的環境有</p><ul><li><a href="https://www.ruby-lang.org/zh_tw/downloads/">Ruby</a></li><li><a href="https://rubygems.org/gems/selenium-webdriver">selenium-webdriver</a></li><li><a href="https://rubygems.org/gems/cucumber">cucumber</a></li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li></ul><h2 id="Ruby環境安裝"><a href="#Ruby環境安裝" class="headerlink" title="Ruby環境安裝"></a>Ruby環境安裝</h2><p>點選我所提供的連結，就可以到 Ruby 官方網頁的下載區中選取屬於你環境的 Ruby 安裝檔<br>如果你是跟我一樣是 windows 作業系統就點選下方圖中我所框起來的連結吧</p><p><img src="/img/2018-172123/1516435222_95991.png"></p><p>進入連結之後會到這個頁面，再針對你的Windows環境選取 64bit (x64) 或是 32bit (x86) 的下載點吧</p><h3 id="因為目前selenium-webdriver目前只支援到-2-4-3-以現在先只安裝-Ruby-的2-4-3版本"><a href="#因為目前selenium-webdriver目前只支援到-2-4-3-以現在先只安裝-Ruby-的2-4-3版本" class="headerlink" title="因為目前selenium-webdriver目前只支援到 2.4.3 以現在先只安裝 Ruby 的2.4.3版本"></a>因為目前selenium-webdriver目前只支援到 2.4.3 以現在先只安裝 Ruby 的2.4.3版本</h3><p><img src="/img/2018-172123/1516438655_18106.png"></p><p>安裝前，我自己是會特別溝這個啦，先避免一些中文亂碼的問題</p><p><img src="/img/2018-172123/1516435562_45557.png"></p><p>安裝完之後，會有這個畫面，他預設是打勾的舊溝起來按 Finish 吧</p><p><img src="/img/2018-172123/1516435640_83072.png"></p><p>按下 Finish之後 他會出現這個CMD(命令提示字元)的畫面</p><p><img src="/img/2018-172123/1516435692_76296.png"></p><p>不要緊張，這個時候她是要問你要安裝什麼東西</p><ol><li>MSYS2的基本安裝</li><li>MSYS2更新</li><li>安裝MSYS2 + MINGW</li></ol><p>這時候我自己是兩個都安裝，就輸入3，按下Enter<br><strong>P.S.: 可以選擇 1 就好</strong></p><p><img src="/img/2018-172123/1516435912_36102.png"></p><p>他就會開始幫你安裝 MSYS2 和 MINGW了<br>這時候就照著步驟走，如果你的系統已經有了MSYS2就不會出現這個畫面。</p><p><img src="/img/2018-172123/1516435939_06564.png"></p><p>然後開始安裝MSYS2</p><p><img src="/img/2018-172123/1516435961_32071.png"></p><p>MSYS2安裝完成之後原本的CMD不會關閉，他會繼續幫你安裝剩餘的東西</p><p><img src="/img/2018-172123/1516436067_52716.png"></p><p>安裝完之後他會問你還有哪些東西是你想安裝的，如果不確定就直接按下Enter，我們就先直接按下Enter吧!<br>直接按下Enter他就會消失不見。</p><p><img src="/img/2018-172123/1516436253_5938.png"></p><p>安裝完畢之後就可以開始使用Ruby啦，你需要使用 Command Prompt with Ruby 來開始使用 Ruby</p><p><img src="/img/2018-172123/1516438094_8613.png"></p><p>開啟之後先確認是否可以使用 Gem 、 Ruby 這兩個指令</p><p>重新開機之後直接開啟CMD就可以使用以下兩個指令，不需要特別找尋command prompt with Ruby</p><p>請下這兩個指令來確認使否能夠執行</p><ul><li>gem -v</li><li>ruby -v</li></ul><p>輸入指令後的畫面會是這個樣子</p><p><img src="/img/2018-172123/1516438829_33227.png"></p><h2 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h2><p>接下來就要裝這兩個套件啦</p><ul><li><a href="https://seleniumcucumber.info/desktop/">selenium-cucumber</a></li></ul><p>首先在剛才叫出來的畫面中輸入</p><p>gem install selenium-cucumber</p><p>他就會開始安裝這個套件</p><p><img src="/img/2018-172123/1516627001_64957.png"></p><p>這樣子目前需要的套件已經安裝完成囉!</p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>Visual Studio Code 是一個微軟所開發的編輯器，他有很多個擴充套件可以使用，我有一些其他的文章有稍微提到一點關於他的東西，有興趣可以到下面兩個連結看看</p><ul><li><h3 id="VSCode-各種好用的擴充套件-Extension-介紹"><a href="#VSCode-各種好用的擴充套件-Extension-介紹" class="headerlink" title="VSCode - 各種好用的擴充套件(Extension)介紹"></a><a href="https://dotblogs.com.tw/im_sqz777/2017/07/30/143557">VSCode - 各種好用的擴充套件(Extension)介紹</a></h3></li><li><h3 id="VSCode－讓我們在VSCode上使用git唄"><a href="#VSCode－讓我們在VSCode上使用git唄" class="headerlink" title="VSCode－讓我們在VSCode上使用git唄"></a><a href="https://dotblogs.com.tw/im_sqz777/2017/07/18/084844">VSCode－讓我們在VSCode上使用git唄</a></h3></li></ul><p>VS Code的安裝很簡單 只要到<a href="https://code.visualstudio.com/">官網的連結</a>，就可以看到大的下載連結</p><p><img src="/img/2018-172123/1516439241_64138.png"></p><p>按下去之後他會帶你到他的文件裡面，然後開始下載，下載完成之後開啟安裝檔，一如往常地看到安裝的介面</p><p><img src="/img/2018-172123/1516439387_16608.png"></p><p>一切都以預設的方式安裝</p><p><img src="/img/2018-172123/1516439433_20394.png"></p><p>這樣就可以完成安裝了</p><p><img src="/img/2018-172123/1516439456_81094.png"></p><p>如果有勾選啟動 VS Code，按下完成就會看到VS Code的畫面，因為是剛安裝他會寫說目前這個版本的變動有哪些還有修正了哪些 Bug</p><p><img src="/img/2018-172123/1516439498_92663.png"></p><p>環境安裝的部分目前已經結束了，下一篇將要紀錄的是如何開始使用  Ruby + Cucumber!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> VSCode </tag>
            
            <tag> Automation </tag>
            
            <tag> Ruby </tag>
            
            <tag> Cucumber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 - 用 dotNetZip 壓縮一波</title>
      <link href="/2017/11/14/2017-002053/"/>
      <url>/2017/11/14/2017-002053/</url>
      
        <content type="html"><![CDATA[<p>好像有點久沒有寫C#的東西了((並沒有XD</p><p>這一次要紀錄的是 dotNetZip</p><p>其實還有很多其他的方法可以進行壓縮 像是shareZip之類的不過這一次因為需求(?) 的關係 只需要用到Zip檔 所以就選了dotNetZip惹 (而且看起來也比較簡單)</p><p>然後因為需求只需要壓縮 所以我就不寫解壓縮了(被揍爆 開玩笑的啦</p><p>這一次紀錄的重點分4段</p><ul><li><h3 id="如何使用dotNetZip"><a href="#如何使用dotNetZip" class="headerlink" title="如何使用dotNetZip"></a>如何使用dotNetZip</h3></li><li><h3 id="壓縮"><a href="#壓縮" class="headerlink" title="壓縮"></a>壓縮</h3></li><li><h3 id="解壓縮"><a href="#解壓縮" class="headerlink" title="解壓縮"></a>解壓縮</h3></li><li><h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3></li></ul><h2 id="如何使用dotNetZip-1"><a href="#如何使用dotNetZip-1" class="headerlink" title="如何使用dotNetZip"></a>如何使用dotNetZip</h2><p>開始使用dotNetZip時，必須要先using Ionic.Zip</p><p>若要 using using Ionic.Zip 則需要先用 Nuget 幫你的專案加入dotNetZip</p><p><img src="/img/2017-002053/1510583552_7733.png"></p><p>接下來就要搜尋 dotnetzip 進行安裝</p><p><img src="/img/2017-002053/1510583838_11995.png"></p><p>安裝完成後就可以在專案內 using Ionic.Zip了</p><h2 id="壓縮-1"><a href="#壓縮-1" class="headerlink" title="壓縮"></a>壓縮</h2><pre><code>var locate = @&quot;D:\dotNetZip Example Files\&quot;;using (var zip = new ZipFile())/&#123;    zip.AddFile(locate + @&quot;resume.pdf&quot;, &quot;TEST Directory&quot;);    zip.Save(locate + &quot;resume.zip&quot;);/&#125;</code></pre><p>以上程式碼為壓縮 就這樣 下一段要講的是解壓縮…….</p><p>zip.AddFile(FileName, directoryArchive)的這個方法</p><p>FileName 就是你即將要壓縮的檔案所在位置<br>directoryArchive 就是你要壓縮時要把它放在哪一個資料夾，若輸入空字串，就是不包進資料夾內<br>若不帶入資料則是該壓所檔案原有的位置</p><p>以上述的程式碼來進行輸出，會得到壓縮檔內長這個樣子</p><p><img src="/img/2017-002053/1510587536_77552.png"></p><p>如果將程式碼改成</p><pre><code>zip.AddFile(locate + @&quot;resume.pdf&quot;);</code></pre><p>則會將他所屬的資料夾帶入，resume.pdf目前在我電腦中所屬的資料夾位置是 D:\dotNetZip Example Files</p><p>所以輸出就會變成以下這個樣子</p><p><img src="/img/2017-002053/1510587791_61832.png"></p><p>如果想要命名包入的資料夾則可以改成這樣</p><pre><code>zip.AddFile(locate + @&quot;resume.pdf&quot;,&quot;TEST Directory&quot;);</code></pre><p>輸出的ZIP檔就會變成以下這個樣子</p><p><img src="/img/2017-002053/1510587862_6643.png"></p><h2 id="解壓縮-1"><a href="#解壓縮-1" class="headerlink" title="解壓縮"></a>解壓縮</h2><p>這一部分要記錄的是解壓縮的部分</p><p>解壓縮相對沒那麼複雜，只需要指定壓縮出來的檔案如何處理，以及位置</p><pre><code>var locate = @&quot;D:\dotNetZip Example Files\&quot;;using (var zip =  ZipFile.Read(locate+&quot;resume.zip&quot;))/&#123;    foreach (var zipEntry in zip)    /&#123;        zipEntry.Extract(locate, ExtractExistingFileAction.OverwriteSilently);    /&#125;/&#125;</code></pre><p>ZipFile.Read(“壓縮檔位置”) 這一段程式碼則是告訴電腦我們的壓縮檔在何處</p><p>locate 即為壓縮出來的檔案位置將要放置何處</p><p>ExtractExistingFileAction 有4個動作</p><ul><li>InvokeExtractProgressEvent</li><li>OverwriteSilently</li><li>DoNotOverwrite</li><li>Throw</li></ul><p>個人常用到的是中間兩個，OverwriteSilently 就是直接覆蓋的意思</p><p>而 DoNotOverwrite 就如字面上所述，不要覆蓋</p><h2 id="結語-1"><a href="#結語-1" class="headerlink" title="結語"></a>結語</h2><p>以上大概就是 dotNetZip 的壓縮 及 解壓縮的使用方法</p><p>如果有需要更詳細一點的解說像是壓縮檔加入密碼、解壓縮密碼、壓縮等級等</p><p>可以到別人寫的<a href="https://dotblogs.com.tw/larrynung/archive/2011/01/03/20534.aspx">部落格</a>或<a href="https://github.com/haf/DotNetZip.Semverd">官方文件</a>進行參考</p><p>若內容有勘誤 麻煩各位大大指點 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Zip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - IntelliJ 環境安裝之 Hello IntelliJ</title>
      <link href="/2017/11/05/2017-130734/"/>
      <url>/2017/11/05/2017-130734/</url>
      
        <content type="html"><![CDATA[<p>最近想多嘗試一些不一樣的IDE，也剛好慢慢的在摸索Java</p><p>就有人推薦試用看看 IntelliJ 這個IDE 所以就來玩玩看了</p><p>原本是在 Eclipse 上寫一點Java的程式，剛好要開始想要研究Minecraft的插件工具所以就想說試試看別的IDE，所以這一次就用 IntelliJ 來開刀啦 (才不是因為潮呢</p><p>首先到<a href="https://www.jetbrains.com/idea/download/#section=windows">官網</a>下載他啦</p><p><img src="/img/2017-130734/1509854991_16649.png"></p><p>下載完成後將安裝檔開啟後進行安裝</p><p><img src="/img/2017-130734/1509855478_45661.png"></p><p>在這一部特別注意的是要勾選相關性跟下載JRE，之後可以節省一些安裝JRE的功夫</p><p><img src="/img/2017-130734/1509855554_33855.png"></p><p>接著就開始安裝啦</p><p><img src="/img/2017-130734/1509855590_47356.png"></p><p>安裝完開啟IntelliJ之後就出現下面這個畫面去確認你有沒有Config可以匯入的，如果沒有就選擇下面的「Do not import settings」即可</p><p><img src="/img/2017-130734/1509855826_04976.png"></p><p>按下OK就會有客製化IDE畫面的選擇，個人是傾向暗色性的畫面 所以我會選右邊的那一個，對長時間看螢幕的我來說比較適合</p><p><img src="/img/2017-130734/1509855877_79653.png"></p><p>這一邊是工具開啟的設定，如果有不需要的就選擇Disable All即可，個人就使用預設的 也就是都開啟就好</p><p><img src="/img/2017-130734/1509855942_717.png"></p><p>在接下來的畫面他會問你需不需要安裝plugins，左邊是如果你是Scala語言的開發者建議安裝，而右邊則若你是比較貼近Vim開發的人，就可以去安裝並啟用他</p><p><img src="/img/2017-130734/1509855986_04237.png"></p><p>按下 Start using IntelliJ IDEA 就會啟動IntelliJ</p><p><img src="/img/2017-130734/1509856084_48205.png"></p><p>這一篇文章是Java的開始，所以就來創建一個新的專案吧!<br>到這個畫面就會發現需要安裝JDK，這時候點選 Download JDK 就會幫你帶入到JAVA官方網站的下載頁面</p><p><img src="/img/2017-130734/1509856172_14828.png"></p><p>這時候直接點選最新的 Download 就會到下一個頁面</p><p><img src="/img/2017-130734/1509856346_35806.png"></p><p>到了下一個頁面之後點選 Accept License Agreement，然後在下方點選自己的環境就可以開始下載JDK了</p><p><img src="/img/2017-130734/1509856435_5527.png"></p><p>接下來把下載好的jdk安裝起來再回到剛才開啟專案的畫面點選右邊的New找到剛才安裝JDK的地方點選那一個資料夾就可以變成以下的畫面<br><strong>通常JDK預設的位置在 C:\Program Files\Java\jdk-9.0.1</strong></p><p><img src="/img/2017-130734/1509856904_47665.png"></p><p>按下一步 (Next) 時，到以下畫面可以看到修改專案名稱。</p><p><img src="/img/2017-130734/1509857163_77996.png"></p><p>專案命名完成之後，就可以看到我的專案</p><p><img src="/img/2017-130734/1509857413_89581.png"></p><p>在寫點程式碼之前先來看看IntelliJ的快捷鍵設定吧，如果你是從別的地方轉來IntelliJ的開發人(類?)，那你可以來到左上角的 File -&gt; Settings<br>或是按下Ctrl + Alt + S快捷鍵，設定其他IDE的快捷鍵喔</p><p><img src="/img/2017-130734/1509858200_16348.png"></p><p>進入之後看到Keymap，就可以看到很多的Keymap可以做選擇，像我個人是從 Visual Studio 和 Eclipse 轉來的 就可以選擇Eclipse 和 Visual Studio 的 Keymap 來開始寫程式碼喔  </p><p><img src="/img/2017-130734/1509858275_38673.png"></p><p>接下來就用IntelliJ來寫點程式碼吧</p><p>在專案底下的src按下右鍵-&gt;New-&gt;Java Class</p><p><img src="/img/2017-130734/1509857440_38574.png"></p><p>新增後他會要你命名Class的名稱</p><p><img src="/img/2017-130734/1509857461_90091.png"></p><p>命名完成按下OK，就可以開始寫Java的程式了</p><p><img src="/img/2017-130734/1509857493_656.png"></p><p>以下就是印出 Hello IntelliJ的程式碼</p><p><img src="/img/2017-130734/1509857700_76821.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IntelliJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDD練習 Codewars_Which Are In</title>
      <link href="/2017/10/21/2017-143526/"/>
      <url>/2017/10/21/2017-143526/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2017-143526/1508562623_18716.png"></p><p>首先解析這份題目要得需求是甚麼</p><p>輸入兩個字串 a1 和 a2 ，輸出的字串陣列內容為 a2每一個字串陣列元素中包含a1任一個陣列元素的的字串，並且將其排序輸出，不可重複</p><p>聽起來很饒口 就看看他的範例唄</p><p>a1是要比對的字串陣列 [“arp”, “live”, “strong”]</p><p>a2是要被比對的字串陣列 [“lively”, “alive”, “harp”, “sharp”, “armstrong”]</p><p>以”arp”為例，他會比對到 “harp” 和 “sharp” 但是 我的輸出只能輸出一個 “arp” 這樣</p><p>以上的範例可以方便我來拆解這一次的需求</p><ul><li>Contains方法 用來找尋包含的字串元素</li><li>比對在輸出結果有沒有重複的字串 一樣是用 Contains</li><li>最後的排序 OrderBy</li></ul><p>起手就先以a1和a2各1個元素的比對來做測試案例起手，a1的元素是arp，a2的元素是aaa</p><p>程式碼如下 我預期的結果要是空的字串陣列</p><pre><code>[TestMethod]public void Input_arpAnd_aaa_Should_Be_EmptyArray()/&#123;var actual = Kata.inArray(new string[] /&#123;&quot;arp&quot;/&#125;, new string[] /&#123;&quot;aaa&quot;/&#125;);var expected = new string[] /&#123; /&#125;;Assert.AreEqual(expected,actual);/&#125;</code></pre><p>而Production Code 則生成了下面這個樣子</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123; return new string[]/&#123;/&#125;;/&#125;</code></pre><p>很理所當然的 這一個測試案例亮了第一次的<strong>紅燈</strong></p><p>接下來用最簡單的方式讓紅燈變成<strong>綠燈</strong>，直接Return一個空的字串陣列XDDD</p><p>然後把剛才的筆誤Assert.AreEqual更改成 <strong>CollectionAssert.AreEqual</strong> 因為是比較陣列的關係所以要使用 <strong>CollectionAssert.AreEqual</strong></p><p>再來新增一個會發生錯誤且Prodction Code 更改幅度為最小的測試案例，那就是會回傳正確答案的字串了</p><pre><code>[TestMethod]public void Input_arpAnd_aaa_Should_Be_EmptyArray()/&#123;var actual = Kata.inArray(new string[] /&#123;&quot;arp&quot;/&#125;, new string[] /&#123;&quot;arp&quot;/&#125;);var expected = new string[] /&#123;&quot;arp&quot; /&#125;;CollectionAssert.AreEqual(expected,actual);/&#125;</code></pre><p>很正常的，這一個測試案例會亮你紅燈，就將程式碼更改為</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123;List&lt;string&gt; result = new List&lt;string&gt;();foreach (var s in array2)/&#123;  if (s.Equals(array1[0]) ) /&#123;   result.Add(s); /&#125;/&#125;return result.ToArray();/&#125;</code></pre><p>直接宣告一個result字串陣列變數，方便我直接用add的方法就在foreach內新增一個字元，不用去標記index為多少<br>然後只用一個Foreach來完成這一次的需求，並且判斷有沒有包含(<strong>這裡的Equal當初寫錯，是後來才發現寫錯的</strong>)，雖然把包含方法誤寫成Equal但還是通過了測試案例，亮了綠燈</p><p>接下來新增第三個測試案例，一樣是以可能最小步的方式來思考測試案例的方向，第三個測試案例就這樣產生了</p><pre><code>[TestMethod]public void Input_arpAnd_aaa_Should_Be_EmptyArray()/&#123;var actual = Kata.inArray(new string[] /&#123;&quot;ss&quot;, &quot;arp&quot;/&#125;, new string[] /&#123;&quot;arp&quot;/&#125;);var expected = new string[] /&#123;&quot;arp&quot;/&#125;;CollectionAssert.AreEqual(expected,actual);/&#125;</code></pre><p>因為上一個測試案例所更改的 Production Code 只有找第一個 a1 元素來做比對，這一次就故意把他新增成兩個，很理所當然的，這一個測試案例也產生了紅燈的結果</p><p>所以在 Production Code 加上了第二個 Foreach 迴圈，這個迴圈以目前的測資來說 也會是沒有問題的，所以也亮了綠燈</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123; List&lt;string&gt; result = new List&lt;string&gt;(); foreach (var a2 in array2) /&#123;     foreach (var a1 in array1)     /&#123;         if (a2.Equals(a1))         /&#123;             result.Add(a2);         /&#125;     /&#125; /&#125; return result.ToArray();/&#125;</code></pre><p>亮了綠燈之後要檢視程式碼</p><p>這時候就發現不應該使用 Equals 而是要使用Contains 、 result add的不應該是 a2 而要是 a1、上層的迴圈應該要是array1 下層的則是array2</p><p>就把Production Code改成以下的樣子</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123;var result = new List&lt;string&gt;();foreach (var a1 in array1)    foreach (var a2 in array2)        if (a2.Contains(a1))            result.Add(a1); return result.ToArray();/&#125;</code></pre><p>接下來再新增一個測試案例，這個測試案例是為了避免重複的結果，所以測試案例中的a2有多一個包含arp的字串</p><pre><code>[TestMethod]public void Input_ss_arp_And_art_starpoint_garp_Should_Be_arp()/&#123;    var actual = Kata.inArray(new string[] /&#123; &quot;ss&quot;, &quot;arp&quot; /&#125;, new string[] /&#123; &quot;art&quot;, &quot;starpoint&quot;,&quot;garp&quot; /&#125;);    var expected = new string[] /&#123; &quot;arp&quot; /&#125;;    CollectionAssert.AreEqual(expected, actual);/&#125;</code></pre><p>一樣這一個測試案例使我的專案亮了紅燈</p><p>接下來就把Production Code更改成下面這個樣子 讓他再新增元素時除了判斷有無包含之外，還判斷原有的字串陣列中有沒有包含一樣的元素，如此一來就可以把這個測試案例亮成綠燈</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123;var result = new List&lt;string&gt;();foreach (var a1 in array1)    foreach (var a2 in array2)        if (a2.Contains(a1) &amp;&amp; !result.Contains(a1))            result.Add(a1); return result.ToArray();/&#125;</code></pre><p>再來就是最後一個需求，排序的部分，所以新增了一個需要排序才能成功的測試案例，其測試案例如下</p><pre><code>[TestMethod]public void Input_bc_abc_And_bbbc_dsssaabcasd_Should_Be_arp()/&#123;    var actual = Kata.inArray(new string[] /&#123; &quot;bc&quot;,&quot;abc&quot; /&#125;, new string[] /&#123; &quot;bbbc&quot;,&quot;dsssaabcasd&quot;/&#125;);    var expected = new string[] /&#123; &quot;abc&quot;,&quot;bc&quot; /&#125;;    CollectionAssert.AreEqual(expected, actual);/&#125;</code></pre><p>這個測試案例我故意把 a 開頭的比較字串放在 a1 的第二個元素 b開頭擺在第一個，如此一來我的測試案例就會亮紅燈 </p><p>接下來只需要在我返回字串陣列的時候用Linq排序就可以完成這個需求了，也因此亮了綠燈</p><pre><code>public static string[] inArray(string[] array1, string[] array2)/&#123;    var result = new List&lt;string&gt;();    foreach (var a1 in array1)        foreach (var a2 in array2)            if (a2.Contains(a1) &amp;&amp; !result.Contains(a1))                result.Add(a1);    return result.OrderBy(x =&gt; x).ToArray();/&#125;</code></pre><p>這一次的所有測試案例如下</p><pre><code>    [TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_arpAnd_aaa_Should_Be_EmptyArray()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;arp&quot; /&#125;, new string[] /&#123; &quot;aaa&quot; /&#125;);            var expected = new string[] /&#123; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void Input_arpAndarp_Should_Be_arpOfArray()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;arp&quot; /&#125;, new string[] /&#123; &quot;arp&quot; /&#125;);            var expected = new string[] /&#123; &quot;arp&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void Input_ss_arpAndarp_Should_Be_arpOfArray()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;ss&quot;, &quot;arp&quot; /&#125;, new string[] /&#123; &quot;arp&quot; /&#125;);            var expected = new string[] /&#123; &quot;arp&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void Input_ss_arp_And_art_starpoint_Should_Be_arp()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;ss&quot;, &quot;arp&quot; /&#125;, new string[] /&#123; &quot;art&quot;, &quot;starpoint&quot; /&#125;);            var expected = new string[] /&#123; &quot;arp&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void Input_ss_arp_And_art_starpoint_garp_Should_Be_arp()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;ss&quot;, &quot;arp&quot; /&#125;, new string[] /&#123; &quot;art&quot;, &quot;starpoint&quot;,&quot;garp&quot; /&#125;);            var expected = new string[] /&#123; &quot;arp&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void Input_bc_abc_And_bbbc_dsssaabcasd_Should_Be_arp()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;bc&quot;,&quot;abc&quot; /&#125;, new string[] /&#123; &quot;bbbc&quot;,&quot;dsssaabcasd&quot;/&#125;);            var expected = new string[] /&#123; &quot;abc&quot;,&quot;bc&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;        [TestMethod]        public void CodewarsExampleTest()        /&#123;            var actual = Kata.inArray(new string[] /&#123; &quot;arp&quot;, &quot;live&quot;, &quot;strong&quot; /&#125;,                new string[] /&#123; &quot;lively&quot;, &quot;alive&quot;, &quot;harp&quot;, &quot;sharp&quot;, &quot;armstrong&quot; /&#125;);            var expected = new string[] /&#123; &quot;arp&quot;, &quot;live&quot;, &quot;strong&quot; /&#125;;            CollectionAssert.AreEqual(expected, actual);        /&#125;    /&#125;</code></pre><p>接下來就把程式提交，就可以看到美妙的綠燈亮出來啦</p><p><img src="/img/2017-143526/1508567305_49316.png"></p><p>不過最重要的是在提交之後可以看見別人所寫的程式碼，其中有一個人寫的程式碼跟我的邏輯相同但他們以Linq的方式寫出來，也更精簡，如下</p><p><img src="/img/2017-143526/1508567401_42697.png"></p><h2 id="心得"><a href="#心得" class="headerlink" title="心得:"></a>心得:</h2><p>在這次的練習過稱中儘管不小心把Contains方法寫成Equal 也把 加入的字串a1 寫成 a2 還有 迴圈比較也寫反，但也因為後面的測試案例修改以及每一次的重新審視Production Code而及早發現程式碼發生的問題，所以覺得除了自己的測試案例還有進步的空間之外還有自己在寫Code的時候也要更加謹慎才能更有效率地把程式完成。</p><hr><p>91在介紹codewars以及跟我私聊幾句時說了下面這段話</p><blockquote><p>我們需要找到一種持續給自己回饋的方式，才能持續改善<br>所以 scrum 裡面有 iteration (迭代)<br>所以有 retrospective<br>一切都是持續改善的基本要素</p></blockquote><h4 id="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界"><a href="#我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界" class="headerlink" title="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!"></a>我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷開發 -  Agile_Neihu_Sprint 9 - Scrum Drawing Game</title>
      <link href="/2017/10/12/2017-235521/"/>
      <url>/2017/10/12/2017-235521/</url>
      
        <content type="html"><![CDATA[<p>參加社群可以透過討論獲得很多東西</p><p>今天是第一次參加台北的敏捷聚會，上個月各種經濟拮据，所以也沒有Follow到一些活動，這個月總算可以Follow了XD</p><p>這一次的講師是Juggernaut，因為名字不好念的關係所以也有人稱他賈格</p><p><img src="/img/2017-235521/1507822134_74289.png"></p><p>會來參加這個聚會的原因不外乎就是想要再更了解敏捷，以及還有哪些其他的方式能夠詮釋敏捷，今天這項活動Run下來對於敏捷開發這個議題會有更深入的了解，如果是Run過敏捷或是正在Run敏捷的人會有更深的體悟</p><p>這一次我自願擔任PO，因為我沒當過想玩看看XDDD</p><p>活動過程以平常Run Scrum的方式來進行，需求是要畫動物的圖，有一個限制在於PO( Product Owner )不能給Team看到真正需求的圖片，就這樣開始了第一階段，需求就是畫下面這張</p><p><img src="/img/2017-235521/1507822407_3218.png"></p><p>第一階段的 Sprint 完成了，但沒有任何產出，原因是因為需求還不理解跟沒有評估排序任務的優先順序，導致第一階段的 Sprint 沒有完成任何一個項目<br>但在 Review 時 User 發給了我們一些提示，讓我們知道如何將某一個動物畫好</p><p>第二階段的 Sprint 開始了，我們的團隊開始把之前的提示內容補上，也將許多的細節補上，在這一個Sprint開始，整個團隊對於需求有更好的理解，在Sprint開始之後就有更順利的感覺</p><p>第三階段的 Sprint  我們放棄了左下角的性感羚羊，直接對於其他的動物圖像進行修補，讓我們可以得到最有把握能夠獲得的價值</p><p>最終也如我們所願的把剩下能夠獲得價值的動物圖像都畫出來了，產出就像下圖一樣漂亮(笑)</p><p><img src="/img/2017-235521/1507822478_73607.png"></p><p>今天的重點整理:</p><ul><li><h3 id="需求先搞清楚然後整理後再來排序好，如果可以，就詢問User最重要的是什麼，讓團隊可以認知到哪一個項目是最具有價值的"><a href="#需求先搞清楚然後整理後再來排序好，如果可以，就詢問User最重要的是什麼，讓團隊可以認知到哪一個項目是最具有價值的" class="headerlink" title="需求先搞清楚然後整理後再來排序好，如果可以，就詢問User最重要的是什麼，讓團隊可以認知到哪一個項目是最具有價值的"></a>需求先搞清楚然後整理後再來排序好，如果可以，就詢問User最重要的是什麼，讓團隊可以認知到哪一個項目是最具有價值的</h3></li><li><h3 id="Retrospective是一個在Srum中很奇妙的存在，他可以拉近團隊成員的距離，讓整個Team對於專案更有向心性"><a href="#Retrospective是一個在Srum中很奇妙的存在，他可以拉近團隊成員的距離，讓整個Team對於專案更有向心性" class="headerlink" title="Retrospective是一個在Srum中很奇妙的存在，他可以拉近團隊成員的距離，讓整個Team對於專案更有向心性"></a>Retrospective是一個在Srum中很奇妙的存在，他可以拉近團隊成員的距離，讓整個Team對於專案更有向心性</h3></li><li><h3 id="能提早-Deploy-完成的項目，就越能夠讓這個專案獲得更大的價值"><a href="#能提早-Deploy-完成的項目，就越能夠讓這個專案獲得更大的價值" class="headerlink" title="能提早 Deploy 完成的項目，就越能夠讓這個專案獲得更大的價值"></a>能提早 Deploy 完成的項目，就越能夠讓這個專案獲得更大的價值</h3></li><li><h3 id="頻繁的-Review-能夠讓團隊快速的了解目前的專案是否真正符合-User-的需求"><a href="#頻繁的-Review-能夠讓團隊快速的了解目前的專案是否真正符合-User-的需求" class="headerlink" title="頻繁的 Review 能夠讓團隊快速的了解目前的專案是否真正符合 User 的需求"></a>頻繁的 Review 能夠讓團隊快速的了解目前的專案是否真正符合 User 的需求</h3></li></ul><p>這一次參加最大的收穫，除了看到了另一種介紹Srum的方式之外，因為自己從Developer轉入QA心存不少疑問，所以偷偷在離開時問了賈格一些的問題，印象中最深刻的就是</p><h4 id="QA在Scrum-Team裡面，怎樣才算是好的QA，該如何定義"><a href="#QA在Scrum-Team裡面，怎樣才算是好的QA，該如何定義" class="headerlink" title=":QA在Scrum Team裡面，怎樣才算是好的QA，該如何定義?"></a>:QA在Scrum Team裡面，怎樣才算是好的QA，該如何定義?</h4><h4 id="賈格-先把Scrum拿掉，QA-做的事會不一樣嗎"><a href="#賈格-先把Scrum拿掉，QA-做的事會不一樣嗎" class="headerlink" title="賈格: 先把Scrum拿掉，QA 做的事會不一樣嗎?"></a>賈格: 先把Scrum拿掉，QA 做的事會不一樣嗎?</h4><h4 id="摁-不會"><a href="#摁-不會" class="headerlink" title=":摁..不會"></a>:摁..不會</h4><h3 id="賈格-對-很多人會問我這個問題，但我都會反問他們這個問題，QA不會因為待在哪就會有不同的事情要做，好的QA要會的事不外乎就是方法論，自動化等-是很多所謂好的-QA-要去做的"><a href="#賈格-對-很多人會問我這個問題，但我都會反問他們這個問題，QA不會因為待在哪就會有不同的事情要做，好的QA要會的事不外乎就是方法論，自動化等-是很多所謂好的-QA-要去做的" class="headerlink" title="賈格:對 很多人會問我這個問題，但我都會反問他們這個問題，QA不會因為待在哪就會有不同的事情要做，好的QA要會的事不外乎就是方法論，自動化等 是很多所謂好的 QA 要去做的"></a>賈格:對 很多人會問我這個問題，但我都會反問他們這個問題，QA不會因為待在哪就會有不同的事情要做，好的QA要會的事不外乎就是方法論，自動化等 是很多所謂好的 QA 要去做的</h3><p>這個回答和上一次去參加台中敏捷小酒館的答案一樣，只是上一次的討論比這一次隨口聊聊還要深入一點點，有興趣可以到這個傳送門</p><h3 id="敏捷開發-8-30-敏捷小酒館-心得記錄"><a href="#敏捷開發-8-30-敏捷小酒館-心得記錄" class="headerlink" title="敏捷開發 - 8&#x2F;30 敏捷小酒館 心得記錄"></a><a href="https://dotblogs.com.tw/im_sqz777/2017/09/04/142117">敏捷開發 - 8&#x2F;30 敏捷小酒館 心得記錄</a></h3><p>感謝今天Agile in 內湖辦的敏捷聚會，之後有時間都會繼續參加敏捷的聚會</p><h3 id="每一次都會有一點收穫，收穫一點一點地累積起來，內化成自己的，就能夠變成強大的自走砲"><a href="#每一次都會有一點收穫，收穫一點一點地累積起來，內化成自己的，就能夠變成強大的自走砲" class="headerlink" title="每一次都會有一點收穫，收穫一點一點地累積起來，內化成自己的，就能夠變成強大的自走砲"></a>每一次都會有一點收穫，收穫一點一點地累積起來，內化成自己的，就能夠變成強大的自走砲</h3><p><img src="/img/2017-235521/1507822597_20016.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> 社群 </tag>
            
            <tag> 敏捷開發 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - 寫點程式碼讓網頁自己動起來之xPath之外的幾個取得元素位置的方式</title>
      <link href="/2017/09/27/2017-011625/"/>
      <url>/2017/09/27/2017-011625/</url>
      
        <content type="html"><![CDATA[<p>這次要記錄的是除了xPath之外的取得路徑方式</p><ul><li>cssSelector</li><li>Name</li><li>ID</li><li>ClassName</li></ul><p>閱讀本篇前可先參考 <a href="https://dotblogs.com.tw/im_sqz777/2017/09/20/002538">Test - 哦哦哦哦 網站會自己動欸!! 寫點程式碼讓網站自己動起來!!</a> 這篇</p><p>由於在開發時會遇到一些變化，所以就出現了其他的 Laocting 方式</p><p><a href="http://selenium-python.readthedocs.io/locating-elements.html">官方文件</a>內有詳細的說明，裡面也有這次沒有紀錄的FindLikText的方式，有興趣可以到這裡看看</p><h3 id="cssSelector-取得方式"><a href="#cssSelector-取得方式" class="headerlink" title="cssSelector 取得方式"></a>cssSelector 取得方式</h3><p>與xPath取得的方式一樣，只是在選擇時，選擇「Copy selector」</p><p><img src="/img/2017-011625/1506443527_66941.png"></p><p>將cssSelector 複製下來之後，就可以像xPath一樣的運用，以下的程式碼是將上次所有的Code更改為cssSelector的方式</p><p>主要變化的部分就是將「By.xpath」更改成「By.cssSelector」</p><pre><code>///使用cssSelector的方式    public void cssSelectorMethod() throws InterruptedException/&#123;        System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:/selenium/chromedriver.exe&quot;); // 設定chromedriver位置        WebDriver chromeDriver = new ChromeDriver(); // 建立一個WebDriver物件        chromeDriver.manage().window().maximize(); // 開啟的視窗要放大 才比較好讓我們觀看執行的過程        chromeDriver.get(&quot;https://www.google.com/&quot;); // 開啟google首頁        chromeDriver.findElement(By.cssSelector(&quot;#lst-ib&quot;)).sendKeys(&quot;1+1&quot;);        chromeDriver.findElement(By.cssSelector(&quot;#tsf &gt; div.tsf-p &gt; div.jsb &gt; center &gt; input[type=\&quot;submit\&quot;]:nth-child(1)&quot;)).submit();        chromeDriver.findElement(By.cssSelector(&quot;#rso &gt; div:nth-child(2) &gt; div &gt; div:nth-child(1) &gt; div &gt; div &gt; h3 &gt; a&quot;)).click();        Thread.sleep(3000);         chromeDriver.quit();     /&#125;</code></pre><p>這裡值得注意的是</p><p>若複製下來的cssSelector碼有雙引號，要在字串內表示雙引號則需要以斜線+雙引號來表示「 \“ 」。</p><h3 id="Name、ID、ClassName取得方式"><a href="#Name、ID、ClassName取得方式" class="headerlink" title="Name、ID、ClassName取得方式"></a>Name、ID、ClassName取得方式</h3><p>針對google搜尋列按下右鍵&#x3D;&gt;檢查，一樣會看到被選取的元素被反白，如下圖(放大過)。<br>若要取得以上三種標籤，則要觀看網頁該物件有無被賦予「Name」、「ID」、「ClassName」，下圖被紅色框起來的是 className，橘色的是 ID而綠色的則是 name</p><p><img src="/img/2017-011625/1506443848_46596.png"></p><p>如果可以找到以上三種元素程式則分別可以更改為以下幾種方式</p><ul><li>若是 name 則將 原本的「By.xpath」更改成「By.name」</li><li>若是 id 則將 原本的「By.xpath」更改成「By.id」</li><li>若是 name 則將 原本的「By.xpath」更改成「By.className」</li></ul><p>程式碼大多都雷同，所以這三種元素只紀錄較好演示的 name 和 id 方法</p><p>因為最下面要做click動作的元素沒有Name故用cssSelector來做取代</p><pre><code>///使用ID的方式public void FindByIDMethod() throws InterruptedException/&#123;System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:/selenium/chromedriver.exe&quot;); // 設定chromedriver位置WebDriver chromeDriver = new ChromeDriver(); // 建立一個WebDriver物件chromeDriver.manage().window().maximize(); // 開啟的視窗要放大 才比較好讓我們觀看執行的過程chromeDriver.get(&quot;https://www.google.com/&quot;); // 開啟google首頁chromeDriver.findElement(By.id(&quot;lst-ib&quot;)).sendKeys(&quot;1+1&quot;);chromeDriver.findElement(By.id(&quot;tsf&quot;)).submit();chromeDriver.findElement(By.cssSelector(&quot;#rso &gt; div:nth-child(2) &gt; div &gt; div:nth-child(1) &gt; div &gt; div &gt; h3 &gt; a&quot;)).click();Thread.sleep(3000); chromeDriver.quit(); /&#125;    ///使用Name的方式public void FindByNameMethod() throws InterruptedException/&#123;System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:/selenium/chromedriver.exe&quot;); // 設定chromedriver位置WebDriver chromeDriver = new ChromeDriver(); // 建立一個WebDriver物件chromeDriver.manage().window().maximize(); // 開啟的視窗要放大 才比較好讓我們觀看執行的過程chromeDriver.get(&quot;https://www.google.com/&quot;); // 開啟google首頁chromeDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;1+1&quot;);chromeDriver.findElement(By.name(&quot;btnK&quot;)).submit();chromeDriver.findElement(By.cssSelector(&quot;#rso &gt; div:nth-child(2) &gt; div &gt; div:nth-child(1) &gt; div &gt; div &gt; h3 &gt; a&quot;)).click();Thread.sleep(3000); chromeDriver.quit(); /&#125;</code></pre><h3 id="Git-Hub上的程式碼也跟著更新了，有興趣的可以看看"><a href="#Git-Hub上的程式碼也跟著更新了，有興趣的可以看看" class="headerlink" title="Git Hub上的程式碼也跟著更新了，有興趣的可以看看"></a><a href="https://github.com/SQZ777/DemoWebTest.git">Git Hub上的程式碼</a>也跟著更新了，有興趣的可以看看</h3><p>以上是今天的紀錄 若有錯誤或可以寫得更好的地方 請各位大大告知我 感謝 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Java </tag>
            
            <tag> Selenium </tag>
            
            <tag> ChromeDriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test - 哦哦哦哦 網站會自己動欸!! 寫點程式碼讓網站自己動起來!!</title>
      <link href="/2017/09/20/2017-002538/"/>
      <url>/2017/09/20/2017-002538/</url>
      
        <content type="html"><![CDATA[<p>測試之路開始</p><p>這也代表有各種對我來說是新的工具需要紀錄和學習</p><p><strong>這次要記錄的是使用java + Selenium + Chrome Driver 讓網站自己動起來</strong></p><p>開始前的準備</p><ul><li><a href="https://www.eclipse.org/downloads/">Eclipse</a></li><li><a href="https://sites.google.com/a/chromium.org/chromedriver/">Chrome Driver</a></li><li><a href="http://www.seleniumhq.org/download/">Selenium</a></li></ul><p>將 Chrome Driver下載下來之後 記得將其解壓縮至自己知道的位置</p><p>我自己是裝在C槽中自己建立的selenium的資料夾底下</p><p>介紹之前先記錄一下如何把Selenium import到自己的專案底下</p><p>首先在官網下載 Selenium 的檔案 本次紀錄是使用 Java 所以 選擇 Java 的檔案來下載</p><p><img src="/img/2017-002538/1505834733_23335.png"></p><p>下載完成之後就把它解壓縮出來，然後再到自己創建好的Java Project 中 點選你的 Project 右鍵 如下圖</p><p><img src="/img/2017-002538/1505834950_53527.png"></p><p>現階段版本 3.5.3 解壓縮出來後會看到 如下圖的畫面，<strong>你要匯入的是下面client-combined-3.5.3-nodeps-sources.zip , client-combined-3.5.3-nodeps.jar 和 lib資料夾中所有的 .jar 檔</strong></p><p><img src="/img/2017-002538/1505835262_33294.png"></p><p>按下右手邊 Add External JARs 選擇好上面那幾個檔案進行匯入，匯入完成後就會看到這一大堆你匯入進來的檔案，接下來點選 Apply and Close 即可</p><p><img src="/img/2017-002538/1505835349_54329.png"></p><p>接下來終於要開始寫點程式碼啦!</p><pre><code>public static void main(String[] args) throws InterruptedException /&#123;        System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:/selenium/chromedriver.exe&quot;); //設定chromedriver位置        WebDriver chromeDriver = new ChromeDriver();      //建立一個WebDriver物件        chromeDriver.manage().window().maximize();        //開啟的視窗要放大 才比較好讓我們觀看執行的過程        chromeDriver.get(&quot;https://www.google.com/&quot;);      //開啟google首頁        chromeDriver.findElement(By.xpath(&quot;//*[@id=\&quot;lst-ib\&quot;]&quot;)).sendKeys(&quot;1+1&quot;);                     //針對這個xpath輸入1+1        chromeDriver.findElement(By.xpath(&quot;//*[@id=\&quot;tsf\&quot;]/div[2]/div[3]/center/input[1]&quot;)).submit(); //針對這個xpath進行Submit動作        chromeDriver.findElement(By.xpath(&quot;//*[@id=\&quot;rso\&quot;]/div[2]/div/div[1]/div/div/h3/a&quot;)).click(); //針對這個xpath做點選動作        Thread.sleep(3000);  //避免一完成就直接關閉 所以讓他暫時停止3秒        chromeDriver.quit(); //關閉視窗    /&#125;</code></pre><p>System.setProperty(“ 要使用的driver “,” 你放置driver的位置 “);</p><p>chromeDriver.get(“ 你要測試的網站 “);</p><p>chromeDriver.findElement(By.xpath(“ 擷取下來的xpath路徑 “)).你要求做的事();</p><p>.sendKeys() 要求程式幫你在xpath的路徑中自動輸入字串的方法<br>chromeDriver.findElement(By.xpath(“ 擷取下來的xpath路徑 “)).sendKeys(“ 你要輸入的字串 “); </p><p>.submit() 要求程式幫你將xpath這個路徑的物件進行submit的動作<br>chromeDriver.findElement(By.xpath(“ 擷取下來的xpath路徑 “)).submit(); </p><p>.click() 要求程式幫你針對xpath的路徑進行點選的動作<br>chromeDriver.findElement(By.xpath(“ 擷取下來的xpath路徑 “)).click(); </p><p>在這邊要順帶一提的是xPath的取得方法</p><p>xPath的取得方式很簡單</p><p>假如說要找到 google 首頁搜尋列的 xPath 就點他 右鍵 -&gt; 檢查 ， 如下圖</p><p><img src="/img/2017-002538/1505836700_95216.png"></p><p>這時候畫面就會出現網頁的程式碼，你選取的部分將會被反白，接下來點選反白的部分右鍵 -&gt; Copy -&gt; XPath 就可以複製成功了 </p><p><img src="/img/2017-002538/1505836795_74531.png"></p><p>最後就用 gif 來看看 程式執行的過程吧</p><p><img src="/img/2017-002538/1505838254_48858.gif"></p><p>以上是一點點的紀錄，如果有什麼可以補充或是有錯誤的地方歡迎各位大大跟我說 &lt;(_ _)&gt;</p><p>今天紀錄的內容雖然只有一點點 但還是把它放在 Git Hub 上 讓大家可以下載下來使用</p><h3 id="Git-Hub連結在此"><a href="#Git-Hub連結在此" class="headerlink" title="Git Hub連結在此"></a><a href="https://github.com/SQZ777/DemoWebTest.git">Git Hub連結在此</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Java </tag>
            
            <tag> Selenium </tag>
            
            <tag> ChromeDriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDD練習 Codewars_BoiledEggs</title>
      <link href="/2017/09/15/2017-010055/"/>
      <url>/2017/09/15/2017-010055/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2017-010055/1505408626_65513.png"></p><p>這份題目的需求是煮蛋要花多少時間，運算過後將需要的時間輸出。</p><p>Codewars kata題目: <a href="https://www.codewars.com/kata/boiled-eggs/csharp">Boiled Eggs</a> TDD練習。</p><p><a href="https://github.com/SQZ777/Codewars_BoiledEggs/commits/master">我的Git Commit 紀錄</a> </p><p>這篇是第二篇關於TDD練習的文章，TDD練習的紀錄文章真的是不太好寫，這一次的題目感覺起來比較好寫一點就決定寫出來了 www</p><p>之前有預備了十幾道TDD練習的記錄在git上 左思右想 還是覺得 放著給自己看就好了(被揍</p><p>這題會PO出來的原因是，因為自己在做這題的時候發現我自己根本沒搞清楚題目的需求，且又看了codewars上的測試案例誤導了自己<br>不過也好家在前面的這些 Test Case 讓我知道修改過後的Code 是不是會像之前一樣保證正確</p><p>一樣是Codewars的題目，所以這一個題目的需求也十分單純，比上一次還要簡單，這一次的需求是</p><ul><li>蛋的數量要分幾次煮(需求是一次最多可以煮八顆蛋)</li><li>分幾次煮的次數乘以煮一次要花多少的時間(需求是煮一次要花5分鐘)</li></ul><p>首先要說的是蛋要分幾次煮，因為需求輸入限制 int 所以要將輸入轉型 -&gt; ToDouble ，ToDouble之後為了運算求取其次數，所以需要Math.Ceiling</p><p>分幾次煮的次數則是在需求中提到是5分鐘，故將上述算出來的數值成以5即可</p><p>首先先初始化專案，產生第一個測試案例並讓他測試失敗</p><pre><code>[TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_0_Should_Be_0()        /&#123;            //arrange            var input = 0;            var expected = 0;            //act            var actual = Kata.CookingTime(input);            //assert            Assert.AreEqual(expected, actual);        /&#125;    /&#125;</code></pre><p>以下為Production Code，它使得我們的第一個測試亮出了<strong>紅燈</strong></p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            throw new NotImplementedException();        /&#125;    /&#125;</code></pre><p>接著用最簡單的方式去讓他變成<strong>綠燈</strong>，其Production Code 如下</p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            return 0;        /&#125;    /&#125;</code></pre><p>接下來寫出第二個測試案例，此測試案例目的是確保原本的code是否可以符合我們的需求(結果自己需求看錯QAQ)</p><pre><code>public void Input_1_Should_Be_5()/&#123;    //arrange    var input = 1;    var expected = 5;    //act    var actual = Kata.CookingTime(input);    //assert    Assert.AreEqual(expected, actual);/&#125;</code></pre><p>將測試案例完成之後，其Production Code變成這樣(超級簡陋)，這時候其實就已經偏離需求了，因為需求一開始沒看清楚以為是五顆一次…所以變成乘以五，應該要是八顆一次，如果有看對需求就不會這樣做了…</p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            return input * 5;        /&#125;    /&#125;</code></pre><p>不過沒關係，我們先繼續看下去，目前的Test Code 就發現有重複的狀況，所以針對這一部分進行重構，將Code變成以下如此</p><pre><code>[TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_0_Should_Be_0()        /&#123;            cookingTimeResult(0,0);        /&#125;        [TestMethod]        public void Input_1_Should_Be_5()        /&#123;            cookingTimeResult(5,1);        /&#125;        private static void cookingTimeResult(int expected,int input)        /&#123;            //act            var actual = Kata.CookingTime(input);            //assert            Assert.AreEqual(expected, actual);        /&#125;    /&#125;</code></pre><p>看起來舒服多了，對吧?<br><strong>重構完成之後不要忘記記再 run 一次測試確保我們修改的 Code 有沒有出錯</strong></p><p>接下來新增了第三個測試案例，接下來做測試案例都很方便，只需要寫一行就可以了，其測試的資料及 Code 如下</p><pre><code>public void Input_2_Should_Be_5()        /&#123;            cookingTimeResult(5, 2);        /&#125;</code></pre><p>測試之後就會發現理所當然的錯了，所以就開始修改Production Code，因為需求到目前為止都看錯的問題，所以變成是以為需求是最多5顆一次，其Production Code就變成下面這個樣子，run了一遍測試，OK 過了 <strong>綠燈</strong></p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            var result = 0;            var ceilNum = Math.Ceiling(Convert.ToDouble(input) / 5);            result = (int)ceilNum * 5;            return result;        /&#125;    /&#125;</code></pre><p>接下來要重構程式碼，因為上面這串實在是有點長，所以重構後就變成如此。</p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            return (int)Math.Ceiling(Convert.ToDouble(input) / 5) * 5;        /&#125;    /&#125;</code></pre><p>也跟著加上了一些測試案例，而這些案例，都是根據錯誤的需求理解來製造的，所以表面上過了，在提交之後就發生了錯誤QQ，新增的測試案例如下，從輸入11應該要是15就是一個很血淋淋的例子</p><pre><code>[TestMethod]public void Input_5_Should_Be_5()/&#123;    cookingTimeResult(5,5);/&#125;[TestMethod]public void Input_10_Should_Be_10()/&#123;    cookingTimeResult(10,10);/&#125;[TestMethod]public void Input_11_Should_Be_15()/&#123;    cookingTimeResult(15,11);/&#125;</code></pre><p>提交之後終於發現需求理解錯誤，就將程式更改了，其Production Code變成以下如此，並且Run一次測試，卻出現了錯誤，因為剛寫的測試案例本身就是一個錯誤，輸入11應該要是10，所以出現了紅燈</p><pre><code>public class Kata    /&#123;        public static int CookingTime(int input)        /&#123;            return (int)Math.Ceiling(Convert.ToDouble(input) / 8) * 5;        /&#125;    /&#125;</code></pre><p>接著就將那一道測試案例更改成輸入11應該要輸出10，更改完成之後測試就<strong>過了</strong></p><pre><code>public void Input_11_Should_Be_10()/&#123;    cookingTimeResult(10,11);/&#125;</code></pre><p>接著就加入最關鍵的測試案例，輸入8，應該要是5，其Code如下</p><pre><code>public void Input_8_Should_5()/&#123;    cookingTimeResult(5, 8);/&#125;</code></pre><p>測試過了之後就將 Code 提交至 Codewars 上了，最後的 Production Code 和所有測試案例，如下</p><pre><code>[TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_0_Should_Be_0()        /&#123;            cookingTimeResult(0, 0);        /&#125;        [TestMethod]        public void Input_1_Should_Be_5()        /&#123;            cookingTimeResult(5, 1);        /&#125;        [TestMethod]        public void Input_2_Should_Be_5()        /&#123;            cookingTimeResult(5, 2);        /&#125;        [TestMethod]        public void Input_5_Should_Be_5()        /&#123;            cookingTimeResult(5, 5);        /&#125;        [TestMethod]        public void Input_10_Should_Be_10()        /&#123;            cookingTimeResult(10, 10);        /&#125;        [TestMethod]        public void Input_11_Should_Be_10()        /&#123;            cookingTimeResult(10, 11);        /&#125;        [TestMethod]        public void Input_8_Should_5()        /&#123;            cookingTimeResult(5, 8);        /&#125;        private static void cookingTimeResult(int expected, int input)        /&#123;            //act            var actual = Kata.CookingTime(input);            //assert            Assert.AreEqual(expected, actual);        /&#125;    /&#125;    public class Kata    /&#123;        public static int CookingTime(int eggs)        /&#123;            var minutes = 5;            return CookTimes(eggs) * minutes;        /&#125;        public static int CookTimes(int eggs)        /&#123;            var eggsPerPot = 8;            return (int) Math.Ceiling(Convert.ToDouble(eggs) / eggsPerPot);        /&#125;    /&#125;</code></pre><p>原以為自己的Code一樣還是覺得很簡短了，結果有人用了Lamda的方式完成他，也有用更好的方式完成他，他們的方式就如下幾張圖，我又覺得很興奮自己還有很多東西是可以學的了 A____A</p><p>第一個則是剛才說的Lamda方式，第二個是用遞迴的方式完成，第三個是用三元運算式來做<br>這三個看起來都很厲害啊!!! 比我的厲害的感覺 XDDDD</p><p><img src="/img/2017-010055/1505407724_54772.png"></p><p>提交完成之後為了讓Code更好維護和彈性，就將程式碼改成了下面這個樣子</p><pre><code>public class Kata    /&#123;        public static int CookingTime(int eggs)        /&#123;            var minutes = 5;            return CookTimes(eggs) * minutes;        /&#125;        public static int CookTimes(int eggs)        /&#123;            var eggsPerPot = 8;            return (int) Math.Ceiling(Convert.ToDouble(eggs) / eggsPerPot);        /&#125;    /&#125;</code></pre><p>之後如果廚房的鍋子變大了 可以裝更多的蛋，就可以更改CookTimes(煮的次數)方法裡的 eggsPerPot 這個變數，一目了然<br>minutes這個變數也是比較讓人好閱讀一點就不會滿臉問號的覺得5是什麼意思<br>不知道有沒有大大可以提出更好看的方式? 歡迎一起討論 &lt;(_ _)&gt;</p><p>以上是我這一次的TDD練習，這一次的心得就是</p><h2 id="需求真的要看清楚"><a href="#需求真的要看清楚" class="headerlink" title="需求真的要看清楚"></a><strong>需求真的要看清楚</strong></h2><p>不然真的搞到最後好一點就像這個題目一樣，要修改的地方很小，壞的話就真的可能牽扯到各種事項，很有可能要把所有的Code做修改，連測試案例預期的值都會變成是錯誤的</p><p>不過在也因為今天這個情況更讓自己覺得TDD的開發更有意義，因為我在修改Code之後可以用之前撰寫完成的測試案例立即的驗證自己改的是不是對的</p><p>再強調一次，給自己一個教訓QAQ</p><h3 id="需求真的要看清楚-1"><a href="#需求真的要看清楚-1" class="headerlink" title="需求真的要看清楚"></a><strong>需求真的要看清楚</strong></h3><h3 id="需求真的要看清楚-2"><a href="#需求真的要看清楚-2" class="headerlink" title="需求真的要看清楚"></a><strong>需求真的要看清楚</strong></h3><h3 id="需求真的要看清楚-3"><a href="#需求真的要看清楚-3" class="headerlink" title="需求真的要看清楚"></a><strong>需求真的要看清楚</strong></h3><p>不然真的….會很慘 O_O|||</p><h2 id="這裡是本文的commit-history"><a href="#這裡是本文的commit-history" class="headerlink" title="這裡是本文的commit history"></a><a href="https://github.com/SQZ777/Codewars_BoiledEggs/commits/master">這裡是本文的commit history</a></h2><hr><p>91在介紹codewars以及跟我私聊幾句時說了下面這段話</p><blockquote><p>我們需要找到一種持續給自己回饋的方式，才能持續改善<br>所以 scrum 裡面有 iteration (迭代)<br>所以有 retrospective<br>一切都是持續改善的基本要素</p></blockquote><h4 id="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界"><a href="#我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界" class="headerlink" title="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!"></a>我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷開發 -  Agile Taichung Meetup 2017 九月份聚會 User Story 的那些人與那些事 心得記錄</title>
      <link href="/2017/09/04/2017-AgileInTaichung0902/"/>
      <url>/2017/09/04/2017-AgileInTaichung0902/</url>
      
        <content type="html"><![CDATA[<p>參加社群可以透過討論獲得很多東西</p><p><img src="/img/2017-AgileInTaichung0902/1504523330_27327.JPG"></p><p>今天參加這個活動目的是想要更了解敏捷，來的時候遇到了很多之前實習公司的人 XDD<br>從實習結束之後第一次遇到 哈哈哈哈哈哈<br>實習也剛好差不多結束滿一個月了呢 www</p><p>今天這一個活動的主題是 <strong>User Story 的那些人與那些事</strong><br>主要講述的是關於 User Story 的事情，什麼是 User Story ，為什麼要有 User Story ，如何寫，誰寫 等等之類的討論分享</p><p>在講師的**<a href="https://docs.google.com/presentation/d/12COOaq4OzbjloZR4rvIwNP-MnxD7odXrK5nCrDQEJaQ/edit#slide=id.g1daaffd876_0_63">簡報</a>**裡面有定義什麼是 User Story 也就是所謂的 3C</p><ul><li>卡片(Card)－用一張卡片的大小簡述用戶的需求</li><li>交談(Conversation)－重點在於透過 User Story 作為溝通基底，而非直接交棒</li><li>確認(Confirmation)－透過用戶角度來進行驗收，看有沒有達到他們的需求</li></ul><p>今天聽完這個分享就發現自己在實習的半年裡，想起來之前團隊裡的 Story 都是寫成 Spec，雖然這點對於團隊中沒有什麼不好，因為我們的PO 也是懂技術相關的人，且在需求的討論中獲得了這一個 Story 的價值，所以才會說沒有什麼不好。<br>不過我覺得還是得花時間去練習寫好的 User Story 或許會更好，畢竟 User Story 他本身存在的意義依然有他的原因，不然就寫 Spec 就好啦。</p><p>在整個分享過程之後，發現User Story 其本身存在的意義是為了讓大家都看得懂，他是一個溝通的媒介，也可以透過他來用客戶的角度來驗收。</p><p>講者有提到的Spec 和 Story 之間的差異的一個例子，如下</p><blockquote><ul><li><em><strong>Spec &#x3D;&gt; 身為一個求職者，我想在搜尋篩選器多一個學歷的選項，以至於我可以篩選出符合我學歷的工作。</strong></em></li><li><em><strong>Story &#x3D;&gt; 身為一個求職者，我想要找到符合我學歷的工作，以至於我可以縮小合適的職缺範圍。</strong></em></li></ul></blockquote><p>中間有一個人提出發問「不寫成 Spec 的其中一個原因是否是因為寫成 Spec 可能會限制開發者的彈性」<br>還有另一個人做出提問「在團隊跟業務之間如果對於需求非常的明確，是不是寫成 Spec 會比較好? 因為這樣就不用再花時間去理解Story所要描述的需求」<br>這兩個問題我個人覺得，其實要去追求 User Story 他本身存在的意義，如果知道他本身存在的意義，以及定義如何，那這兩個問題就可以很簡單的解決了<br>(如果有大大覺得不是這樣的話可以討論一下XDD 因為我也不知道我這個想法是不是對的</p><p>最後要提到的是簡報裡說的 很難撰寫「好的User Story 」的原因，總共六大項，總稱為INVEST，這六大項反過來想也可以翻解成，怎麼定義這是一個好的 User Story</p><ul><li><h4 id="Independent－非開發團隊的人很難理解需求是否獨立"><a href="#Independent－非開發團隊的人很難理解需求是否獨立" class="headerlink" title="Independent－非開發團隊的人很難理解需求是否獨立"></a>Independent－非開發團隊的人很難理解需求是否獨立</h4></li><li><h4 id="Negotialble－撰寫時容易落入Spec-細節，不易進行討論"><a href="#Negotialble－撰寫時容易落入Spec-細節，不易進行討論" class="headerlink" title="Negotialble－撰寫時容易落入Spec 細節，不易進行討論"></a>Negotialble－撰寫時容易落入Spec 細節，不易進行討論</h4></li><li><h4 id="Valuable－通常是假設性的，因此不確定此價值是否存在"><a href="#Valuable－通常是假設性的，因此不確定此價值是否存在" class="headerlink" title="Valuable－通常是假設性的，因此不確定此價值是否存在"></a>Valuable－通常是假設性的，因此不確定此價值是否存在</h4></li><li><h4 id="Estimable－非開發團隊很難理解何謂「可估計」的大小"><a href="#Estimable－非開發團隊很難理解何謂「可估計」的大小" class="headerlink" title="Estimable－非開發團隊很難理解何謂「可估計」的大小"></a>Estimable－非開發團隊很難理解何謂「可估計」的大小</h4></li><li><h4 id="Small－非開發團隊很難確認此需求是否「小」"><a href="#Small－非開發團隊很難確認此需求是否「小」" class="headerlink" title="Small－非開發團隊很難確認此需求是否「小」"></a>Small－非開發團隊很難確認此需求是否「小」</h4></li><li><h4 id="Testable－非開發團隊很難理解何謂「可測試」"><a href="#Testable－非開發團隊很難理解何謂「可測試」" class="headerlink" title="Testable－非開發團隊很難理解何謂「可測試」"></a>Testable－非開發團隊很難理解何謂「可測試」</h4></li></ul><p>以下是我的理解</p><ul><li>Independent，一個好的 User Story 會是一個獨立的需求</li><li>Negotialble，一個好的 User Story 會是容易進行討論的</li><li>Valuable，一個好的 User Story 會是可以知道他的價值的</li><li>Estimable，一個好的 User Story 會是好估計的</li><li>Small，一個好的 User Story 是適度的「小」的</li><li>Testable，一個好的 User Story 是一個可以被測試的需求</li></ul><p>最後Q&amp;A的部分我詢問講師一個問題「如果是傳統公司，適不適用 User Story?」<br>他回我說 「不適合，因為一般的傳統公司還是習慣寫成 Spec ，寫成 Spec 就會比較難以看出這一個需求的價值」<br>這個問答中我得到了 User Story 其實不只是要描述客戶的需求和溝通的媒介而已，重要的是它可以讓大家知道這一個需求的價值在哪裡，不是單純的「需求」而是「價值」</p><p>經過今天的整個活動的過程，自己對於 User Story 有更大的認識，至少不會像以前一樣，只知道要把需求寫出來，卻不知道其存在的意義到底是如何<br>不過要把 User Story 就需要花很多的時間來去把他撰寫出來，並且要透過許多的練習，才能寫出一個被定義為「好的 User Story」</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> 社群 </tag>
            
            <tag> 敏捷開發 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript 學習筆記 - [Variable Object] JavaScript的運作原理 Part 2</title>
      <link href="/2017/09/02/2017-004219/"/>
      <url>/2017/09/02/2017-004219/</url>
      
        <content type="html"><![CDATA[<p>要學好任何東西，不能只把它寫出來就好</p><p>學習來源: 「udemy課程-普通話-深入淺出了解Javascript」</p><h2 id="Function的創建及執行階段"><a href="#Function的創建及執行階段" class="headerlink" title="Function的創建及執行階段"></a>Function的創建及執行階段</h2><p>這一部分要講的是 Function 創造 Execution  Context 之後 javaScript 中在 function 裡的執行情況</p><p>首先 javaScript 在創立完這個Function的Execution context 之後 會有兩個大步驟 第一步是 「創建」 第二步是 「執行」</p><h4 id="1-創建"><a href="#1-創建" class="headerlink" title="1.創建"></a>1.創建</h4><h6 id="在第一個步驟中-創建時，首先要做的是-初始化空間-而這個空間稱之為-Scope-chain"><a href="#在第一個步驟中-創建時，首先要做的是-初始化空間-而這個空間稱之為-Scope-chain" class="headerlink" title="在第一個步驟中 創建時，首先要做的是 初始化空間 而這個空間稱之為 Scope chain"></a>在第一個步驟中 創建時，首先要做的是 初始化空間 而這個空間稱之為 Scope chain</h6><p>初始化空間之後 會創建 Variable Object (VO) 也就是變數的對象 而創建 VO 的時候會有三種 變數對象</p><p>第一種在 function 裡的參數 也就是 所謂的 argments object<br>第二種則是 掃描 function 裡的 function 然後會為他們創建他們對應的 VO 如果找到的話則會將它做為一個指標 Pointer ，因為這個function可能會在其他不同的地方，所以需要這個指標來知道這一個function位於何處。<br>第三種則是掃描 variable 而一開始則會設定成 undefined </p><h6 id="在上面的那些VO創建完成之後-則會創建一個叫做-this-的-variable"><a href="#在上面的那些VO創建完成之後-則會創建一個叫做-this-的-variable" class="headerlink" title="在上面的那些VO創建完成之後 則會創建一個叫做 this 的 variable"></a>在上面的那些VO創建完成之後 則會創建一個叫做 this 的 variable</h6><p>以程式碼來做示範創建階段的部分</p><pre><code>function foo(i) /&#123;  var a = &#39;Hi&#39;;  var b = function demo()/&#123;  /&#125;;  function c()/&#123;  /&#125;/&#125;foo(10);</code></pre><p>以上程式碼，在創建階段時，在創建一個 fooExecutionContext 後會先做一個初始化空間，稱之為Scope chain</p><p>之再創造一個 variableObject ，再來就是先掃描 function 中的參數 (arguments object)，這一個arguments會被創建在VO裡面 ，在這裡也就是以上程式碼中的「i」變數，而他第0個值就是10，他只有一個數所以length是1</p><p>再來掃描 function 中的 function ， 建立function之後就會讓指標指向 c 這個 function</p><p>掃描function完成之後就會從頭開始掃描變數 也就先掃描到 a 然後再掃描到 b，這兩個變數在進入執行階段之前都會被設成「undefined」</p><p><img src="/img/2017-004219/1504929281_0641.gif"></p><h4 id="2-執行"><a href="#2-執行" class="headerlink" title="2.執行"></a>2.執行</h4><h6 id="在執行階段就會將之前所創造過的變數放進variable-object中進行逐行的執行。"><a href="#在執行階段就會將之前所創造過的變數放進variable-object中進行逐行的執行。" class="headerlink" title="在執行階段就會將之前所創造過的變數放進variable object中進行逐行的執行。"></a>在執行階段就會將之前所創造過的變數放進variable object中進行逐行的執行。</h6><p>執行的過程中就會將創建階段變數為undefined的值賦予我們要賦予給他的值</p><p>以上面創建過程的程式碼為例，就是 a 將會在執行階段變更為 ‘Hello’</p><p>而 b 這個變數就會將它的指標指向demo() 的這個方法中</p><p><img src="/img/2017-004219/1505050156_31801.gif"></p><p>以上是javaScript的創建及執行階段會發生的事，感謝各位大大收看 若有錯誤 麻煩糾正~ &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript 學習筆記 - [Execution Stack] JavaScript的運作原理 Part 1</title>
      <link href="/2017/08/31/2017-004533/"/>
      <url>/2017/08/31/2017-004533/</url>
      
        <content type="html"><![CDATA[<p>要學好任何東西，不能只把它寫出來就好</p><p>學習來源: 「udemy課程-普通話-深入淺出了解Javascript」</p><p>因為js是自己在做中學習得的一個語言，老實說學起來相當的不踏實，所以剛好最近udemy有特價300$就可以買到一堂不錯的js課程就趁這個機會好好把js的基礎打穩一點 哈哈哈哈哈哈哈<br>PS:這不是業配 ˊ_&gt;ˋ</p><p>老樣子  如果文章內容有錯的話  歡迎各位大大糾正 :D</p><p>這一系列的紀錄將會使用一點簡單的Code來解釋 JS的運作原理(流程?)</p><p>會記錄以下幾點</p><ul><li>javaScript 運作原理(流程?)</li><li>Execution Stack</li><li>function的創建及執行階段</li><li>Hosting</li><li>Scope &amp; ScopeChain</li><li>this</li></ul><h2 id="javaScript-運作原理-流程"><a href="#javaScript-運作原理-流程" class="headerlink" title="javaScript 運作原理(流程?)"></a>javaScript 運作原理(流程?)</h2><p>javaScript的運作流程如下</p><p>每一個瀏覽器都會有一個所謂的 JavaScript引擎 而引擎底下也就會有所謂的 <a href="https://zh.wikipedia.org/wiki/%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">語法分析器</a>(也稱作剖析器 不知道大家是怎麼稱呼他) 它可以幫助我們轉換成010101之類的碼 最後才會執行我們的JS程式<br>換做成流程就會如下</p><p>javaScript引擎 -&gt; Parser -&gt; 轉換成010101之類的碼 -&gt; 執行 JS 程式</p><p>以上流程是執行js程式會發生的事情</p><h2 id="Execution-Stack"><a href="#Execution-Stack" class="headerlink" title="Execution Stack"></a>Execution Stack</h2><p>在講解之前，先寫一段簡單的Code，如下</p><p><img src="/img/2017-004533/1504248644_81748.png"></p><p>其執行結果為此</p><p><img src="/img/2017-004533/1504248636_97765.png"></p><p>那如果將原本的Code改成以下情況結果會是如何呢?</p><p><img src="/img/2017-004533/1504248722_22116.png"></p><p>結果會呈現以下狀況，剛好與原本的結果相反</p><p><img src="/img/2017-004533/1504248760_69387.png"></p><p>一般的說法會說是「因為程式是由上往下執行的」，但實際在記憶體中他會如何運行呢?<br>首先，在javaScript中，執行整段程式時，會進入一個叫做Execution stack (中文翻譯做「執行堆疊」)裡面。<br>在這段程式碼執行後的Execution stack中首先會看到的就是在程式碼中宣告的一個Global變數 「name」，稱之為Global execution context。<br>這一個 Global execution context 將會放在 Execution stack 中的最下面</p><p>再來就是Function被創建時，就會被創造一個叫做 Execution  Context 的一個任務，而執行 Function 時就會將該Function的 Execution Context 放在Execution stack的最上方<br>也就是最後執行 Function 的 Execution Context 就會被放在 Execution stack 的最上面，聽起來很饒口對吧?<br>我們用圖片來看這支程式在執行之後，Execution  stack到底會變成什麼樣子。</p><p><img src="/img/2017-004533/1504251513_42392.png"><br>而 javaScript 就會將 Execution  stack 最上方的程式先做執行，也就會先印出Yo DZ，在最上方的Execution Context執行完成之後，就會將這一個Execution Context抽離，再往下執行Hey這個Function的 Execution Context的任務<br>接下來就是以此類推，其執行時的 Execution  stack 內的情況就會像下面這張圖一樣。</p><p><img src="/img/2017-004533/1504247560_27495.gif"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 - Conditional 和 Obsolete 的 Attribute 特性的簡介與用法</title>
      <link href="/2017/08/23/2017-004831/"/>
      <url>/2017/08/23/2017-004831/</url>
      
        <content type="html"><![CDATA[<p>記錄一下 Attribute 的學習紀錄</p><p>啊啊 記錄一下Attribute的基本用法，Attribute英文直接翻譯是「屬性」但是「屬性」這個名詞已經有Property佔用了，為了避免混淆，所以個人將Attribute翻譯為「特性」，而 Property 在這篇則翻譯為「屬性」</p><p>目前我的Attribute文章會寫兩到三篇左右，本篇只會記錄基本的用法跟自己常用的用法，第二篇則是會記錄該如何自定義Attribute，第三篇則是會記錄簡單的反射用法(這篇可能會融進第二篇)</p><p>這篇要記錄的有以下4點</p><ul><li>Attribute 和 Property 意義跟實際上的差別</li><li>Conditional</li><li>多個識別項</li><li>Obsolete</li></ul><h2 id="Attribute-和-Property-意義跟實際上的差別"><a href="#Attribute-和-Property-意義跟實際上的差別" class="headerlink" title="Attribute 和 Property 意義跟實際上的差別"></a>Attribute 和 Property 意義跟實際上的差別</h2><p>Attribute 和 Property 是完全不同的東西，但英文的直接翻譯上都會被稱之為「屬性」，之前也有看到別人把Attribute翻作「特徵向」，但我還是比較偏好「特性」的這個翻譯。</p><p>在意義上的可以在MSDN上看見兩者不同的定義</p><p><a href="https://msdn.microsoft.com/zh-tw/library/aa288059(v=vs.71).aspx">Attribute的官方定義</a>是</p><blockquote><p><em>C# 提供了一個定義宣告式標記 (Tag) 的機制，此宣告標記稱為屬性 (Attribute)，可以讓您在原始程式碼中放置一些實體，來指定額外的資訊。屬性所包含的資訊可以在 Run Time 時透過<a href="https://msdn.microsoft.com/zh-tw/library/aa719979(v=vs.71).aspx">反映</a>來擷取。您可以使用<a href="https://msdn.microsoft.com/zh-tw/library/aa287992(v=vs.71).aspx">預先定義屬性 (Attribute)</a>或者您可以定義自己的自訂屬性。</em></p></blockquote><p>簡單來說，Attribute是一個讓我們的程式可以新增「附加聲名」訊息的一個機制</p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/properties">Property的官方定義</a>是</p><blockquote><p>屬性是提供彈性機制以讀取、寫入或計算私用欄位值的成員。 使用屬性時可將其視為公用資料成員，但實際上屬性是名為「存取子」的特殊方法。 如此可讓資料更容易存取，同時有助於提升方法的安全性和彈性。</p></blockquote><p>簡單來說Property是類型(class)、結構(structure)、介面(interface)跟命名的成員，他使用存取子(accessor)讓變數的值可被讀寫</p><p>從以上兩個定義就可以發現他們兩個在翻譯上是相同的，但實際上是完全不同的東西</p><h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a><a href="https://msdn.microsoft.com/zh-tw/library/4xssyw96(v=vs.90).aspx">Conditional</a></h2><p>這一部分要記錄的是 Attribute 的 Conditional </p><p>Conditional 的翻譯是「條件」也就是說執行他的條件是什麼狀態，一般在開發時會有兩種執行模式一種是用於平時開發偵錯測試時的「DEBUG」模式另一種則是發布時用的「RELEASE」模式，在圖中可以看見執行更改模式的地方</p><p><img src="/img/2017-004831/1503478090_31298.png"></p><p>現在用簡單的Code來作為展示與說明Attribute</p><pre><code>using System;using System.Diagnostics;namespace Attribute_練習/&#123;    class Program    /&#123;        static void Main(string[] args)        /&#123;            MyClass.ShowMessage(&quot;In Main&quot;);            Method1();            Console.Read();        /&#125;                static void Method1()        /&#123;           MyClass.ShowMessage(&quot;Method1&quot;);        /&#125;    /&#125;    public class MyClass    /&#123;        [Conditional(&quot;DEBUG&quot;)]        public static void ShowMessage(string msg)        /&#123;            Console.WriteLine(msg);        /&#125;    /&#125;/&#125;</code></pre><p>以上的Code顯而易見的是我建立了另一個Class而裡面有一個ShowMessage的Method，在這一個Method的上面可以看見我加入了一個Conditional，而這個Conditional我設定在Debug模式下才能夠使用，所以如果我現在用Debug模式執行程式Console則會出現以下的畫面</p><p><img src="/img/2017-004831/1503478373_06786.png"></p><p>如果將 Debug 模式設成 Release 則會發現執行的結果是什麼事情都不會發生。</p><p>PS:若想要在 Release 模式下執行條件為 DEBUG 的方法，也可以使用<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define">前置處理器指示詞 #define</a> 來定義出 DEBUG 就可以在 release 下執行 Conditional 為 debug 的 Method </p><h2 id="多個識別項"><a href="#多個識別項" class="headerlink" title="多個識別項"></a>多個識別項</h2><p>我們也可以讓一個方法擁有多個 Conditional 屬性，擁有多個 Conditional 屬性就會有兩種邏輯，一種是 AND 、一種則是 OR </p><p>首先先來說說 OR 的邏輯，OR 的邏輯表示方法的 Code 如下</p><pre><code>public class MyClass/&#123;    [Conditional(&quot;DEBUG&quot;), Conditional(&quot;B&quot;)]    public static void ShowMessage(string msg)    /&#123;        Console.WriteLine(msg);    /&#125;/&#125;</code></pre><p>以上程式碼的意思是在 DEBUG 模式「或」有 #define B 則會執行</p><p>再來要說的是 AND 邏輯，AND 邏輯的表示方法的 Code 如下</p><pre><code>public class MyClass/&#123;    [Conditional(&quot;DEBUG&quot;)]    public static void ShowMessage(string msg)    /&#123;        ShowMessage2();    /&#125;    [Conditional(&quot;B&quot;)]    public static void ShowMessage2()    /&#123;        Console.WriteLine(&quot;Message2&quot;);    /&#125;/&#125;</code></pre><p>以上的程式碼就是在 DEBUG 模式「及」有 #define B 才會執行</p><h2 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a><a href="https://msdn.microsoft.com/zh-tw/library/22kk2b44(v=vs.90).aspx">Obsolete</a></h2><p>Obsolete 的官方定義如下</p><blockquote><p><em>Obsolete 屬性 (Attribute) 會標記不再建議使用的程式實體 (Entity)。每次使用標記為過時的實體時，會視設定此屬性的方法，產生警告或是錯誤。</em></p></blockquote><p>假設今天我們有一段程式代碼，在今過一段時間的開發後，這一段程式代碼已經過時了，不再使用，或是不建議使用時，就可以利用Obsolete這一個Attribute來做標記，其使用方法如下</p><pre><code>public class MyClass/&#123;    [Obsolete(&quot;Don&#39;t use Old Method!&quot;)]    public static void ShowMessage(string msg)    /&#123;        Console.WriteLine(msg);    /&#125;/&#125;</code></pre><p>如果我們使用到了這一個被標記為Obsolete的方法時，系統則會跳出警告，並顯示出我們所寫的提示「Dont’ use Old Method!」，其系統顯示時的畫面如下</p><p><img src="/img/2017-004831/1503488182_1552.png"></p><p>如果今天要讓我們在編譯時直接出錯則在Obsolete帶入一個布林參數 true就 會出現error 其使用方法如下</p><pre><code>public class MyClass/&#123;    [Obsolete(&quot;Don&#39;t use Old Method!&quot;,true)]    public static void ShowMessage(string msg)    /&#123;        Console.WriteLine(msg);    /&#125;/&#125;</code></pre><p>在使用這一個方法的程式碼就會出現錯誤，系統下方也會出現錯誤的提示，其畫面如下</p><p><img src="/img/2017-004831/1503488163_53149.png"></p><p>以上都是基本的Attribute用法，之後會再寫一個該如何自定義Attribute</p><p>Attribute十分的常見，在開發的時候也時常用到像是在ASP.NET 中 會用到 HttpPost 或是 ActionFilter 的 Attribute ，之後有時間再把自己常用的這兩個一起整理出來，避免之後沒有用到又忘記www</p><p>感謝各位的收看 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Attribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 - 黑人問號，喔不 我是說 「?」啦</title>
      <link href="/2017/08/17/2017-222734/"/>
      <url>/2017/08/17/2017-222734/</url>
      
        <content type="html"><![CDATA[<p>C#各種問號使用方式</p><p>啊呀…一個出國之後就沒寫文章了</p><p>離上一次寫文章過了兩個禮拜了 今天繼續開始寫啦!!!</p><p>今天在抓Bug的時候多發現了一個?的使用方式<br>在講今天發現的東西之前，先記錄一下?可以使用的哪些方式</p><p>在C#中常常看到? 而且蠻常被忘記的 所以就乾脆紀錄一下!</p><p>主要有以下幾種常見使用方式</p><ul><li><h3 id="a-10-“是十”-“不是十”"><a href="#a-10-“是十”-“不是十”" class="headerlink" title="a&#x3D;&#x3D;10 ? “是十” : “不是十”;"></a>a&#x3D;&#x3D;10 ? “是十” : “不是十”;</h3></li><li><h3 id="int-a"><a href="#int-a" class="headerlink" title="int? a;"></a>int? a;</h3></li><li><h3 id="a-0"><a href="#a-0" class="headerlink" title="a??0"></a>a??0</h3></li></ul><h2 id="第一種方式為三元運算式"><a href="#第一種方式為三元運算式" class="headerlink" title="第一種方式為三元運算式"></a>第一種方式為<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/conditional-operator">三元運算式</a></h2><p>原本使用If的寫法則如以下程式碼</p><pre><code>int a = 10;if (a == 10)/&#123;    Console.WriteLine(&quot;是十&quot;);/&#125;else/&#123;    Console.WriteLine(&quot;不是十&quot;);/&#125;Console.Read();</code></pre><p>以上程式碼可使用三元運算式來表示 </p><h3 id="格式為-「判斷式」-「判斷為true回傳的值」-「判斷為false回傳的值」"><a href="#格式為-「判斷式」-「判斷為true回傳的值」-「判斷為false回傳的值」" class="headerlink" title="格式為 「判斷式」 ? 「判斷為true回傳的值」:「判斷為false回傳的值」"></a>格式為 「判斷式」 ? 「判斷為true回傳的值」:「判斷為false回傳的值」</h3><pre><code>int a = 10;Console.WriteLine(a == 10 ? &quot;是十&quot; : &quot;不是十&quot;);Console.Read();</code></pre><p>以上程式將會回傳的是「是十」</p><h2 id="第二種是將該變數設成可以Null的類型"><a href="#第二種是將該變數設成可以Null的類型" class="headerlink" title="第二種是將該變數設成可以Null的類型"></a>第二種是將該變數<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/nullable-types/using-nullable-types">設成可以Null的類型</a></h2><p>以一般的程式碼若要將整數int變數設定成null編譯器會直接翻臉給你看，如下圖</p><p><img src="/img/2017-222734/1502977769_17725.png"></p><p>若要使其設定為Null則需要將int後面加入「?」即可，編譯器就會息怒喔~</p><p><img src="/img/2017-222734/1502977829_63414.png"></p><h2 id="第三種則是雙問號"><a href="#第三種則是雙問號" class="headerlink" title="第三種則是雙問號"></a>第三種則是<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/null-conditional-operator">雙問號</a></h2><p>雙問號左邊的變數為可null才能將變數放在雙問號旁邊喔，否則編譯器一樣會翻臉，如下圖</p><p><img src="/img/2017-222734/1502978103_66783.png"></p><p>上圖中可以看見我宣告了b的字串變數，他可以使用，因為字串變數是可null的值<br>那要如何將a變數放至雙問號左邊呢? 這時候就會用到第二種使用問號的方式來宣告a變數了，如下圖</p><p><img src="/img/2017-222734/1502978223_01439.png"></p><p>以上程式碼將會回傳字串100以及整數100，??是判斷其左邊的變數是否為Null 若為Null則回傳右邊的值</p><h3 id="「變數」-「左邊的變數為Null的話回傳這個值」"><a href="#「變數」-「左邊的變數為Null的話回傳這個值」" class="headerlink" title="「變數」??「左邊的變數為Null的話回傳這個值」"></a>「變數」??「左邊的變數為Null的話回傳這個值」</h3><h2 id="最後一個要說的是今天發現的一個方式"><a href="#最後一個要說的是今天發現的一個方式" class="headerlink" title="最後一個要說的是今天發現的一個方式"></a>最後一個要說的是今天發現的一個方式</h2><h3 id="這個方式稱之為Null-條件運算子"><a href="#這個方式稱之為Null-條件運算子" class="headerlink" title="*這個方式稱之為Null 條件運算子"></a>*這個方式稱之為<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/null-conditional-operators">Null 條件運算子</a></h3><p>官方文件中有詳細介紹，感謝FB上的大大跟我說，十分感謝!!!</p><p>以Thread來做示範，若今天想要將將一個已存在的Thread做Abort之前我會這樣做</p><pre><code>var a = new Thread(Show);a.Start();if (a != null) a.Abort();</code></pre><p>上述的程式碼會發現我要用一個if判斷是否為空，如果不是空的我就將執行序Abort掉，而今天發現可以用一行就結束了，就是使用問號來判斷是否為空，可以將If判斷式改為以下程式碼</p><pre><code>var a = new Thread(Show);a.Start();a?.Abort();</code></pre><p>不知道這個方法大家有沒有用過，這種簡潔的方式介紹給大家，兩者方式都很簡短，但不知道效能會不會有差，歡迎大大指點 : )</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 - 來試試 .Count 方法吧!</title>
      <link href="/2017/08/01/2017-233020/"/>
      <url>/2017/08/01/2017-233020/</url>
      
        <content type="html"><![CDATA[<p>方便的 Count 方法</p><p>最近開始在Codewars上用TDD的方式去把題目寫出來</p><p>然後每一次寫完都會有發現很多人對C#許多的用法十分的熟悉，每次自己寫完認定已經是最完美的Code時總是會有人寫得比你更好，最好頂多就是寫得一樣或差不多。</p><p>很常會有別人的Code更明瞭、簡潔或是效能更好的時候，所以我每一次寫完都很期待會看到什麼樣的Code，進而去學習他們的寫法</p><p>而這一次要說的的是Count方法</p><p>這一個方法可以省去我們自己去刻一個For迴圈去做計算的動作如下</p><pre><code>var count = 0;for (int i = 0; i &lt; x.Length; i++) /&#123;  count++; /&#125;//Output:10</code></pre><p>總共需要花四行才能夠完成這一個計算的功能，若使用Count方法只需要</p><pre><code>var x = new[] /&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /&#125;;var count = x.Count(); //Output:10</code></pre><p>更精簡則可以變成</p><pre><code>var x = new[] /&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /&#125;.Count(); //Output:10</code></pre><h4 id="有時候過於精簡的程式碼可能會造成程式可讀性的問題，所以撰寫的風格就自行取捨拉"><a href="#有時候過於精簡的程式碼可能會造成程式可讀性的問題，所以撰寫的風格就自行取捨拉" class="headerlink" title="有時候過於精簡的程式碼可能會造成程式可讀性的問題，所以撰寫的風格就自行取捨拉!"></a>有時候過於精簡的程式碼可能會造成程式可讀性的問題，所以撰寫的風格就自行取捨拉!</h4><p>Count方法方便的是它也可以加Lambda進去進行判別如下，以下程式碼是計算出x陣列中偶數有幾個。<br>Note: 對 Lambda有興趣的朋友可以到我寫的<a href="https://dotblogs.com.tw/im_sqz777/2017/07/23/225131"><strong>這篇文章</strong></a>去看看~</p><pre><code>var x = new[] /&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /&#125;;var count = x.Count(i =&gt; i % 2 == 0); //Output:5</code></pre><p>這個方法在寫很多kata題目時很容易用到，因為在眾多題目裡其實蠻多需要去計算這一個陣列裡面有哪些元素是符合條件的，所以這一個方法我覺得需要讓我記錄一下 :D</p><h3 id="補充筆記-感謝FB上的大大提問和補充"><a href="#補充筆記-感謝FB上的大大提問和補充" class="headerlink" title="補充筆記(感謝FB上的大大提問和補充):"></a>補充筆記(感謝FB上的大大提問和補充):</h3><p>*主要用Count方法是因為可以直接使用lambda去做篩選<br>如果單純取得陣列元素大小時在效能上使用Length會比Count還要來得好</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>來溜本書唄-成為卓越程式設計師的38項必修法則</title>
      <link href="/2017/07/30/2017-013107/"/>
      <url>/2017/07/30/2017-013107/</url>
      
        <content type="html"><![CDATA[<p>工程師必讀之心法書!? 給<strong>想要</strong>成為一位更棒程式員的你!!</p><p><img src="/img/2017-013107/1501347694_70236.jpg"></p><p>安安 大家豪 這一篇又是一篇新的系列文 ˊ_&gt;ˋ</p><p>這系列的文章基本上都是讀書心得或是推薦大家要去看的書啦XDD</p><h2 id="想要看書的詳細資訊可以直接到最底下哦"><a href="#想要看書的詳細資訊可以直接到最底下哦" class="headerlink" title="想要看書的詳細資訊可以直接到最底下哦~"></a>想要看書的詳細資訊可以直接到最底下哦~</h2><p>工程師基本上除了看Document也需要看很多「抽象的」敏捷文化相關或是某些法則的書對於工程師來說也會有很大的幫助</p><p>常常在開發時技術上遇到的困難，你通常不會遇到只有你遇到別人不會遇到的情況，當然在實際開發上遇見的非技術困難也很常不是只有你自己一個遇到</p><ul><li>客戶各種神奇的需求</li><li>這前人所寫的Code怎麼這麼難讀</li><li>我該如何把這個Code改得更好</li><li>這個Code需要重構，但不知道改了會不會壞掉? 所以我可能需要寫測試</li><li>這個部分需要寫測試..但這部分寫得太爛所以需要重構</li><li>…</li></ul><p>巴拉巴拉巴啦…<br>一大堆你所遇見過的事，在一般的情況下別人也會遇見，這本書會用很多種有趣的解釋方式讓你理解很多情況。</p><p>這本書通常都會舉一些例子，而這些例子很容易可以被敘述在程式開發過程中所發生的事。</p><p>這一段很像是我們在開發時期的初期，我們一心一意的想要快速的完成需求，卻沒注意到一些問題，導致不小心噴出了Bug<br>不過沒關係，這情況如下面節錄自文章的內容，第八章 (68頁)。</p><blockquote><p><em>有天晚上，我走在街頭，準備到酒吧與朋友會面。我們已經有段時間沒有一起暢飲啤酒了，所以我很期待再次與他見面。<br>匆忙之間，我沒有注意我走到哪裏了。我絆倒了。好吧，誰叫我自己沒有留意，我想。</em></p></blockquote><p>我們很快速的修復了Bug，然後繼續完成下面的需求，但這時已經發現先前修改好的Bug其實是有問題的。<br>這情況如下面節錄自文章的內容，第八章 (68頁)。</p><blockquote><p><em>我的腿受傷了，但我很想快點跟朋友見面。於是我站起來，繼續趕路。我越走越痛。<br>雖然一開始我以為這只是一場虛驚，但很快地，我就發現不對勁了。</em></p></blockquote><p>最後我們完成了所有需求，我們完成的所有程式碼，都非常難讀，也十分難維護，可讀性也很差。我們如果繼續開發，會非常痛苦。<br>這情況如下面節錄自文章的內容，第八章 (68頁)。</p><blockquote><p><em>但是我不理會他，繼續趕往酒吧。到達的時候，我痛苦萬分。那一晚並不美好，因為我非常心煩意亂。<br>隔天早上，我去看醫生，發現我的腿骨折了。當我感覺疼痛時，就不該走路了，因為當時繼續走路，讓我承受額外的傷害。或許這是我生命中最糟的一天。</em></p></blockquote><p>在開發時我們很常會發生「哦..這個晚點再修改一下就好了，很簡單」但我們常常修改之後就置之不理，沒有即時的讓他變得更好更簡單，導致我們一直在累積所謂的技術債務。<br>到最後我們要繼續開發新的功能時，會發現我們寸步難行!</p><p>這本書最主要倡導的就是這幾點:</p><ul><li><h3 id="享受學習與挑戰"><a href="#享受學習與挑戰" class="headerlink" title="享受學習與挑戰"></a>享受學習與挑戰</h3></li><li><h3 id="樂觀的面對你的程式並擁抱他們讓他們變得更好"><a href="#樂觀的面對你的程式並擁抱他們讓他們變得更好" class="headerlink" title="樂觀的面對你的程式並擁抱他們讓他們變得更好"></a>樂觀的面對你的程式並擁抱他們讓他們變得更好</h3></li><li><h3 id="讓程式變得簡單、好讀、好維護"><a href="#讓程式變得簡單、好讀、好維護" class="headerlink" title="讓程式變得簡單、好讀、好維護"></a>讓程式變得簡單、好讀、好維護</h3></li></ul><p>在這本書裡面我學到了很多事情，雖然很多事情我還沒有遇過，但無論是剛入行或只有寫過一點程式的菜鳥還是老鳥工程師，不用看完這本書，只要看裡面的幾篇你有興趣的章節，我相信你們一定就會深有同感且會更熱情的去擁抱你們的程式，讓自己陷於挑戰及學習之中。</p><p>書的詳細資訊:</p><h3 id="書名-成為卓越程式設計師的38項必修法則"><a href="#書名-成為卓越程式設計師的38項必修法則" class="headerlink" title="書名:成為卓越程式設計師的38項必修法則"></a>書名:成為卓越程式設計師的38項必修法則</h3><h3 id="原文-Becoming-a-Better-Programmer"><a href="#原文-Becoming-a-Better-Programmer" class="headerlink" title="原文:Becoming a Better Programmer"></a>原文:Becoming a Better Programmer</h3><ul><li>作者： Pete Goodliffe</li><li>譯者：賴屹民</li><li>出版社：歐萊禮</li><li>出版日期：2015&#x2F;05&#x2F;05</li><li>語言：繁體中文</li><li>ISBN：9789863475699</li><li>規格：平裝 &#x2F; 376頁 &#x2F; 18.5 x 23 cm &#x2F; 普通級 &#x2F; 單色印刷 &#x2F; 初版</li><li>出版地：台灣</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 讀書心得系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode - 各種好用的擴充套件(Extension)介紹</title>
      <link href="/2017/07/30/2017-143557/"/>
      <url>/2017/07/30/2017-143557/</url>
      
        <content type="html"><![CDATA[<p>編輯器以上，IDE未滿的VSCode</p><p>今天要介紹的VSCode的擴充套件有4個，就來逐一地介紹唄</p><p>1.Path Intellisense<img src="/img/2017-143557/1501392178_7511.png"></p><p>平常在寫網頁時很容易使用到相對路徑，而這個擴充套件可以在打code的時候按下「&#x2F;」會出現資料夾、檔案供你選擇，按下Tab後就會出現你選擇的資料夾或檔案。</p><p>示範圖如下<img src="/img/2017-143557/1501393092_82431.gif"></p><p>2.Lorem ipsum<img src="/img/2017-143557/1501392129_4553.png"></p><p>亂數產生器，很常在寫網頁時他的文字段落自己要想或是文案還沒有出來，要自己想很麻煩，這時候就需要這個套件來幫我們隨機產生亂數文章</p><p>示範圖如下，按下Ctrl +Shift + p 或 F1 後 輸入lorem 選擇要單行文字還是段，按下Enter即可亂數產生一行文字</p><p><img src="/img/2017-143557/1501394796_9064.gif"></p><p>3.vscode-icons<img src="/img/2017-143557/1501392139_46674.png"></p><p>VSCode有很多icon的主題，而這個套件是我自己比較喜歡的icon主題推薦給大家，順便講一下如何更換icon主題<br>更換主題的方式有兩種 一種是 按F1 或是 Ctrl + Shift + P 後 輸入icon 選擇 <strong>喜好設定:檔案圖示佈景主題</strong> 就會出現你有安裝過的所有檔案圖示佈景主題再做選擇即可。</p><p>其畫面如下</p><p><img src="/img/2017-143557/1501395707_24754.gif"></p><p>如果不用快捷鍵選擇也可到畫面左上角選擇檔案-&gt;喜好設定-&gt;檔案圖示佈景主題 也可以喔~</p><p><img src="/img/2017-143557/1501395368_99793.png"></p><p>4.jQuery Code Snippets<br><img src="/img/2017-143557/1501392214_13589.png"></p><p>接下來是jQuery的 Code Snippets 常常在寫jQuery的朋友對於要自己一個一個字慢慢打實在是十分麻煩，所以可以利用這個套件，再輸入jq後會出現很多方法讓你選擇，可以幫你省下許多時間</p><p>示範圖如下<img src="/img/2017-143557/1501395942_38448.gif"></p><p>介紹到此 感謝收看 &lt;(_ _)&gt;</p><p>歡迎各位推薦一些好用的擴充套件給我 : )</p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 基本觀念 - 相對路徑 和 絕對路徑</title>
      <link href="/2017/07/26/2017-220713/"/>
      <url>/2017/07/26/2017-220713/</url>
      
        <content type="html"><![CDATA[<p>一起來複習一下基本觀念吧 ! 網頁開發的人必須知道的事!</p><p>安安 各位大家好，今天要介紹的是相對路徑和絕對路徑。</p><p>對於剛接觸網頁前端開發的人來說他們對於路徑的使用方式都不太懂，儘管他們可能已經可以切版或是做一些其他厲害的事情。</p><p>首先先來定義，何謂「相對路徑」和「絕對路徑」</p><h3 id="相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同。"><a href="#相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同。" class="headerlink" title="相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同。"></a>相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同。</h3><h3 id="絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。"><a href="#絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。" class="headerlink" title="絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。"></a>絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。</h3><p>我將舉多個實例來個別展示相對路徑以及絕對路徑，在舉例之前，首先得知道路徑的幾個特殊符號</p><h3 id="「-」是代表目前所在目錄"><a href="#「-」是代表目前所在目錄" class="headerlink" title="「.」是代表目前所在目錄"></a>「.」是代表目前所在目錄</h3><h3 id="「-」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄"><a href="#「-」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄" class="headerlink" title="「..」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄"></a>「..」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄</h3><h3 id="「-」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄"><a href="#「-」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄" class="headerlink" title="「&#x2F;」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄"></a>「&#x2F;」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄</h3><p>以下是目前目錄中檔案的狀態，我們目前Index.html所在的資料夾是PATHDEMO。</p><p><img src="/img/2017-220713/1501076638_52892.png"></p><p>若要寫一個以相對路徑來顯示「sqz777FirstLogo.png」的圖片的話則有以下幾種方式</p><p><img src="/img/2017-220713/1501077214_39801.png"></p><p>由上圖看見相對路徑找到圖片的方式有三種，第一和第二個一樣是在同一層目錄下找名為「sqz777NowLogo.png」的檔案<br>第三種「..&#x2F;」的方式也會達到一樣找到目前目錄的原因是這個html放置的位置就位於根目錄，故依然是找目前目錄。</p><p>若要寫一個以絕對路徑來顯示「sqz777FirstLogo.png」的圖片的話則有以下幾種方式</p><p><img src="/img/2017-220713/1501077304_52355.png"></p><p>由上圖可看見絕對路徑找到圖片的方式也有三種<br>第一和第二種則是以一般常見的絕對路徑來做顯示圖片的方式  </p><p>第三種不適用於已經架設在Server上的網頁以及開發時也不建議使用，因常常在開發時也不知道未來將會把這個檔案放置於何處，故很容易發生在實際建置網頁的時候找不到檔案的情況。</p><p>以上無論是絕對路徑還是相對路徑，在Server架設起來之後所解析出來的檔案位置都是一樣的(廢話)</p><p>我的local站台port設置為8787，實際解析出來的位置如下</p><p><img src="/img/2017-220713/1501077934_14393.png"></p><p>雖然不建議使用第三種方式但還是補充以下使用方式，其格式如下</p><h4 id="file-磁碟機名稱-路徑-檔名"><a href="#file-磁碟機名稱-路徑-檔名" class="headerlink" title="file:&#x2F;&#x2F;&#x2F;磁碟機名稱&#x2F;&#x2F;路徑&#x2F;&#x2F;檔名"></a>file:&#x2F;&#x2F;&#x2F;磁碟機名稱&#x2F;&#x2F;路徑&#x2F;&#x2F;檔名</h4><p>一般的路徑觀念大概就是到這結束，但ASP.NET的跟目錄有他一個特殊的表示方式「<del>」，有興趣的朋友可以GOOGLE一下</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> Html </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDD練習 Codewars_Stop gninnipS My sdroW!</title>
      <link href="/2017/07/23/2017-035424/"/>
      <url>/2017/07/23/2017-035424/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/2017-035424/1500741124_44467.png"></p><p>這份題目的需求是針對句子中每一個超過5個(含)進行反轉，並輸出反轉後的句子。</p><p>Codewars kata題目:<a href="https://www.codewars.com/kata/5264d2b162488dc400000001">Stop gninnipS My sdroW!</a> TDD練習。</p><p>繼這周遇見91看見他那高強的功力進行重構程式後，對TDD的概念有更深的感覺，所以決定在每天有時間都去他強力推薦的<a href="https://www.codewars.com/">Codewars</a>裡找題目練習TDD</p><p>Codewars的題目大部分相較於單純，十分的適合練習TDD。<br>為什麼會選這題呢? 哦..因為他剛好自己跳出來的啊  我覺得看起來很簡單就做了<br>因為他看起來起來很好拆解，所以我把他拆成了以下幾個需求</p><ul><li>Split方法</li><li>字串長度判斷方法</li><li>反轉字串方法</li><li>字串串接方法</li></ul><p>首先寫一個測試，輸入空字串，我們預期結果是空字串，其Test Code如下</p><pre><code>[TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_Empty_Should_Be_Empty()        /&#123;            var input = string.Empty;            var expected = string.Empty;            var actual = Kata.spinWords(input);            Assert.AreEqual(expected,actual);        /&#125;    /&#125;</code></pre><p>一開始的Production Code如下，然後跑測試，跑完測試，出現了<strong>第一個紅燈</strong></p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            throw new NotImplementedException();        /&#125;    /&#125;</code></pre><p>接著用最簡單的方式去讓他變成綠燈，Production Code 改成如下</p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            return string.Empty;        /&#125;    /&#125;</code></pre><p>再來我們綠燈之後，新增一個測試案例，輸入為aAAa，預期結果為aAAa</p><h4 id="這個測試案例的目的是讓Production-Code可以進行印出"><a href="#這個測試案例的目的是讓Production-Code可以進行印出" class="headerlink" title="這個測試案例的目的是讓Production Code可以進行印出"></a>這個測試案例的目的是讓Production Code可以進行印出</h4><p>其Test Code如下</p><pre><code>public void Input_aAAa_Should_Be_aAAa()        /&#123;            var input = &quot;aAAa&quot;;            var expected = &quot;aAAa&quot;;            var actual = Kata.spinWords(input);            Assert.AreEqual(expected,actual);        /&#125;</code></pre><p>將Production Code改成可以回傳自己</p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            return input;        /&#125;    /&#125;</code></pre><p>跑測試過了之後發現Test Code是可以進行重構的，於是重構了Test Code，其Code 以及 重構後的Test Code如下</p><pre><code> [TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_Empty_Should_Be_Empty()        /&#123;            spinResult(string.Empty,string.Empty);        /&#125;        [TestMethod]        public void Input_aAAa_Should_Be_aAAa()        /&#123;            spinResult(&quot;aAAa&quot;, &quot;aAAa&quot;);        /&#125;        private static void spinResult(string input, string expected)        /&#123;            var actual = Kata.spinWords(input);            Assert.AreEqual(expected, actual);        /&#125;    /&#125;</code></pre><p>重構完成了，我們就開始寫新的測試案例吧! 輸入Hello 預期結果是 olleH，其測試Code 如下，現在要新增測試案例變得十分簡便，不需要再往上copy paste 測試案例的code<br>所以新增的測試案例Code如下</p><h4 id="這個測試案例的目的是實做一個針對字串反轉的方法。"><a href="#這個測試案例的目的是實做一個針對字串反轉的方法。" class="headerlink" title="這個測試案例的目的是實做一個針對字串反轉的方法。"></a>這個測試案例的目的是實做一個針對字串反轉的方法。</h4><pre><code>public void Input_Hello_Should_Be_olleH()        /&#123;            spinResult(&quot;Hello&quot;,&quot;olleH&quot;);        /&#125;</code></pre><p>首先先讓這個測試案例失敗，紅燈了，再開始改Production Code來完成反轉字串的方法，完成後亮綠燈，改完的Code 如下 </p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            if (input.Length &gt; 4)            /&#123;                char[] inputArray = input.ToCharArray();                Array.Reverse(inputArray);                return new string(inputArray);            /&#125;            return input;        /&#125;    /&#125;</code></pre><p>Prodcution Code 改完之後再新增一個測試案例，輸入 Hello World 預期結果為 olleH dlroW，其Test Code如下。</p><h4 id="這個案例是直接split字串後在split後的字串進行處理，處理完成後再將它們Join起來"><a href="#這個案例是直接split字串後在split後的字串進行處理，處理完成後再將它們Join起來" class="headerlink" title="這個案例是直接split字串後在split後的字串進行處理，處理完成後再將它們Join起來"></a>這個案例是直接split字串後在split後的字串進行處理，處理完成後再將它們Join起來</h4><h4 id="這邊我不小心跨太大步了，所以這邊要新增的測試應該要是只針對多個長度未超過4的字串作為測試案例-或其他-才會比較好，EX-input-“this-is-a-test-shoud”-be-“this-is-a-test”"><a href="#這邊我不小心跨太大步了，所以這邊要新增的測試應該要是只針對多個長度未超過4的字串作為測試案例-或其他-才會比較好，EX-input-“this-is-a-test-shoud”-be-“this-is-a-test”" class="headerlink" title="這邊我不小心跨太大步了，所以這邊要新增的測試應該要是只針對多個長度未超過4的字串作為測試案例(或其他)才會比較好，EX:input “this is a test. shoud” be “this is a test”"></a>這邊我不小心跨太大步了，所以這邊要新增的測試應該要是只針對多個長度未超過4的字串作為測試案例(或其他)才會比較好，EX:<strong>input “this is a test. shoud” be “this is a test”</strong></h4><pre><code> [TestMethod]        public void Input_Hello_World_Should_Be_olleH_dlroW()        /&#123;            spinResult(&quot;Hello World&quot;, &quot;olleH dlroW&quot;);        /&#125;</code></pre><p>這時候要讓Production Code去跑每一個個別的字串，所以要用string的Split()方法去針對超過長度4的字串做個別處理，處理完成後讓使用Split()方法後的字串陣列去做串接<strong>[string.Join()]</strong> (其中間都要有空白)，code如下</p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            string[] inputArray = input.Split();            for (int i = 0; i &lt; inputArray.Length; i++)            /&#123;                char[] inputCharArray = inputArray[i].ToCharArray();                if (inputArray[i].Length &gt; 4)                /&#123;                    Array.Reverse(inputCharArray);                /&#125;                inputArray[i] = new string(inputCharArray);            /&#125;            return string.Join(&quot; &quot;,inputArray);        /&#125;    /&#125;</code></pre><p>更改Production Code之後，我們將反轉字串的方法提取出來做並重構</p><pre><code>public class Kata    /&#123;        public static string spinWords(string input)        /&#123;            string[] inputArray = input.Split();            for (int i = 0; i &lt; inputArray.Length; i++)                inputArray[i] = reverseArray(inputArray[i].ToCharArray());            return string.Join(&quot; &quot;, inputArray);        /&#125;        private static string reverseArray(char[] inputArray)        /&#123;            if (inputArray.Length &gt; 4)                Array.Reverse(inputArray);            return new string(inputArray);        /&#125;    /&#125;</code></pre><p>接下來補上一些codewars上的測試資料進行測試，最後所有測試案例的Code如下</p><pre><code>    [TestClass]    public class UnitTest1    /&#123;        [TestMethod]        public void Input_Empty_Should_Be_Empty()        /&#123;            spinResult(string.Empty, string.Empty);        /&#125;        [TestMethod]        public void Input_aAAa_Should_Be_aAAa()        /&#123;            spinResult(&quot;aAAa&quot;, &quot;aAAa&quot;);        /&#125;        [TestMethod]        public void Input_Hello_Should_Be_olleH()        /&#123;            spinResult(&quot;Hello&quot;, &quot;olleH&quot;);        /&#125;        [TestMethod]        public void Input_Hello_World_Should_Be_olleH_dlroW()        /&#123;            spinResult(&quot;Hello World&quot;, &quot;olleH dlroW&quot;);        /&#125;        [TestMethod]        public void Input_Welcome_Should_Be_emocleW()        /&#123;            spinResult(&quot;Welcome&quot;, &quot;emocleW&quot;);        /&#125;        [TestMethod]        public void Input_Hey_fellow_warriors_Should_Be_Hey_wollef_sroirraw()        /&#123;            spinResult(&quot;Hey fellow warriors&quot;,&quot;Hey wollef sroirraw&quot;);        /&#125;        [TestMethod]        public void Input_This_is_a_test_Should_Be_This_is_a_test()        /&#123;            spinResult(&quot;This is a test&quot;,&quot;This is a test&quot;);        /&#125;        [TestMethod]        public void Input_This_is_another_test_Should_Be_This_is_rehtona_test()        /&#123;            spinResult(&quot;This is another test&quot;, &quot;This is rehtona test&quot;);        /&#125;        [TestMethod]        public void Input_You_are_almost_to_the_last_test_Should_Be_You_are_tsomla_to_the_last_test()        /&#123;            spinResult(&quot;You are almost to the last test&quot;, &quot;You are tsomla to the last test&quot;);        /&#125;        [TestMethod]        public void Input_Just_kidding_there_is_still_one_more_Should_Be_Just_gniddik_ereht_is_llits_one_more()        /&#123;            spinResult(&quot;Just kidding there is still one more&quot;, &quot;Just gniddik ereht is llits one more&quot;);        /&#125;        private static void spinResult(string input, string expected)        /&#123;            var actual = Kata.spinWords(input);            Assert.AreEqual(expected, actual);        /&#125;    /&#125;</code></pre><p>這一次的TDD練習，在最後那Hello World測試案例，一次時做太多了，下一次要注意思考好跨得步伐大小，這一次跨太大步就發生了一堆東西搞在一起的問題，這是不應該發生的。</p><p>在完成重構Production Code 之後 原以為這個Code 已經算是蠻精簡的了，但把這份Code上傳到Codewars後，看到別人寫出來的其他Solution就發現有更精簡，也可以結合Linq的方式去完成這份程式，這讓我感到很興奮!! 因為我完全沒想到有這種作法!</p><h2 id="這裡是本文的commit-history"><a href="#這裡是本文的commit-history" class="headerlink" title="這裡是本文的commit history"></a><a href="https://github.com/SQZ777/Codewars_Stop-gninnipS-My-sdroW-/commits/master">這裡是本文的commit history</a></h2><hr><p>91在介紹codewars以及跟我私聊幾句時說了下面這段話</p><blockquote><p>我們需要找到一種持續給自己回饋的方式，才能持續改善<br>所以 scrum 裡面有 iteration (迭代)<br>所以有 retrospective<br>一切都是持續改善的基本要素</p></blockquote><h4 id="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界"><a href="#我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界" class="headerlink" title="我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!"></a>我想Codewars就是一個很棒的回饋方式，因為你以為你已經寫到很精簡的Code時，在提交之後就會發現一個新的世界!!!</h4>]]></content>
      
      
      
        <tags>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 運算式 與 陳述式 Lambda</title>
      <link href="/2017/07/23/2017-225131/"/>
      <url>/2017/07/23/2017-225131/</url>
      
        <content type="html"><![CDATA[<p>一起加入C#的世界吧，這次介紹的是陳述式 Lambda 以及 運算式 Lambda。</p><h2 id="開始前你得先知道…"><a href="#開始前你得先知道…" class="headerlink" title="開始前你得先知道…"></a>開始前你得先知道…</h2><p>委派是一種可以安全封裝方法的類型，他類似C、C++的函式指標(function pointer)，但委派是一個安全的物件導向類型，這個就是他與C、C++函式指標不同的地方。</p><p>匿名方法在 C# 2.0 時引進，他是一個將程式區塊當作委派參數傳遞的一種方式，因為匿名方式不需要再分別建立方法，所以可以減少實作委派時另外需要撰寫的程式碼。</p><p>想要更了解<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods">匿名方法</a>跟<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/delegates/">委派</a>的朋友們可以到官方文件詳細了解他們。</p><p>Note:另外還有兩種委派分別為 <a href="https://msdn.microsoft.com/zh-tw/library/018hxwa8(v=vs.110).aspx">Func</a><a href="https://msdn.microsoft.com/zh-tw/library/bb549151(v=vs.110).aspx">&lt;T,…&gt;</a> 和 <a href="https://msdn.microsoft.com/zh-tw/library/018hxwa8(v=vs.110).aspx">Action&lt;T,…&gt;</a> ，簡單來說 Func 有回傳值，而 Action 沒有，詳細可以去官方文件觀看，也可以到這篇<a href="https://dotblogs.com.tw/smartleos/2012/12/05/85417">部落格文章</a>瞭解哦~</p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions">Lambda</a> 是在 C# 3.0 時出現的<br>在 C# 3.0 之後的版本，Lambda 運算式成為了撰寫內嵌程式碼的首選而非匿名方法。</p><p>微軟官方定義 Lambda 的文件如下</p><blockquote><p>Lambda 運算式是<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods">匿名函式</a>，可用來建立<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/delegates/using-delegates">委派</a>或<a href="http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b">運算式樹狀架構</a>類型。 使用 Lambda 運算式可以撰寫區域函式，這些函式可以當做引數傳遞，或是當做函式呼叫的值傳回。</p><p>若要建立 Lambda 運算式，請在 Lambda 運算子 <a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/lambda-operator">=&gt;</a> 的左邊指定輸入參數 (如果有的話)，並將運算式或陳述式區塊放在另一邊。例如，Lambda 運算式 <code>x =&gt; x * x</code> 會指定名為 <code>x</code> 的參數，並傳回 <code>x</code> 的平方值。</p></blockquote><p>Note : Lambda 中的參數，在外部是無法使用(看見)的。 ex: x &#x3D;&gt; x * x 其中的 x 參數是在外部無法使用(看見)的，在使用完畢時該參數 x 就會被進行記憶體回收。</p><p>以下是 在官方文件中提到的 Lambda 一般規則：</p><blockquote><ul><li><p>Lambda 必須包含與委派類型相同數目的參數。</p></li><li><p>Lambda 中的每個輸入參數都必須能夠隱含轉換為其對應的委派參數。</p></li><li><p>Lambda 的傳回值 (如果有的話) 必須能夠隱含轉換為委派的傳回類型。</p></li></ul></blockquote><h2 id="運算式-Lambda-Expression-Lambda"><a href="#運算式-Lambda-Expression-Lambda" class="headerlink" title="運算式 Lambda (Expression Lambda)"></a>運算式 Lambda (Expression Lambda)</h2><p>運算式 Lambda 的基本形式如下</p><p>(input parameters) &#x3D;&gt; expression</p><p>以下的Code是修改自MSDN中的範例，新增匿名方法做展示匿名方法語 Lambda 的不同</p><pre><code>delegate int del(int i);static void Main(string[] args)/&#123;    int j;    //Lambda方法    del expressionLambda = x =&gt; x * x;    j = expressionLambda(5); //j = 25      Console.Write(j);    //匿名方法    del anonymousMethod = delegate (int x)    /&#123;        return x * x;    /&#125;;    j = anonymousMethod(5);    Console.Write(j); //j still 25 /&#125;</code></pre><p>其運算式 Lambda 常見的寫法有以下四種</p><pre><code>//這個方式是利用編譯器進行型別推斷，讓我們可以省去寫傳入參數型別的寫法(x, y) =&gt; x + y;//有時候編譯器會無法判斷輸入類型，所以出現這種情況時，就需要明確的指定類型(int x, string s) =&gt; s.Length &gt; x;//只有一個傳入參數時，可以省去括號x =&gt; x * x//在不需要傳入參數時必須以空括號來表示() =&gt; &quot;S&quot; + &quot;Q&quot; + &quot;Z&quot;;</code></pre><h2 id="陳述式-Lambda-Expression-Lambda"><a href="#陳述式-Lambda-Expression-Lambda" class="headerlink" title="陳述式 Lambda(Expression Lambda)"></a>陳述式 Lambda(Expression Lambda)</h2><p>陳述式 Lambda 的基本形式如下</p><p>(input parameters) &#x3D;&gt; &#x2F;{ statement; &#x2F;}</p><p>在此可以發現陳述式 Lambda 其實與 運算式 Lambda 十分相像，其不同之處在於陳述式必須包含於大括號之內，知道匿名方法的人也會發現他與匿名方法的差別僅在於將 delegate 關鍵字變更為「&#x3D;&gt;」運算子而已。</p><p>為了讓各位快速理解他們的差異性在哪所以一樣用 Code 來展示 陳述式 Lambda 與 匿名方法</p><pre><code>delegate int del(int i);static void Main(string[] args)/&#123;    int j;    //Lambda方法    del statementLambda = x =&gt;    /&#123;        x = x + 2;        return x * x; //j =49    /&#125;;    j = statementLambda(5);    Console.Write(j);    //匿名方法    del anonymousMethod = delegate(int x)    /&#123;        x = x + 2;        return x * x;    /&#125;;    j = anonymousMethod(5);    Console.Write(j); //j still 49/&#125;</code></pre><p>今天介紹到這裡，感謝收看，若內容有誤，麻煩各位大大通知我 &lt;(_ _)&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day 4_與91接觸的這4天</title>
      <link href="/2017/07/22/2017-024721/"/>
      <url>/2017/07/22/2017-024721/</url>
      
        <content type="html"><![CDATA[<p>每一次遇到強者，都覺得自己的書念得太少</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/2017-024721/1500693929_86439.png"></h2><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>今天很開心又有跟91互動到，下午五點時有整周過後的retro 跟 Spec flow for data integration testing Demo 的活動<br>我真的完全沒看過Spec flow for data integration testing，看完除了驚嘆，還是驚嘆 O口O|||<br>我從來沒看過這麼會說話(淺顯易懂) 的Code 這次讓我真正的大開眼界<br>看完這個Demo 我問了 91 一個問題</p><h3 id="我要如何才能寫出Specflow-for-data-integration-test"><a href="#我要如何才能寫出Specflow-for-data-integration-test" class="headerlink" title="我要如何才能寫出Specflow for data integration test?"></a>我要如何才能寫出Specflow for data integration test?</h3><p>91回答我說</p><h3 id="這個東西要先懂Stub、mock、Web-Testing、如何寫unit-test、TDD-等等-才能來寫出這種-test"><a href="#這個東西要先懂Stub、mock、Web-Testing、如何寫unit-test、TDD-等等-才能來寫出這種-test" class="headerlink" title="這個東西要先懂Stub、mock、Web Testing、如何寫unit test、TDD 等等 才能來寫出這種 test"></a>這個東西要先懂Stub、mock、Web Testing、如何寫unit test、TDD 等等 才能來寫出這種 test</h3><p>否則你先學了這個，但不懂前面那些東西也寫不出來。</p><p>希望我未來也可以寫出這個勇猛(?)的東西<br>之後也稍為的提到了 測試金字塔，這個名詞對我來說並不陌生，在之前Cash幫我們Intern教學Unit test時有稍微提到，但為了避免淡忘所以在這邊再一次的紀錄一下<br>其金字塔的測試粒度和比例如下</p><p><strong>測試粒度</strong></p><p><strong>測試案例比例</strong></p><p>End-to-End UI Testing</p><p>10％</p><p>Integration Testing</p><p>20％ ~ 40％</p><p>Unit Testing</p><p>50％ ~ 70％</p><p>講解粒度時印象最深刻的一句話是</p><h3 id="測試的粒度越小，能找到的問題就越多，不過這不代表這些測試綠燈了就表示沒有Bug"><a href="#測試的粒度越小，能找到的問題就越多，不過這不代表這些測試綠燈了就表示沒有Bug" class="headerlink" title="測試的粒度越小，能找到的問題就越多，不過這不代表這些測試綠燈了就表示沒有Bug"></a>測試的粒度越小，能找到的問題就越多，不過這不代表這些測試綠燈了就表示沒有Bug</h3><p>整個活動之中，有提到很多針對公司內部Team的一些改善方式，和各種未來的規劃之類的，覺得很酷</p><p>這一次91來公司對我來說最大的收穫是知道<a href="https://www.codewars.com/">Codewars</a>這個網站還有到底何謂「程式碼會說話」吧，裡面的題目通常都蠻單純，而且在寫完之後也可以看到別人寫了甚麼、用什麼方式寫的，更可以用來練習TDD<br>這幾天應該會用Codewars的題目來練習TDD然後寫成幾篇部落格 :D</p><blockquote><h5 id="在進入別間公司時，不外乎是需要去撿別人的爛攤子，或是要花時間去重構程式碼，如果不知道該如何開始重構程式碼，就從重新命名跟擷取方法開始吧"><a href="#在進入別間公司時，不外乎是需要去撿別人的爛攤子，或是要花時間去重構程式碼，如果不知道該如何開始重構程式碼，就從重新命名跟擷取方法開始吧" class="headerlink" title="在進入別間公司時，不外乎是需要去撿別人的爛攤子，或是要花時間去重構程式碼，如果不知道該如何開始重構程式碼，就從重新命名跟擷取方法開始吧!"></a>在進入別間公司時，不外乎是需要去撿別人的爛攤子，或是要花時間去重構程式碼，如果不知道該如何開始重構程式碼，就從重新命名跟擷取方法開始吧!</h5></blockquote><p>這幾天再次遇見很強大的人，讓我知道自己到底還差距多少、有甚麼還能夠學習的，期望自己有一天能夠誠為如此強大的一個人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello91 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day 3_與91接觸的這4天</title>
      <link href="/2017/07/20/2017-212735/"/>
      <url>/2017/07/20/2017-212735/</url>
      
        <content type="html"><![CDATA[<p>每一次遇到強者，都覺得自己的書念得太少</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/2017-212735/1500555354_6938.png"></h2><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>今天在公司看了幾乎整天的一些其他的文件，中午也沒有和91哥接觸到。下午五點時才得知91哥辦了一個Coding DOJO。<br>聽到這個活動我很興奮的就過去參加了。這一次應該是我第三次參加這種Pair programing的活動，在開始前，91哥跟我們分享了一些好用的Chrome Extension。<br>之後有機會再跟大家一起分享我自己也覺得很實用的Chrome Extension唄 :P</p><p>在之前的Coding DOJO中我們常常可以發現自己與別人程度的差異，還能學習其他人Coding的方式<br>這一次DOJO有限制要先寫測試，也就是以TDD的方式來做題目，這個題目在91的部落格中有寫過<br>可以先來這裡看一看:<a href="https://dotblogs.com.tw/hatelove/2017/03/28/codewars-mumbling-by-tdd">[TDD][Codewars] Mumbling</a></p><p><img src="/img/2017-212735/1500556982_3961.png"></p><p>91幫我們重構整個Prodution Code後的感觸最深，之前透過DOJO的方式協作寫完的感覺都沒有像今天一樣有感覺<br>重構的過程中，我又多看到學到了不少之前沒看過或是已經被我遺忘的一些API，也讓我更了解到底該如何撰寫TDD。<br>以這次的題目Mumbling來說我們可以將需求拆解成以下</p><ul><li><h3 id="ToUpper方法"><a href="#ToUpper方法" class="headerlink" title="ToUpper方法"></a>ToUpper方法</h3></li><li><h3 id="Repeat方法"><a href="#Repeat方法" class="headerlink" title="Repeat方法"></a>Repeat方法</h3></li><li><h3 id="ToLower方法"><a href="#ToLower方法" class="headerlink" title="ToLower方法"></a>ToLower方法</h3></li><li><h3 id="串接”-“方法"><a href="#串接”-“方法" class="headerlink" title="串接”-“方法"></a>串接”-“方法</h3></li></ul><p>如果不了解該如何拆解以上這些動作，我們會思考到底該如何去把這個需求一口氣做完，在我們想要如何把這個需求一次做完時，就會出現很多很難閱讀又很難維護的<strong>Legacy Code</strong><br>除了容易出現Legacy Code之外，也發現如果不把這些需求拆成細項，並且針對每一個細項去做的話，我們今天想要增加一個需求，也會很難去把需求補上。</p><p>拆成細項還有一個很大的好處是，它可以讓你知道該如何塞入你想要的測試資料，這點十分重要<br>如果沒有拆成細項的感知，很容易就會不知道該如何下手，還有不知道到底該怎麼做測試資料</p><p>最後91完成後我對完成的Code中的「yield return」提出發問，因為我真的是第一次看到它<br>91從IEnumerable開始 講到 yeild return實際運作的方式，有讓我真正了解他，這幾天應該會花點時間把IEnumerable整理好並寫出來 :P</p><p>Note:這個方法可以使用Linq的Select讓Production Code變得更簡化</p>]]></content>
      
      
      
        <tags>
            
            <tag> TDD </tag>
            
            <tag> Hello91 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 學習筆記 Ref 與 Out 的差別</title>
      <link href="/2017/07/19/2017-224646/"/>
      <url>/2017/07/19/2017-224646/</url>
      
        <content type="html"><![CDATA[<p>C# 的兩個 Call by Reference，Ref 與 Out</p><p>各位大大安安，早安晚安午安，從二月到現在真正開始接觸C#，之前都是應付作業隨便寫寫的方式<br>只知道C#有if else，switch，for，while，threads的等基本的東西，從二月在鈦坦實習跟公司裡的工程師學習到了很多<br>決定要開始把這些學習到的都記錄下來，不然之後都忘記了，比如說..今天，哈哈…</p><p>今天要紀錄的是ref和out的差別<br>在知道ref或out之後有些情況之下我的code可以從左邊變成了右邊，我的Function不需要再多一個回傳的動作給我的變數做替換或使用。<br>[Note:還是得需要視情況使用Call By Refference或是Call By Value]</p><p><img src="/img/2017-224646/1500472483_71057.png"></p><p>先來說說Ref 和 Out 相同的地方</p><p>Ref 和 Out 都是 Call By Reference 也就是所謂的 傳址(參考)呼叫</p><p>可以在擴充方法時發現這件事情，對於編譯器來說他們倆是相同的，以Code來說的話就會看到下面這樣的情況。</p><p><img src="/img/2017-224646/1500473396_84456.png"></p><p>可以發現他們兩個就是不能同時存在的，你無法宣告一樣的方法名稱，你如果在擴充方法同時擴充了ref和out對於編譯器來說的情況就跟下面這張圖是一樣的。</p><p><img src="/img/2017-224646/1500473612_61708.png"></p><p>我們可以從官方的文件看到 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref">Ref</a> 和 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-parameter-modifier">Out</a>之間的不同之處</p><blockquote><p>傳遞至 <code>ref</code> 參數的引數，在傳遞之前必須先初始化。 這點與 <code>out</code> 參數不同，其引數不需要在傳遞之前先明確初始化。 </p></blockquote><p>如下圖Code範例，意思就是是如果我沒有先將num1的值初始化(左手邊)，編譯器就會直接鬧脾氣給你看ˊ_&gt;ˋ<br>如果將num1賦予初始值，那編譯器就會笑顏展開唷。</p><p><img src="/img/2017-224646/1500474338_07723.png"></p><p>接下來是out的使用方式，out的成功編譯的方式不同於ref，out只要在這個方法結束前有賦予其值，就可以編譯，如下圖Code範例。<br>左手邊看見就算我一開始賦予它值，他還是沒辦法讓我編譯成功。<br>將Code修正後，我把原本num1的初始化去除(int num1 &#x3D; 1; 變成 int num1; )，反而在Method中再次初始化num1編譯器是可以成功編譯的。</p><p><img src="/img/2017-224646/1500474588_75175.png"></p><p>以上是ref 和 out 的差異，兩種方式都有其適用的情境。就視情況去使用他們唄。<br>感謝各位大大收看，若有哪些錯誤請幫忙指正我，感謝 :P</p><p>整理今天的重點</p><ul><li>ref 與 out 都是 傳址(參考)呼叫。</li><li>ref 與 out 在編譯器眼裡是被視為相同的，所以在同時使用時會發生錯誤</li><li>ref 參數需要先初始化才能將其變數傳入方法中</li><li>out 參數只要在方法內賦予其初始值，編譯就可以成功</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode－讓我們在VSCode上使用git唄</title>
      <link href="/2017/07/18/2017-084844/"/>
      <url>/2017/07/18/2017-084844/</url>
      
        <content type="html"><![CDATA[<p>編輯器以上，IDE未滿的VSCode</p><p>HI 各位 大家好 早安 午安 晚安 胎嘎後 打給後<br><a href="https://code.visualstudio.com/">Visual Studio Code</a> 是一個微軟開在2015年發布出來的一個編輯器<br>他有許多的擴充可以讓我們使用，且還有許多的優點及方便性，可以參考下面這篇文章</p><h3 id="為什麼我從-Sublime-Text-跳槽-Visual-Studio-Code？"><a href="#為什麼我從-Sublime-Text-跳槽-Visual-Studio-Code？" class="headerlink" title="為什麼我從 Sublime Text 跳槽 Visual Studio Code？"></a><a href="https://hungys.xyz/why-i-switched-from-sublime-to-vscode/">為什麼我從 Sublime Text 跳槽 Visual Studio Code？</a></h3><p>今天要介紹該如何在VSCode上使用git<br>要在VSCode上進行git的動作十分簡單，VSCode的進入畫面就可以看到複製Git存放庫(Clone git repository)的連結，按下之後他就會要你輸入Git Repository</p><p><img src="/img/2017-084844/1500335380_25903.png"></p><p>存放庫輸入完成後他會請你輸入父目錄。</p><p><img src="/img/2017-084844/1500335523_3608.png"></p><p>將父目錄輸入完成後，你將會看到左下角會出現「正在複製Git儲存庫…」的字樣，完成複製後VSCode將會跳出提醒問你說是否要開啟剛才複製的儲存庫。</p><p><img src="/img/2017-084844/1500335803_81041.png"></p><p>開啟後我們就可以進行檔案的修改、刪除、新增等動作，VSCode左手邊第三個Icon就是開啟原始檔控制的按鈕，按下去之後左手邊可以看見我們變更了哪些檔案，選擇想要看到這個檔案做了哪些變更，右手邊就會出現他的Working Tree。</p><p><img src="/img/2017-084844/1500336697_95159.png"></p><h2 id="Commit-Push-Pull"><a href="#Commit-Push-Pull" class="headerlink" title="Commit&amp;Push&amp;Pull"></a>Commit&amp;Push&amp;Pull</h2><p>可以看見檔案的右手邊有出現三個符號，分別是恢復變更，加入變更暫存，以及他的更改狀態  </p><p><img src="/img/2017-084844/1500336621_84632.png"></p><p>M是Modified，檔案狀態是「有做修改的」<br>U是Updated，檔案狀態是「被新增的」<br>D是Deleted，檔案狀態是「被刪除的」<br>特別要說的是 U ，U在被Commit後，會變成 A<br>這個狀態是跟我們說這個檔案「將要被新增的」了。<br>接下來要進行Commit的動作在上方可以看見一個輸入欄位讓我們輸入Commit的Message輸入完成後按下欄位上方的勾勾，就可以進行Commit</p><p><img src="/img/2017-084844/1500337482_88646.png"><br>Commit後要進行推送可以使用兩種方式<br>第一種是在勾勾右手邊那個按鈕按下去再按下推送，如下圖</p><p><img src="/img/2017-084844/1500337585_17608.png"><br>另一種方式則是使用快捷鍵 Ctrl + Shift + P 後輸入Push，選擇推送，按下Enter就可以進行推送囉!</p><p><img src="/img/2017-084844/1500337726_63847.png"><br>今天若要Pull檔案，可以使用第一種方式選擇提取，或是使用第二種方式將Push改成Pull即可，今天若在Pull檔案發生衝突時則會出現以下畫面</p><p><img src="/img/2017-084844/1500338366_5759.png"></p><h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h2><p>分支很重要，所以若是要Checkout分支，按下Ctrl + Shift + P 輸入 git Checkout後他會要你選擇哪一個分支進行Checkout，如下圖<br>如果你輸入的Branch名稱找不到，它會自動幫你新增一個Branch</p><p><img src="/img/2017-084844/1500338675_59368.png"></p><p>今天的分享到這裡，有甚麼建議就跟我說唷，感謝各位大大收看ˊ_&gt;ˋ</p>]]></content>
      
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day 1_與91接觸的這4天</title>
      <link href="/2017/07/18/2017-230008/"/>
      <url>/2017/07/18/2017-230008/</url>
      
        <content type="html"><![CDATA[<p>每一次遇到強者，都覺得自己的書念得太少</p><p>從上個月的部門會議中就知道這個月91就會來到公司帶領公司正職的人(目前我是個實習生 O_O)</p><p><img src="/img/2017-230008/1500387075_17811.png"></p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>在7&#x2F;17終於看到了傳說中的91，第一天的中午91就與大家聊聊天，並在白板畫下了上面這張圖，講到工程師的職涯之路就像一個巨大的技能樹<br>中說了五點(棵樹?)</p><ul><li>Tech Skill</li><li>Tech collaboration</li><li>Agile Method log</li><li>Domain</li><li>Soft-Skill</li></ul><p>從白板上可以看到Tech Skill 和 Tech collaboration(應該是這樣吧ˊ_&gt;ˋ)有分支出來另外三項<br>從Tech Skill延伸出 最基本的Coding能力 然後 設計能力(ex:OOP) 再來架構(ex:MVC)<br>從Tech Skill拉出來用C#來講 91就一一列舉出一些C#上所使用到的技術，一個Move就畫出了下面這張圖(持續成長中..?)</p><p><img src="/img/2017-230008/1500387859_03355.png"></p><p>從Tech collaboration延伸出來的Review 然後 團隊合作 最後是 影響力(91表示這點是最稀有的能力)<br>我覺得從 Review ,Team collaboration到 Leading Changes都是一個影響力發展<br>從Review你要如何影響一個人(Coding Style? or 其他叭啦叭啦)-&gt;<br>你要如何影響整個Team(引入某種技術? or 其他叭啦叭啦)-&gt;<br>你要如何影響整個公司(導入敏捷? or 其他叭啦叭啦)<br>*****Agile Method log 在這指的是 <strong>系統發展生命週期(System Development Life Cycle) 所有相關的協作、流程與基礎建設</strong> 感謝91回覆我這個我不記得當初所說的事&lt;(_ _)&gt;<br>Domain則是說你的領域在哪，像是博奕類、購物網站，這種就屬於高頻訪問類型(是這樣說的嗎..ˊ_&gt;ˋ)的Domain，也有ERP或是其他的Domain<br>Soft-Skill顧名思義就是軟實力他所涵蓋的範圍非常的廣，像是簡報能力、嘴砲八啦叭啦等等等等等等。  </p><p>大家都知道</p><blockquote><p>技術的學習曲線，永遠不是線性的，而我們的時間是有限的。</p></blockquote><p>91表示這幾棵樹(?)都要花時間去投資技能點數，技能等級越高的就越得花更多的技能點數(時間)去投資他，才會有更大的進步。<br>找到自己對他有愛的技術，去研究它，鑽研它。會比樣樣都通但樣樣不精還要來得值得投資。<br>詳細可以參考91的這兩篇文章:<br><a href="https://dotblogs.com.tw/hatelove/2017/02/06/investing-your-time-to-produce-synergies">全端工程師才有價值？</a><br><a href="https://dotblogs.com.tw/hatelove/2016/05/24/181324">[隨筆] Developer 自我養成之路</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello91 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day 2_與91接觸的這4天</title>
      <link href="/2017/07/18/2017-231255/"/>
      <url>/2017/07/18/2017-231255/</url>
      
        <content type="html"><![CDATA[<p>每一次遇到強者，都覺得自己的書念得太少</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>今天中午91分享了一部名叫Dinner的日劇給大家看(第一集)，換個角度來看<br>片中廚房裡每一個人的分工方式真的很像我們在Run敏捷開發的感覺，<br>廚房裡做菜的是Team，服務生是 PO 而廚師長則是 Scrum Master，在餐廳內吃飯的就是Customer。<br>裡面發生了一件事情是<br>一名顧客在餐廳裡吃飯，廚房做菜時遇到了問題，雖然馬上就解決了也很開心的找到了這個替代方案，過程一路順利，但忽略了新的解決方案會衍生出這個餐點會太鹹的問題<br>這個顧客一吃下去就發現這個不是他要的餐點並點出了Team忽略了替代方案會衍生出來的問題。<br>而Team並不接受這名顧客所提出的點，並表示我們用了很多心意與努力等等的，如下圖<br><img src="/img/2017-231255/1500391983_98126.png"></p><p>現實的是客戶要的不是努力與心意，而客戶反問了一句話</p><blockquote><p>「你們所謂的心意，究竟是甚麼味道? 影響這道菜的好壞不是團隊合作和心意，是一克鹽巴，僅僅一克鹽巴就可能會失去自己的常客」</p></blockquote><p>跟現實開發的現況其實十分相像<br>今天我們工程師做事都做得很愉快，努力的寫Code，開心的產出<br>最後我們忽略了客戶的感受與需求，如果客戶不滿意今天的產出，他們一點都不會在乎你們開發過程有多快樂多努力<br>他們要的是今天這個需求能不能滿足他們，幫他們賺錢(之類的)。</p><p>在看完影片之後，91決定在下班前辦一個 Visual Studio的熱鍵大賽<br>(沒有懲罰，真要說的話就是說不出來的要喝啤酒或是喝綠茶 哈哈哈哈)<br>主要的目的不是比賽，而是讓大家知道自己有沒有不知道的東西，對於大家也是一種複習和學習，真心覺得很棒。</p><p>在幾個月前公司的某個禮拜二記得Cash和Tim有分享一些熱鍵，那時候發現這些熱鍵<br>真的是覺得十分的新奇與興奮，所以我先詢問了實習生是否可以參加這個大賽，得到答案之後我就第一個寫下了我的名字，五點半之後報名區上面的名字才陸陸續續的長出來(?)變成下面這張圖的樣子<br>牆壁上就可以看見很多熱鍵，其中有自己很常在使用的，也有沒有用過的，這一次又學到了不少東西，是一個寶貴的經驗 :D  </p><p><img src="/img/2017-231255/1500693610_13777.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello91 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp學習紀錄_Part 3-一起來使用Livereload做前端吧!!</title>
      <link href="/2017/07/14/2017-001638/"/>
      <url>/2017/07/14/2017-001638/</url>
      
        <content type="html"><![CDATA[<p>前端的技巧越來越多，要做的事情也越來越繁雜，就交給Gulp吧!</p><p>Hi 大家豪，今天要講到的是<a href="https://www.npmjs.com/package/gulp-connect">connect</a>套件以及<a href="https://www.npmjs.com/package/gulp-watch">Watch</a>套件(非內建)的使用方式</p><p>首先來介紹這兩個套件的特色，connect這個套件可以幫助我們在檔案儲存時可以重新整理我們的頁面，且不需要安裝額外的擴充軟體或再開一個node.js的命令視窗來開一個網站。而Watch套件可以讓我們在gulpfile.js少新增一個watch的task方法將會在稍後為大家介紹~</p><p>這次就讓大家一次安裝兩個套件吧! 要一次安裝多個套件就以這次要安裝兩個套件為範例，輸入以下的指令就可以一次安裝兩個套件喔</p><pre><code>npm install --save-dev gulp-connect gulp-watch</code></pre><p>安裝完成後在gulpfile.js內一樣引入這兩個套件，這一次的程式碼直接承襲Part 2的程式碼，所以引入套件後的程式碼如下</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;) //引入Concat套件    uglify = require(&#39;gulp-uglify&#39;) //引入uglify套件    sass = require(&#39;gulp-sass&#39;)     //引入sass套件    connect = require(&#39;gulp-connect&#39;) //引入connect套件    watch = require(&#39;gulp-watch&#39;)     //引入watch套件</code></pre><p>此時我們需要用一個task來使用connect套件來開啟port以及開啟port的專案相對位置，其程式碼如下</p><pre><code>gulp.task(&#39;serverGO&#39;, function () /&#123;    connect.server(/&#123;        root: &#39;build&#39;, //設定開啟位置        livereload: true, //開啟livereload        port: 8787 //設定預設port為8787    /&#125;);/&#125;);</code></pre><p>接下來我們來介紹該如何使用非內建的Watch方式以及connect重新整理頁面的方法，非內建的Watch方式很簡單，只要在每一個需要watch的task內加入watch的function即可，這次我們針對sassGO這個task來做改變，其程式碼如下</p><pre><code>gulp.task(&#39;sassGO&#39;, function () /&#123;    return watch(&#39;src/**/*.scss&#39;,function()/&#123;     //監看src目錄底下的所有scss檔        gulp.src(&#39;src/**/*.scss&#39;)                //設定來源檔案為src目錄底下的所有scss檔        .pipe(sass().on(&#39;error&#39;, sass.logError))         .pipe(gulp.dest(&#39;./build/&#39;))             //輸出至build目錄底下        .pipe(connect.reload());                 //利用connect套件刷新頁面    /&#125;);/&#125;);</code></pre><p>現在我們的gulpfile.js都寫好了，程式碼如下(所有範例檔我放在<a href="https://github.com/SQZ777/DemoGulp">Git</a>上，歡迎大家參考)</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;) //引入Concat套件uglify = require(&#39;gulp-uglify&#39;) //引入uglify套件sass = require(&#39;gulp-sass&#39;)     //引入sass套件connect = require(&#39;gulp-connect&#39;) //引入connect套件watch = require(&#39;gulp-watch&#39;)     //引入watch套件gulp.task(&#39;serverGO&#39;, function () /&#123;    connect.server(/&#123;        root: &#39;build&#39;, //設定開啟位置        livereload: true, //開啟livereload        port: 8787 //設定預設port為8787    /&#125;);/&#125;);//將src內的所有js打包成all.js並將all.js輸出至build/js的目錄下gulp.task(&#39;ConcatAndUglify&#39;, function () /&#123;    return watch(&#39;src/**/*.js&#39;, function () /&#123;   //監看src目錄底下的所有js檔        gulp.src(&#39;src/**/*.js&#39;)                 //設定來源檔案為src目錄底下的所有js檔            .pipe(concat(&#39;all.js&#39;))            .pipe(uglify())            .pipe(gulp.dest(&#39;./build/js&#39;))      //輸出至build目錄底下            .pipe(connect.reload());            //利用connect套件刷新頁面    /&#125;);/&#125;);//將src內的所有scss輸出至build目錄下gulp.task(&#39;sassGO&#39;, function () /&#123;    return watch(&#39;src/**/*.scss&#39;, function () /&#123;     //監看src目錄底下的所有scss檔        gulp.src(&#39;src/**/*.scss&#39;)                //設定來源檔案為src目錄底下的所有scss檔            .pipe(sass().on(&#39;error&#39;, sass.logError))            .pipe(gulp.dest(&#39;./build/&#39;))             //輸出至build目錄底下            .pipe(connect.reload());                 //利用connect套件刷新頁面    /&#125;);/&#125;);gulp.task(&#39;htmlGO&#39;, function () /&#123;    return watch(&#39;build/**/*.html&#39;, function () /&#123;        gulp.src(&#39;build/**/*.html&#39;)             .pipe(connect.reload());                 //利用connect套件刷新頁面    /&#125;);/&#125;);//內建的watch方式// gulp.task(&#39;watch&#39;, function () /&#123;//     gulp.watch(&#39;src/**/*.scss&#39;, [&#39;sassGO&#39;]);//     gulp.watch(&#39;src/**/*.js&#39;, [&#39;ConcatAndUglify&#39;]);//     gulp.watch(&#39;build/**/*.html&#39;, [&#39;htmlGO&#39;]);// /&#125;);gulp.task(&#39;default&#39;, [&#39;ConcatAndUglify&#39;, &#39;sassGO&#39;, &#39;serverGO&#39;, &#39;htmlGO&#39;]);// gulp.task(&#39;default&#39;, [&#39;ConcatAndUglify&#39;, &#39;sassGO&#39;, &#39;serverGO&#39;, &#39;watch&#39;]);</code></pre><p>gulpfile.js的檔案都準備好了，接下來就執行gulp吧! 執行完成後可以看到Server成功啟動了，8787這個port成功開啟，並且Livereload在35729 port上成功啟動。</p><p><img src="/img/2017-001638/1499961875_88119.png"></p><p>如下gif圖就可以看見我們每一次更動檔案，他都會幫我們去做刷新的動作。</p><p><img src="/img/2017-001638/1499962372_69478.gif"></p><p>非內建Watch的方式各有所好，每個人的喜好不同，所以有的人喜歡，有的人不喜歡，這是一種______<br>這次的介紹到這裡，感謝大家的觀看<br>這裡再附上一次Git的網址:<br><a href="https://github.com/SQZ777/DemoGulp">https://github.com/SQZ777/DemoGulp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Gulp.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp學習紀錄_Part 2-Gulp可以做什麼事?</title>
      <link href="/2017/07/12/2017-233637/"/>
      <url>/2017/07/12/2017-233637/</url>
      
        <content type="html"><![CDATA[<p>前端的技巧越來越多，要做的事情也越來越繁雜，就交給Gulp吧!</p><p>HI 大家豪，繼上次分享安裝及使用Gulp文章推出後，這次要分享的是我有在gulp上使用的其中幾個套件~</p><p>這次分享使用的套件有<a href="https://www.npmjs.com/package/gulp-concat/">concat</a>、<a href="https://www.npmjs.com/package/gulp-uglify/">uglify</a>、<a href="https://www.npmjs.com/package/gulp-sass/">sass</a>。還有該如何<strong>讓gulp監看(Watch)檔案狀態並針對檔案儲存行來進行特定的task</strong>，希望大家會喜歡的啦</p><p>還有幾個套件是connect以及非內建的watch，我將會在下一篇分享這2個套件的使用方式，敬請期待囉~</p><p>廢話不多說，要先來介紹的是concat，concat這個套件的功能是將你多個js檔案打包並輸出成一個js檔案。</p><p>若要安裝這個套件，就要在你的專案內使用node.js輸入下面的指令來安裝concat這個套件</p><pre><code>npm install --save-dev gulp-concat</code></pre><p>安裝完成後若需要使用這個套件就必須要讓gulp知道有這個task所以我們需要在gulpfile.js中撰寫下列程式碼</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;)//將src內的所有js打包成all.js並將all.js輸出至build/js的目錄下gulp.task(&#39;Concat&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.js&#39;)        .pipe(concat(&#39;all.js&#39;))        .pipe(gulp.dest(&#39;./build/js&#39;))        .pipe(connect.reload());;/&#125;);</code></pre><p>下圖為這篇文章所使用的目錄結構，如上述程式碼中我需要建構src目錄內的所有js所以我放置了兩個js檔案，分別為a.js 和 b.js</p><p><img src="/img/2017-233637/1499871805_35683.png"></p><p>a.js的程式內容為</p><pre><code>$(document).ready(function () /&#123;    console.log(&#39;PrintA&#39;);/&#125;);</code></pre><p>b.js的程式碼內容為</p><pre><code>$(document).ready(function () /&#123;    console.log(&#39;PrintB&#39;);/&#125;);</code></pre><p>將兩份JavaScript檔案準備好後就返回到Node.js中，使用gulp執行Concat這個task</p><p><img src="/img/2017-233637/1499869317_95848.png"></p><p>執行成功後可以發現build底下的js如期的出現all.js的檔案，圖中右手邊可以看到gulp已經幫我們把a.js以及b.js完整的打包在一起，是不是很棒呢~</p><p><img src="/img/2017-233637/1499871852_61883.png"></p><p>接下來要介紹的是Uglify這個套件，這個套件可以幫助我們將js檔進行Minify的動作，好處是可以讓程式執行效率變好。</p><p>要使用這個套件的話一樣是使用你的node.js到你的專案目錄底下執行下列指令</p><pre><code>npm install --save-dev gulp-uglify</code></pre><p>安裝完成後我們使用之前使用過的程式碼來進行新增，其task名稱更改為「ConcatAndUglify」，引入Uglify的套件並在task中加入uglify的動作。</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;),引入Concat套件    uglify = require(&#39;gulp-uglify&#39;)//引入uglify套件//將src內的所有js打包成all.js再uglify化後，將all.js輸出至build/js的目錄下gulp.task(&#39;ConcatAndUglify&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.js&#39;)        .pipe(concat(&#39;all.js&#39;))        .pipe(uglify()) //uglify化        .pipe(gulp.dest(&#39;./build/js&#39;))        .pipe(connect.reload());/&#125;);</code></pre><p>程式碼完成後執行完成後可以看見all.js中的檔案會變成一行的JavaScript程式，如下圖。</p><p><img src="/img/2017-233637/1499871767_29121.png"></p><p>接下來要講的是sass這個套件，主要功能是幫助我們進行編譯sass檔，我們可以指定編譯後的檔案輸出到我們想要放置的目錄底下。我們要使用這個套件也必須先執行下列指令</p><pre><code>npm install gulp-sass --save-dev</code></pre><p>執行完成後，我們再新增一個task來做sass編譯，其task名稱為sassGO。程式碼從舊有的新增，新增完成後如下。因為要分開來執行兩次gulp很繁瑣，所以在最後新增了一個default的task來讓gulp執行ConcatAndUglify和sassGO這兩個task</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;), //引入concat套件    uglify = require(&#39;gulp-uglify&#39;), //引入uglify套件    sass = require(&#39;gulp-sass&#39;),     //引入sass套件//將src內的所有js打包成all.js再uglify化後，將all.js輸出至build/js的目錄下gulp.task(&#39;ConcatAndUglify&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.js&#39;)        .pipe(concat(&#39;all.js&#39;))        .pipe(uglify()) //uglify化        .pipe(gulp.dest(&#39;./build/js&#39;))        .pipe(connect.reload());/&#125;);//將src內的所有scss檔編譯後輸出到build/的目錄下gulp.task(&#39;sassGO&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.scss&#39;)        .pipe(sass().on(&#39;error&#39;, sass.logError))        .pipe(gulp.dest(&#39;./build/&#39;))        .pipe(connect.reload());/&#125;);//預設執行ConcatAndUglify和sassGO這兩個taskgulp.task(&#39;default&#39;, [&#39;ConcatAndUglify&#39;, &#39;sassGO&#39;]);</code></pre><p>在src&#x2F;css的目錄底下我自己先新增了一個scss的檔案，其scss的程式碼內容如下</p><pre><code>$bg:yellow;body/&#123;    background-color:red;    color:white;/&#125;</code></pre><p>在gulp執行完畢後可以看見css的目錄底下多了一個demo.css的檔案，這代表他已經完成編譯了。其編譯後的css檔程式碼如下。</p><p><img src="/img/2017-233637/1499872068_43143.png"></p><p>這些套件都安裝完成可以成功執行了，但很麻煩的是每一次要編譯都要在執行一次gulp，所以gulp有一個很貼心的功能叫做Watch，他可以幫我們監看某一個目錄底下的檔案是不是有變動，如果有變動，我們可以針對有變動(或有儲存動作)的目錄來執行我們指定的某一個task，廢話不多說我們來看該怎麼使用watch，要使用watch不需要安裝套件，但是也有非內建的watch套件可以讓程式碼變得更好，這個套件我想應該會和下次的connect和livereload一起分享出來~</p><p>若要監控檔案是否有變動也需要建立一個task來讓gulp知道要進行watch的動作，其程式碼如下</p><pre><code>var gulp = require(&#39;gulp&#39;),    concat = require(&#39;gulp-concat&#39;), //引入concat套件    uglify = require(&#39;gulp-uglify&#39;), //引入uglify套件    sass = require(&#39;gulp-sass&#39;)     //引入sass套件//將src內的所有js打包成all.js再uglify化後，將all.js輸出至build/js的目錄下gulp.task(&#39;ConcatAndUglify&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.js&#39;)        .pipe(concat(&#39;all.js&#39;))        .pipe(uglify()) //uglify化        .pipe(gulp.dest(&#39;./build/js&#39;))        .pipe(connect.reload());/&#125;);//將src內的所有scss檔編譯後輸出到build/的目錄下gulp.task(&#39;sassGO&#39;, function () /&#123;    return gulp.src(&#39;src/**/*.scss&#39;)        .pipe(sass().on(&#39;error&#39;, sass.logError))        .pipe(gulp.dest(&#39;./build/&#39;))        .pipe(connect.reload());/&#125;);//讓gulp開始監看目錄下的變動，並執行指定動作gulp.task(&#39;watch&#39;, function () /&#123;    gulp.watch(&#39;src/**/*.scss&#39;, [&#39;sassGO&#39;]); //監控src下所有的.scss檔，若有變動則執行sassGO這個task    gulp.watch(&#39;src/**/*.js&#39;, [&#39;Concat&#39;]);   //監控src下所有的.js檔，若有變動則執行Concat這個task/&#125;);//預設執行ConcatAndUglify和sassGO以及watch這三個taskgulp.task(&#39;default&#39;, [&#39;ConcatAndUglify&#39;, &#39;sassGO&#39;,&#39;watch&#39;]);</code></pre><p>在node.js執行gulp會發現畫面會卡住，並不讓你輸入下一個指令，這代表他正在監看你目錄下的檔案</p><p><img src="/img/2017-233637/1499873560_01025.png"></p><p>我們將src目錄下的scss檔案變更的話在命令視窗內就會顯示他進行指定task動作(sassGO)的畫面</p><p><img src="/img/2017-233637/1499873576_00622.png"></p><p>若更改src目錄下的.js檔也會進行變動，因為我們也有監看src下的.js檔，如下圖</p><p><img src="/img/2017-233637/1499873656_98006.png"></p><p>今天的分享到這邊結束囉，下一次將介紹connect、livereload以及非內建的watch套件</p><p>感謝各位大大的觀看，歡迎一起討論 感謝~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Gulp.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp學習紀錄_Part 1-Hello Gulp!</title>
      <link href="/2017/07/10/2017-213106/"/>
      <url>/2017/07/10/2017-213106/</url>
      
        <content type="html"><![CDATA[<p>前端的技巧越來越多，要做的事情也越來越繁雜，就交給Gulp吧!</p><p>前陣子開始Follow一些人在直播寫程式，尤其是前端切版之類的</p><p>就很好奇他們一些前置作業之類的動作是如何完成的，偶然間發現Gulp.js這一個方便的東西</p><p>本篇將簡單介紹該如何開始使用Gulp.js，之後也會另外寫文章介紹我個人有在使用的Gulp套件</p><p>Gulp.js是一個<a href="https://nodejs.org/en/">Node.js</a>的套件，所以要使用Gulp.js之前必須要先安裝<a href="https://nodejs.org/en/">Node.js</a>喔!!</p><p>Gulp.js的官方還有中文文件(簡體)可以參考</p><p><a href="http://www.gulpjs.com.cn/">http://www.gulpjs.com.cn/</a></p><p>若習慣看英文版的朋友可以到這裡</p><p><a href="http://www.gulpjs.com.cn/">http://www.gulpjs.com/</a></p><p>在開始前請先將Node.js安裝完成</p><p>安裝完成後開啟Node.js的「Node.js command prompt」別開到Node.js囉!</p><p>首先先在你想要使用的gulp專案下輸入並執行</p><pre><code>npm init</code></pre><p><img src="/img/2017-213106/1499691073_2805.png"></p><p>執行後他會要你輸入名字、定義等之類的需求，輸入完成後他會幫你輸出一個Package.json的檔案</p><p>我只有輸入名字’sqz’，其餘的都直接按Enter帶過，檔案內容長這樣</p><pre><code>/&#123;  &quot;name&quot;: &quot;sqz&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: /&#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  /&#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;/&#125;</code></pre><p>檔案中如果安裝了一些套件他會顯示你安裝過哪些套件，這樣一來如果未來團隊有新人要來學習就可以透過這個檔案知道你們有使用哪些套件進行開發。</p><p>接下來要開始安裝gulp，開啟後在command中輸入</p><pre><code>npm install -g gulp</code></pre><p>在全域安裝完成後再到你想要使用gulp的專案下安裝gulp套件</p><p><img src="/img/2017-213106/1499690697_51864.png"></p><p>完成安裝後可以看見你package.json上面顯示說你這個專案有安裝了gulp，檔案內容會長成這個樣子</p><pre><code>/&#123;  &quot;name&quot;: &quot;sqz&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: /&#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  /&#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: /&#123;    &quot;gulp&quot;: &quot;^3.9.1&quot;  /&#125;/&#125;</code></pre><p>接下來你需要在你的專案跟目錄下新增一個gulpfile.js，這個檔案是當你執行gulp時直接讀取的檔案。</p><p>這個檔案內必須先引用gulp plugin，引用後要建立一個gulp的task，讓gulp知道你要做什麼事情，default是gulp預設載入的task名稱，下面是gulpfile.js的檔案內容。</p><pre><code>//引用gulpvar gulp = require(&#39;gulp&#39;); //建立一個gulp的default taskgulp.task(&#39;default&#39;, function () /&#123;    console.log(&#39;Hello Gulp!&#39;);/&#125;);</code></pre><p>你只需要gulp即可執行</p><pre><code>gulp</code></pre><p>執行成功後可以看見他有幫我們印出Hello Gulp! ，其畫面如下</p><p><img src="/img/2017-213106/1499692307_31067.png"></p><p>若今天想要讓這個task不要讓他自動載入我們只要將default這個字更改為你想要命名的名稱即可。</p><p>但執行gulp時就不能只輸入gulp，你必須輸入 「gulp 你的task名稱」。</p><p>以原本的程式碼為範例，我們將default更改為HelloGulp再到node.js command中輸入gulp肯定是會出現錯誤訊息的，所以我們需要輸入gulp HelloGulp讓gulp找到你的task。下圖可以看見執行失敗以及成功的畫面。</p><p><img src="/img/2017-213106/1499692626_48898.png"></p><p>今天如果我們有很多個task但又想要命名別的名稱可以這樣做，我們先假設我們有task1，task2，task3這三個task，如果我想要預設一次載入他的話，那我要在default的task中這樣撰寫，gulp就知道預設要執行這三個task。以下為gulpfile.js檔案內目前的內容。</p><pre><code>var gulp = require(&#39;gulp&#39;);gulp.task(&#39;task1&#39;, function () /&#123;    console.log(&#39;task1!&#39;);/&#125;);gulp.task(&#39;task2&#39;, function () /&#123;    console.log(&#39;task2!&#39;);/&#125;);gulp.task(&#39;task3&#39;, function () /&#123;    console.log(&#39;task3!&#39;);/&#125;);gulp.task(&#39;default&#39;, [&#39;task1&#39;,&#39;task2&#39;,&#39;task3&#39;]);</code></pre><p>執行後的畫面會如下圖。</p><p><img src="/img/2017-213106/1499692896_01991.png"></p><p>今天gulp的簡單介紹就講到這裡，感謝各位耐心地看完ˊ_&gt;ˋ</p><p>如果有哪些部分不清楚的地方可以再跟我說~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Gulp.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
