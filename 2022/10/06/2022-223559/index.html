<!DOCTYPE html><html class="appearance-auto" lang="zh-TW"><head><meta charset="UTF-8"><title>API 自動化的技術選擇與 Modules 的分層思考 - sqz777's blog</title><meta name="description" content="今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。
https://.."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><meta name="image" content="https://sqz777.github.io/img/2022-223559/1665066616.png.png"><meta name="original-source" content="https://sqz777.github.io/2022/10/06/2022-223559/"><link rel="canonical" href="https://sqz777.github.io/2022/10/06/2022-223559/"><meta property="og:locale" content="zh-TW"><meta property="og:type" content="article"><meta property="og:title" content="API 自動化的技術選擇與 Modules 的分層思考 - sqz777's blog"><meta property="og:description" content="今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。
https://.."><meta property="og:url" content="https://sqz777.github.io/2022/10/06/2022-223559/"><meta property="og:site_name" content="SQZ777's blog"><meta property="og:image" content="https://sqz777.github.io/img/2022-223559/1665066616.png.png"><meta name="twitter:title" content="API 自動化的技術選擇與 Modules 的分層思考 - sqz777's blog"><meta name="twitter:image" content="https://sqz777.github.io/img/2022-223559/1665066616.png.png"><meta name="twitter:description" content="今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。
https://.."><meta name="twitter:card" content="summary_large_image"><meta name="google-site-verification" content="lTAMT4U8v-CtkYRIo8AmGaACB3EikdUYpiTHAylwGPE"><!-- Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-4N118JY08V"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4N118JY08V');</script><!-- End Google Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="SQZ777's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">sqz777's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">API 自動化的技術選擇與 Modules 的分層思考</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">點擊返回開頭</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首頁</a></h3><h3 class="is-inline-block"><a href="/about">關於我</a></h3><h3 class="is-inline-block"><a href="/archives">文章列表</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首頁</a></h3><h3 class="is-inline-block"><a href="/about">關於我</a></h3><h3 class="is-inline-block"><a href="/archives">文章列表</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%BA%E4%BD%95%E4%B8%8D%E4%BD%BF%E7%94%A8-Postman-%E4%BE%86%E5%81%9A-API-Automation%EF%BC%9F"><span class="toc-text">為何不使用 Postman 來做 API Automation？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AA%9E%E8%A8%80%E9%81%B8%E6%93%87"><span class="toc-text">語言選擇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%AC%E8%A9%A6%E6%A1%86%E6%9E%B6%E9%81%B8%E6%93%87"><span class="toc-text">測試框架選擇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Modules-%E7%9A%84%E5%88%86%E5%B1%A4"><span class="toc-text">Modules 的分層</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E5%80%8B-Modules-%E7%9A%84%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AF%A6%E4%BD%9C"><span class="toc-text">各個 Modules 的介紹與實作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#requestPayloads-%E8%B3%87%E6%96%99%E5%A4%BE"><span class="toc-text">requestPayloads 資料夾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apis-%E8%B3%87%E6%96%99%E5%A4%BE"><span class="toc-text">apis 資料夾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#common-%E8%B3%87%E6%96%99%E5%A4%BE"><span class="toc-text">common 資料夾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tests-%E8%B3%87%E6%96%99%E5%A4%BE"><span class="toc-text">tests 資料夾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B5%90%E8%AA%9E%E5%92%8C%E6%9C%AC%E7%AF%87%E6%B2%92%E6%8F%90%E5%88%B0%E7%9A%84%E4%BA%8B"><span class="toc-text">結語和本篇沒提到的事</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Automation"><i class="tag post-item-tag">Automation</i></a><a href="/tags/API"><i class="tag post-item-tag">API</i></a><a href="/tags/Notes"><i class="tag post-item-tag">Notes</i></a><a href="/tags/API%20Automation"><i class="tag post-item-tag">API Automation</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">API 自動化的技術選擇與 Modules 的分層思考</h1><time class="has-text-grey" datetime="2022-10-06T00:00:00.000Z">2022-10-06</time><article class="mt-2 post-content"><p>今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/SQZ777/jest-for-api-automation-template.git">https://github.com/SQZ777/jest-for-api-automation-template.git</a></p>
<p>各個 subtitle 如下</p>
<ul>
<li>為何不使用 Postman 來做 API Automation</li>
<li>語言選擇</li>
<li>測試框架選擇</li>
<li>Modules 的分層</li>
<li>各個 Modules 的介紹與實作</li>
<li>結語和本篇沒提到的事</li>
</ul>
<p>首先在使用程式碼撰寫 API 自動化的測試案例時，一定會先遇到這個問題</p>
<h2 id="為何不使用-Postman-來做-API-Automation？"><a href="#為何不使用-Postman-來做-API-Automation？" class="headerlink" title="為何不使用 Postman 來做 API Automation？"></a>為何不使用 Postman 來做 API Automation？</h2><p><img src="/img/2022-223559/1665066616.png.png"></p>
<p>所以就先來列一下 Postman 的優&#x2F;缺點吧</p>
<p>優點如下</p>
<ul>
<li>UI 介面容易使用，門檻極低</li>
<li>可以透過 JavaScript 來實作檢查 response 的 script</li>
<li>各個平台（Mac, Windows）都可以使用</li>
<li>可以透過 newman（CLI）來建置 CI 的流程</li>
</ul>
<p>接著列一下使用 Postman 執行管理自動化案例會遇到的問題</p>
<ul>
<li>大量自動化案例會產生極大的維護成本<ul>
<li>無法重用的 test script</li>
<li>受測 API 如果新增 required fields，會需要手動更新大量既有的 script</li>
</ul>
</li>
<li>執行 collection runner 再透過 csv 檔案來匯入測試資料的過程過於繁瑣</li>
</ul>
<p>Postman 在實作小型的 API 驗證時，是一個非常好用的工具，但需要實作大量 API 測試案例時，在 Postman 上管理這些案例會產生很大的維護成本，不信的話你可以試試，所以我們需要透過撰寫程式的方式來管理這些即將被實作的 API 測試案例。</p>
<h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>首先要選擇的是語言，依照公司內部現有的技術而選，策略是以不增加公司同事之間跨越職能障礙為主要目標，其次是這個語言的資源，再其次是學習的門檻，因為有尚未開發過自動化的 QA ，所以選擇語言起手的難易度也需要列為考量。</p>
<p><img src="/img/2022-223559/1665066630.png.png"></p>
<p>抱歉了 Java XD</p>
<p>公司內部的 backend 是 Java，而 front-end 則是 Vue.js，所以就剩下 JavaScript 及 Java 的選項能夠選擇，考量到學習的難易度與學習資源取得的容易度，就選了 JavaScript 了，其中考量到 JavaScript 的原因還有就是公司是有需要驗證 Web 上面顯示資料正確性的需求，所以如果學會了 JavaScript ，就可以 JavaScript 實作一些工具直接在 console 上執行來協助測試。</p>
<h2 id="測試框架選擇"><a href="#測試框架選擇" class="headerlink" title="測試框架選擇"></a>測試框架選擇</h2><p>接下來就可以找 JavaScript 在 2021 的統計，可以參考<a target="_blank" rel="noopener" href="https://2021.stateofjs.com/en-US/">這個網站</a>，可以從圖表看到使用率最高的是 Jest。</p>
<p><img src="/img/2022-223559/1665066647.png.png"></p>
<p>使用率最高不代表他就是一個值得讓人使用的框架，所以再次參考了「時間推移體驗」這個數據，也可以觀察到 Jest 是一個會讓人願意再次使用的框架。</p>
<p><img src="/img/2022-223559/1665066655.png.png"></p>
<p>所以依照上面的數據，問了幾個身邊的朋友，得到的回饋也是好的，所以就選擇了 Jest 作為這次實作自動化的框架。</p>
<h2 id="Modules-的分層"><a href="#Modules-的分層" class="headerlink" title="Modules 的分層"></a>Modules 的分層</h2><p>為了解決 Postman 所遇到的痛點，所以我們需要</p>
<ul>
<li>tests 層<ul>
<li>使用其他 modules 來組成 test case 的地方</li>
</ul>
</li>
<li>request API 的部分要抽成 apis 的 module</li>
<li>request payloads 的部分要抽成 requestPayloads 的 module</li>
<li>有一些需要共用的 lib 抽成 common 的 module</li>
</ul>
<p>相依的關係可以畫成這個樣子</p>
<p><img src="/img/2022-223559/1665066676.png.png"></p>
<p>資料夾結構如下</p>
<pre><code>├─apis
│      apis1.js
│      apis2.js
│      api/&#123;.../&#125;.js
│      index.js
│      requestHelper.js
├─common
│      jestExtend.js
│          
├─requestPayloads
│      apis1Request.js
│      apis2Request.js
│      apis/&#123;.../&#125;Request.js
│      index.js
│      
└─tests
    │   singleApi1.test.js
    │   singleApi2.test.js
    │   singleApi/&#123;.../&#125;.test.js
    │      
    └─stories
           stories.test.js
</code></pre>
<h2 id="各個-Modules-的介紹與實作"><a href="#各個-Modules-的介紹與實作" class="headerlink" title="各個 Modules 的介紹與實作"></a>各個 Modules 的介紹與實作</h2><h3 id="requestPayloads-資料夾"><a href="#requestPayloads-資料夾" class="headerlink" title="requestPayloads 資料夾"></a>requestPayloads 資料夾</h3><p>requestPayloads 資料夾中的 indejx.js 是用來統整各個 API 的預設 request payloads</p>
<pre><code>const apis1= require(&#39;./apis1Request&#39;);
const apis2= require(&#39;./apis2Request&#39;);

module.exports = /&#123;
  apis1,
  apis2,
/&#125;;
</code></pre>
<p>預設 request payloads 的定義為：Server 不會回應「lack of fields response」的 payload</p>
<p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis1Request.js 內容就會如下：</p>
<pre><code>const products = /&#123;
  product_id: 1,
  product_info: /&#123;
    product_name: &#39;Car Engine&#39;,
  /&#125;,
/&#125;;

module.exports = /&#123;
  products,
/&#125;;
</code></pre>
<p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 4 行）</p>
<pre><code>const apis = require(&#39;../apis&#39;);
const requestPayloads = require(&#39;../requestPayloads&#39;);

const apis1ProductsRequest = requestPayloads.apis1.products;
const result = await apis.apis1.products(apis1ProductsRequest );
expect(result.productName).toBe(&#39;something that expected product name&#39;);
</code></pre>
<h3 id="apis-資料夾"><a href="#apis-資料夾" class="headerlink" title="apis 資料夾"></a>apis 資料夾</h3><p>apis 資料夾中的 index.js 是用來統整 apis1, apis2…等 api 的地方</p>
<pre><code>const apis1 = require(&#39;./apis1&#39;);
const apis2 = require(&#39;./apis2&#39;);

module.exports = /&#123;
  apis1,
  apis2,
/&#125;;
</code></pre>
<p>apis 資料夾中的 requestHelper.js 是用來管理 request API 的 HTTP method 的一層，如 get, post 等 在這一層會與 report 那一層作結合，多讓 jest 的 report 多帶一些在打 api request 的相關結果 程式碼單純以 post 為例子</p>
<pre><code>const axios = require(&#39;axios&#39;);

/**
 * @param /&#123;string/&#125; baseURL for base URL
 * @param /&#123;object/&#125; headers for request headers
 * @param /&#123;object/&#125; data for request payload
 */
async function postRequest(baseURL, headers, data) /&#123;
  const result = await axios(/&#123;
    method: &#39;post&#39;,
    url: baseURL,
    headers: headers,
    data: data,
  /&#125;)
      .then((result) =&gt; /&#123;
        return result;
      /&#125;)
      .catch((err) =&gt; /&#123;
        console.log(err);
      /&#125;);
  return result;
/&#125;

module.exports = /&#123;
  postRequest,
/&#125;;
</code></pre>
<p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis.js 中則會引用到 requestHelper.js 來 request API，apis.js code 如下</p>
<pre><code>const /&#123;postRequest/&#125; = require(&#39;./requestHelper&#39;);
require(&#39;dotenv&#39;).config();
/**
 * @param /&#123;object/&#125; request payload
 * @return /&#123;object/&#125; response
 */
**async function products(data) /&#123;
  const result = await postRequest(
      `$/&#123;configs.BASE_URL/&#125;/apis1/products`,
      /&#123;
        &#39;x-api-key&#39;: process.env.API_KEY,
        &#39;content-type&#39;: &#39;application/json&#39;,
      /&#125;,
      data,
  );
  return result;
/&#125;**
</code></pre>
<p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 5 行）</p>
<pre><code>const apis = require(&#39;../apis&#39;);
const requestPayloads = require(&#39;../requestPayloads&#39;);

const apis1ProductsRequest = requestPayloads.apis1.products;
const result = await apis.apis1.products(apis1ProductsRequest );
expect(result.productName).toBe(&#39;something that expected product name&#39;);
</code></pre>
<h3 id="common-資料夾"><a href="#common-資料夾" class="headerlink" title="common 資料夾"></a>common 資料夾</h3><p>這一層主要是放一些官方沒有提供的 library 實作，或是共用的 function，以 jest 沒有提供的 object contain 為例，就會新增 jestExtend.js，其 code 如下，在 scenario API test 中將會用到。</p>
<pre><code>expect.extend(/&#123;
  toContainObject(received, argument) /&#123;
    const pass = this.equals(
        received,
        expect.arrayContaining([expect.objectContaining(argument)]),
    );

    if (pass) /&#123;
      return /&#123;
        message: () =&gt;
          `expected $/&#123;this.utils.printReceived(
              received,
          )/&#125; not to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,
        pass: true,
      /&#125;;
    /&#125; else /&#123;
      return /&#123;
        message: () =&gt;
          `expected $/&#123;this.utils.printReceived(
              received,
          )/&#125; to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,
        pass: false,
      /&#125;;
    /&#125;
  /&#125;,
/&#125;);
</code></pre>
<h3 id="tests-資料夾"><a href="#tests-資料夾" class="headerlink" title="tests 資料夾"></a>tests 資料夾</h3><p>這一層就是 Jest 的使用層了，會在這一層中使用各個 modules 來組成 test case。</p>
<p>API 測試種類大致上可以分成兩種</p>
<ul>
<li>單一 API 測試 (Single API test)</li>
<li>API 情境測試 (Scenario API test)</li>
</ul>
<p>單一 API 測試是指純粹只有這隻 API 是受測項目，完成測試的條件與其他 API 無關，是一個只需要使用單一一個 API 的測試項目，舉例來說 &#x2F;products API，帶給他 payload，其中會 lack fields，或是沒有帶 header，就稱之為 single API test。</p>
<p>API 情境測試是指要完成一個測試情境而需要用到多個 API，這裡就會需要引用到多個不同的 API 來達成某種目的，舉例來說 call &#x2F;prodcuts&#x2F;update 更新一個 product 然後再透過 &#x2F;products API 來取得預期被更新的 API，這邊就會引用到兩隻 API，這時候就稱之為 API 的情境測試。</p>
<p>Single API test，以 &#x2F;products API 為例子，其 code 如下</p>
<pre><code>const apis = require(&#39;../apis&#39;);

test(&#39;Get products, should return 200&#39;, async () =&gt; /&#123;
  const result = await apis.products.get();
  expect(result.status).toBe(200);
/&#125;);
</code></pre>
<p>Scenario API test，以 &#x2F;products, &#x2F;products&#x2F;create 為例子，其 code 如下</p>
<pre><code>require(&#39;../../common/jestExtend&#39;);
const apis = require(&#39;../../apis&#39;);
const requestPayloads = require(&#39;../../requestPayloads&#39;);

test(&#39;Create product, should get the product at /products&#39;, async () =&gt; /&#123;
  const createResult = await apis.products.create(
      requestPayloads.products.create,
  );
  expect(createResult.status).toBe(200);

  const result = await apis.products.get();

  expect(result.data).toContainObject(requestPayloads.products.create);
/&#125;);
</code></pre>
<h2 id="結語和本篇沒提到的事"><a href="#結語和本篇沒提到的事" class="headerlink" title="結語和本篇沒提到的事"></a>結語和本篇沒提到的事</h2><p>在這一篇中沒提到的有以下幾個事情</p>
<ul>
<li>json schema 的 validate</li>
<li>config</li>
</ul>
<p>依照目前的架構要擴充這兩件事情都可以很輕鬆，所以就沒有額外再寫出來記錄了</p>
<p>以上就是這一次整個 API automation 的思考與選擇的筆記<br>感謝各位大大看到這裡，如果有任何建議都可以跟我說，感謝 &lt;(_ _)&gt;</p>
<p>再次附上 repo: <a target="_blank" rel="noopener" href="https://github.com/SQZ777/jest-for-api-automation-template">SQZ777&#x2F;jest-for-api-automation-template (github.com)</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/06/04/hello-world/" title="Hello World"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一頁: Hello World</span></a><a class="button is-default" href="/2022/02/25/2022-180145/" title="Prettier ESLint 出現的錯誤：Error: r is not a constructor"><span class="has-text-weight-semibold">下一頁: Prettier ESLint 出現的錯誤：Error: r is not a constructor</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="SQZ777/sqz777-blog" src="https://utteranc.es/client.js" issue-term="title" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/sqz777"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> sqz777 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>