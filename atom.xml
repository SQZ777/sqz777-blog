<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SQZ777&#39;s blog</title>
  
  
  <link href="https://sqz777.github.io/atom.xml" rel="self"/>
  
  <link href="https://sqz777.github.io/"/>
  <updated>2024-06-08T17:33:08.630Z</updated>
  <id>https://sqz777.github.io/</id>
  
  <author>
    <name>SQZ777</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 ChatGPT 進行部落格文章搬遷的我會被 AI 取代嗎?</title>
    <link href="https://sqz777.github.io/2024/06/08/2024-migrate-blog-by-chatgpt/"/>
    <id>https://sqz777.github.io/2024/06/08/2024-migrate-blog-by-chatgpt/</id>
    <published>2024-06-08T22:46:45.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-migrate-blog-by-chatgpt/image0.png"><br>圖是使用<a href="https://memes.tw/">梗圖產生器</a>產生的</p><p>最近自己使用了 ChatGPT 進行部落格文章的搬遷<br>搬站的原因很膚淺，想知道的話再去<a href="https://sqz777.com/about/">關於我</a>看，就不多做贅述 🤣<br>原本這篇只是單純想記錄搬遷的過程，但剛好最近社團討論很熱烈就把文章的撰寫方式稍微改變一下<br>讓這篇可以更符合社團最近討論度很高的主題： </p><blockquote><p>因為 AI 的出現，工程師會不會失業?</p></blockquote><h3 id="本文使用的-ChatGPT-模型是-GPT-4o"><a href="#本文使用的-ChatGPT-模型是-GPT-4o" class="headerlink" title="本文使用的 ChatGPT 模型是 GPT-4o"></a>本文使用的 ChatGPT 模型是 GPT-4o</h3><hr><h2 id="正文開始，我的第一步是拆分需求"><a href="#正文開始，我的第一步是拆分需求" class="headerlink" title="正文開始，我的第一步是拆分需求"></a>正文開始，我的第一步是拆分需求</h2><p>需求很簡單</p><ul><li>提供 URL 將部落格的文章內容轉成 markdown</li><li>取得舊部落格的所有文章 URL</li><li>讓第一個需求可以批次處理</li></ul><p>這種一次性的 script，就不考慮維護性了<br>所以基本上所有 code 都讓 ChatGPT 產生再做細節的調整就好</p><h2 id="第二步，描述需求讓-ChatGPT-產生程式碼"><a href="#第二步，描述需求讓-ChatGPT-產生程式碼" class="headerlink" title="第二步，描述需求讓 ChatGPT 產生程式碼"></a>第二步，描述需求讓 ChatGPT 產生程式碼</h2><p>直接讓 ChatGPT 幫我產生一段關於文章內容轉成 markdown 的 Node.js Code</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image1.png"></p><p>以下是 ChatGPT 產生的 Node.js Code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&#x27;axios&#x27;);</span><br><span class="line">const cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">const URL = &#x27;https://dotblogs.azurewebsites.net/Im_sqz777/2022/10/06/223559&#x27;;</span><br><span class="line"></span><br><span class="line">axios.get(URL)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    const html = response.data;</span><br><span class="line">    const $ = cheerio.load(html);</span><br><span class="line"></span><br><span class="line">    // 假設文章內容在 class 為 &#x27;post-content&#x27; 的元素中</span><br><span class="line">    const postContent = $(&#x27;.post-content&#x27;).html();</span><br><span class="line"></span><br><span class="line">    if (!postContent) &#123;</span><br><span class="line">      throw new Error(&#x27;未能找到文章內容，請檢查選擇器是否正確&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 將 HTML 轉換為 Markdown 格式</span><br><span class="line">    const markdownContent = convertToMarkdown(postContent);</span><br><span class="line"></span><br><span class="line">    // 將 Markdown 內容寫入文件</span><br><span class="line">    fs.writeFileSync(&#x27;article.md&#x27;, markdownContent);</span><br><span class="line">    console.log(&#x27;文章已成功轉換為 Markdown 格式並儲存至 article.md&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;發生錯誤:&#x27;, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">function convertToMarkdown(html) &#123;</span><br><span class="line">  // 這裡使用 turndown 庫來轉換 HTML 為 Markdown</span><br><span class="line">  const TurndownService = require(&#x27;turndown&#x27;);</span><br><span class="line">  const turndownService = new TurndownService();</span><br><span class="line"></span><br><span class="line">  return turndownService.turndown(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步，修正-ChatGPT-的程式碼"><a href="#第三步，修正-ChatGPT-的程式碼" class="headerlink" title="第三步，修正 ChatGPT 的程式碼"></a>第三步，修正 ChatGPT 的程式碼</h2><p>我發現了 ChatGPT 提供的 code 中有一個「假設」</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 假設文章內容在 class 為 &#x27;post-content&#x27; 的元素中</span><br><span class="line">const postContent = $(&#x27;.post-content&#x27;).html();</span><br></pre></td></tr></table></figure><p>這一個假設讓我需要回到文章的頁面中找到文章內容的 class 為 <code>article__content</code>，如圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image2.png"></p><p>將 <code>.post-content</code> 取代為 <code>.article__content</code> 了之後執行程式碼</p><blockquote><p>記得在<code>article__content</code>前面加上點: <code>.</code></p></blockquote><p>驗證產生出來的 markdown 有幾個小問題</p><ol><li>舊文章日期&#x2F;標籤&#x2F;標題，沒有被寫進我預期的格式中</li><li>檔案名稱是寫死的，舊文章產生的檔案名稱應該依照文章年份及對應名稱</li></ol><h2 id="第四步，修正小問題，讓-ChatGPT-重新產生程式碼"><a href="#第四步，修正小問題，讓-ChatGPT-重新產生程式碼" class="headerlink" title="第四步，修正小問題，讓 ChatGPT 重新產生程式碼"></a>第四步，修正小問題，讓 ChatGPT 重新產生程式碼</h2><p>依照小問題 1，我需要道舊文章中找到文章對應的標題&#x2F;標籤&#x2F;日期的 html，然後產生 prompt 讓 GPT 幫我改 code<br>prompt 如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image3.png"></p><p>避免文章太長，就不貼 GPT 產生的 code 了<br>接著再解小問題 2<br>這個問題很簡單，直接讓 GPT 修正並且改掉先前提到的文章內容 class 的問題</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image4.png"></p><p>小問題解完之後，執行了 script，確認 markdown 可以被 hexo 解析就可以進到下一步了</p><h2 id="第四步，讓-URL-可以批次輸入"><a href="#第四步，讓-URL-可以批次輸入" class="headerlink" title="第四步，讓 URL 可以批次輸入"></a>第四步，讓 URL 可以批次輸入</h2><p>為了讓舊站的連結可以透過 git 記錄，所以決定透過檔案的方式來進行批次處理<br>這樣一來我有紀錄的同時又可以透過檔案來進行文章的轉換，prompt 如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image5.png"></p><p>在檔案中隨便貼上兩個舊站的文章測試一下，確認沒問題之後就往下一步</p><h2 id="第五步，取得舊站所有文章的-URL"><a href="#第五步，取得舊站所有文章的-URL" class="headerlink" title="第五步，取得舊站所有文章的 URL"></a>第五步，取得舊站所有文章的 URL</h2><p>在舊站首頁中可以觀測到 title 的 class 為 <code>article__title</code><br>然後可以在 URL 觀測到頁面會因為尾數不同而換頁，URL 如下</p><blockquote><p><a href="https://dotblogs.com.tw/Im_sqz777/1">https://dotblogs.com.tw/Im_sqz777/1</a> &lt;&lt; 這個 1 就是頁數</p></blockquote><p>我們就可依照這個狀況產生對應的 prompt:</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image6.png"></p><p>產生的程式碼如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&#x27;axios&#x27;);</span><br><span class="line">const cheerio = require(&#x27;cheerio&#x27;);</span><br><span class="line"></span><br><span class="line">async function fetchArticleTitles(variable) &#123;</span><br><span class="line">    const url = `https://dotblogs.com.tw/Im_sqz777/$&#123;variable&#125;`;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        const &#123; data &#125; = await axios.get(url);</span><br><span class="line">        const $ = cheerio.load(data);</span><br><span class="line"></span><br><span class="line">        // 選擇所有 class 為 article__title 的元素</span><br><span class="line">        $(&#x27;.article__title a&#x27;).each((index, element) =&gt; &#123;</span><br><span class="line">            const titleUrl = $(element).attr(&#x27;href&#x27;);</span><br><span class="line">            console.log(titleUrl);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(`Error fetching data from $&#123;url&#125;:`, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代變數 1 到 8</span><br><span class="line">for (let i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">    fetchArticleTitles(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著執行產生的程式碼會發現他並沒有符合我們的需求，如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image7.png"></p><p>我們的需求是需要讓 text file 中描述 URL，所以只需要在第 14 行加入 <code>&#39;https://dotblogs.com.tw/&#39; + </code> 就可以了<br>執行結果如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image8.png"></p><h2 id="第六步，修復-hexo-解析的問題"><a href="#第六步，修復-hexo-解析的問題" class="headerlink" title="第六步，修復 hexo 解析的問題"></a>第六步，修復 hexo 解析的問題</h2><p>接著就會發現 hexo 解析的 2 個錯誤</p><ol><li>title 格式的問題<br><img src="/img/2024-migrate-blog-by-chatgpt/image9.png"></li><li>舊文中出現大括弧 <code>&#123;&#125;</code> 時的解析問題</li></ol><p>title 的格式問題很簡單，在原程式碼中的 title 中加入單引號即可，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#x27;$&#123;title&#125;&#x27;</span><br><span class="line">date: $&#123;date&#125;</span><br><span class="line">tags: </span><br><span class="line">$&#123;tags.map(tag =&gt; `  - $&#123;tag&#125;`).join(&#x27;\n&#x27;)&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>第 2 個問題直接讓 ChatGPT 解決</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image10.png"><br>但是 ChatGPT 提供的程式碼有問題，關鍵程式碼如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 替換文章內容中的 &#123; 和 &#125; 字符</span><br><span class="line">markdownContent = markdownContent.replace(/(&#123;|&#125;)/g, &#x27;\\$1&#x27;);</span><br></pre></td></tr></table></figure><p>我預期和描述的 prompt 斜線是 <code>/</code>，但 ChatGPT 睜眼說瞎話的寫成了 <code>\</code>，改掉之後確認解析沒問題後</p><p>還剩下一個細節的需求，是一開始需求分析時沒有寫到的:</p><ul><li>圖片應該要下載下來，並且在 markdown 中顯示</li></ul><p>但這一段 ChatGPT 完美的解決了我的問題，所以就不記錄了，想要看最後的程式碼的話可以到 Github 上看<br>連結附上</p><ul><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/dotblogTurnMarkdown.js">DotBlogs 文章轉 markdown</a></li><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/getDotblogPostsURLs.js">取得 DotBlogs 的文章 URLs</a></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>總結一下透過 ChatGPT 搬遷 blogs 文章會需要的技能</p><ol><li>知道網站相關的知識<ul><li>知道在程式碼中描述 class 前面要加上 <code>.</code></li><li>知道 URL 中哪個值是對應頁數</li></ul></li><li>知道如何使用 Chrome 的開發者工具</li><li>知道 regex 的組成</li><li>知道錯誤訊息怎麼看<ul><li>如何快速定位哪一篇是發生錯誤的文章</li></ul></li><li>知道 hexo 解析錯誤的原因<ul><li>在 {} 前要加上 <code>/</code> 而非 <code>\\</code></li><li>在標題中出現 <code>&#39;</code> 要在 script 中針對標題兩側加上 <code>&#39;</code></li></ul></li><li>…之後想到再補充</li></ol><p>以上程式碼的內容，要我自己寫是完全沒問題，有 AI 之後<br>原本可能要花 1 小時左右的時間，最後壓縮成 20 分鐘內甚至更短就解決了<br>依照今天這樣子的搬遷紀錄來看，我應該還不至於被「純粹的 AI 工具」或是「無基礎但使用 AI 工具的人」取代</p><p>不過要注意的是那些努力且能夠善用 AI 工具的人，這些人的生產力可能會是 AI 出現前的好幾倍</p><p>不說了，我要睡了，明早再修這個 blog theme 程式碼會置中的問題了 🙈🙈🙈<br>感謝大家收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-migrate-blog-by-chatgpt/image0.png&quot;&gt;&lt;br&gt;圖是使用&lt;a href=&quot;https://memes.tw/&quot;&gt;梗圖產生器&lt;/a&gt;產生的&lt;/p&gt;
&lt;p&gt;最近自己使用了 ChatGPT 進行部落格文章的搬</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>更改 Chrome 時區的方法</title>
    <link href="https://sqz777.github.io/2024/06/06/2024-how-to-change-time-zone-in-chrome/"/>
    <id>https://sqz777.github.io/2024/06/06/2024-how-to-change-time-zone-in-chrome/</id>
    <published>2024-06-06T22:29:10.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-how-to-change-time-zone-in-chrome/image.png" alt="checkTimeZone"></p><p>最近測試時遇到驗證不同時區狀況的需求</p><p>直覺上認為開啟 VPN 或是更改電腦的設定是不合理的<br>所以嘗試找看看 Chrome 有沒有辦法更改 Chrome 自身的時區設定<br>然後就讓我找到了 <a href="https://developer.chrome.com/docs/devtools/settings/locations?hl=zh-tw">Chrome 的文件</a> !</p><h2 id="設定前確認時區"><a href="#設定前確認時區" class="headerlink" title="設定前確認時區"></a>設定前確認時區</h2><p>更改之前，透過 F12 的 Console 來確認當前的時區</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image1.png" alt="checkTimeZone"></p><h2 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h2><p>於右上角三個點 &gt; More tools &gt; Sensors</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image2.png" alt="settingLocation"></p><p>接著在下方的 Sensors tab 就可以找到複寫 Location 的設定，我們這裡選擇 Tokyo</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image3.png" alt="settingLocation"></p><h2 id="確認結果"><a href="#確認結果" class="headerlink" title="確認結果"></a>確認結果</h2><p>在 Console 中確認時區是否已被覆寫</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image4.png" alt="settingLocation"></p><p>這樣就可以完成時區的修改啦!<br>當前端會根據 Chrome 本身設定的時區進行時區顯示上的修改時，就會需要用到這一個 Chrome 的覆寫時區功能了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-how-to-change-time-zone-in-chrome/image.png&quot; alt=&quot;checkTimeZone&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近測試時遇到驗證不同時區狀況的需求&lt;/p&gt;
&lt;p&gt;直覺上認為開啟 VPN 或是更改電腦</summary>
      
    
    
    
    
    <category term="Chrome" scheme="https://sqz777.github.io/tags/Chrome/"/>
    
    <category term="時區" scheme="https://sqz777.github.io/tags/%E6%99%82%E5%8D%80/"/>
    
  </entry>
  
  <entry>
    <title>API 自動化的技術選擇與 Modules 的分層思考</title>
    <link href="https://sqz777.github.io/2022/10/06/2022-223559/"/>
    <id>https://sqz777.github.io/2022/10/06/2022-223559/</id>
    <published>2022-10-06T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。</p><p><a href="https://github.com/SQZ777/jest-for-api-automation-template.git">https://github.com/SQZ777/jest-for-api-automation-template.git</a></p><p>各個 subtitle 如下</p><ul><li>為何不使用 Postman 來做 API Automation</li><li>語言選擇</li><li>測試框架選擇</li><li>Modules 的分層</li><li>各個 Modules 的介紹與實作</li><li>結語和本篇沒提到的事</li></ul><p>首先在使用程式碼撰寫 API 自動化的測試案例時，一定會先遇到這個問題</p><h2 id="為何不使用-Postman-來做-API-Automation？"><a href="#為何不使用-Postman-來做-API-Automation？" class="headerlink" title="為何不使用 Postman 來做 API Automation？"></a>為何不使用 Postman 來做 API Automation？</h2><p><img src="/img/2022-223559/1665066616.png.png"></p><p>所以就先來列一下 Postman 的優&#x2F;缺點吧</p><p>優點如下</p><ul><li>UI 介面容易使用，門檻極低</li><li>可以透過 JavaScript 來實作檢查 response 的 script</li><li>各個平台（Mac, Windows）都可以使用</li><li>可以透過 newman（CLI）來建置 CI 的流程</li></ul><p>接著列一下使用 Postman 執行管理自動化案例會遇到的問題</p><ul><li>大量自動化案例會產生極大的維護成本<ul><li>無法重用的 test script</li><li>受測 API 如果新增 required fields，會需要手動更新大量既有的 script</li></ul></li><li>執行 collection runner 再透過 csv 檔案來匯入測試資料的過程過於繁瑣</li></ul><p>Postman 在實作小型的 API 驗證時，是一個非常好用的工具，但需要實作大量 API 測試案例時，在 Postman 上管理這些案例會產生很大的維護成本，不信的話你可以試試，所以我們需要透過撰寫程式的方式來管理這些即將被實作的 API 測試案例。</p><h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>首先要選擇的是語言，依照公司內部現有的技術而選，策略是以不增加公司同事之間跨越職能障礙為主要目標，其次是這個語言的資源，再其次是學習的門檻，因為有尚未開發過自動化的 QA ，所以選擇語言起手的難易度也需要列為考量。</p><p><img src="/img/2022-223559/1665066630.png.png"></p><p>抱歉了 Java XD</p><p>公司內部的 backend 是 Java，而 front-end 則是 Vue.js，所以就剩下 JavaScript 及 Java 的選項能夠選擇，考量到學習的難易度與學習資源取得的容易度，就選了 JavaScript 了，其中考量到 JavaScript 的原因還有就是公司是有需要驗證 Web 上面顯示資料正確性的需求，所以如果學會了 JavaScript ，就可以 JavaScript 實作一些工具直接在 console 上執行來協助測試。</p><h2 id="測試框架選擇"><a href="#測試框架選擇" class="headerlink" title="測試框架選擇"></a>測試框架選擇</h2><p>接下來就可以找 JavaScript 在 2021 的統計，可以參考<a href="https://2021.stateofjs.com/en-US/">這個網站</a>，可以從圖表看到使用率最高的是 Jest。</p><p><img src="/img/2022-223559/1665066647.png.png"></p><p>使用率最高不代表他就是一個值得讓人使用的框架，所以再次參考了「時間推移體驗」這個數據，也可以觀察到 Jest 是一個會讓人願意再次使用的框架。</p><p><img src="/img/2022-223559/1665066655.png.png"></p><p>所以依照上面的數據，問了幾個身邊的朋友，得到的回饋也是好的，所以就選擇了 Jest 作為這次實作自動化的框架。</p><h2 id="Modules-的分層"><a href="#Modules-的分層" class="headerlink" title="Modules 的分層"></a>Modules 的分層</h2><p>為了解決 Postman 所遇到的痛點，所以我們需要</p><ul><li>tests 層<ul><li>使用其他 modules 來組成 test case 的地方</li></ul></li><li>request API 的部分要抽成 apis 的 module</li><li>request payloads 的部分要抽成 requestPayloads 的 module</li><li>有一些需要共用的 lib 抽成 common 的 module</li></ul><p>相依的關係可以畫成這個樣子</p><p><img src="/img/2022-223559/1665066676.png.png"></p><p>資料夾結構如下</p><pre><code>├─apis│      apis1.js│      apis2.js│      api/&#123;.../&#125;.js│      index.js│      requestHelper.js├─common│      jestExtend.js│          ├─requestPayloads│      apis1Request.js│      apis2Request.js│      apis/&#123;.../&#125;Request.js│      index.js│      └─tests    │   singleApi1.test.js    │   singleApi2.test.js    │   singleApi/&#123;.../&#125;.test.js    │          └─stories           stories.test.js</code></pre><h2 id="各個-Modules-的介紹與實作"><a href="#各個-Modules-的介紹與實作" class="headerlink" title="各個 Modules 的介紹與實作"></a>各個 Modules 的介紹與實作</h2><h3 id="requestPayloads-資料夾"><a href="#requestPayloads-資料夾" class="headerlink" title="requestPayloads 資料夾"></a>requestPayloads 資料夾</h3><p>requestPayloads 資料夾中的 indejx.js 是用來統整各個 API 的預設 request payloads</p><pre><code>const apis1= require(&#39;./apis1Request&#39;);const apis2= require(&#39;./apis2Request&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>預設 request payloads 的定義為：Server 不會回應「lack of fields response」的 payload</p><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis1Request.js 內容就會如下：</p><pre><code>const products = /&#123;  product_id: 1,  product_info: /&#123;    product_name: &#39;Car Engine&#39;,  /&#125;,/&#125;;module.exports = /&#123;  products,/&#125;;</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 4 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="apis-資料夾"><a href="#apis-資料夾" class="headerlink" title="apis 資料夾"></a>apis 資料夾</h3><p>apis 資料夾中的 index.js 是用來統整 apis1, apis2…等 api 的地方</p><pre><code>const apis1 = require(&#39;./apis1&#39;);const apis2 = require(&#39;./apis2&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>apis 資料夾中的 requestHelper.js 是用來管理 request API 的 HTTP method 的一層，如 get, post 等 在這一層會與 report 那一層作結合，多讓 jest 的 report 多帶一些在打 api request 的相關結果 程式碼單純以 post 為例子</p><pre><code>const axios = require(&#39;axios&#39;);/** * @param /&#123;string/&#125; baseURL for base URL * @param /&#123;object/&#125; headers for request headers * @param /&#123;object/&#125; data for request payload */async function postRequest(baseURL, headers, data) /&#123;  const result = await axios(/&#123;    method: &#39;post&#39;,    url: baseURL,    headers: headers,    data: data,  /&#125;)      .then((result) =&gt; /&#123;        return result;      /&#125;)      .catch((err) =&gt; /&#123;        console.log(err);      /&#125;);  return result;/&#125;module.exports = /&#123;  postRequest,/&#125;;</code></pre><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis.js 中則會引用到 requestHelper.js 來 request API，apis.js code 如下</p><pre><code>const /&#123;postRequest/&#125; = require(&#39;./requestHelper&#39;);require(&#39;dotenv&#39;).config();/** * @param /&#123;object/&#125; request payload * @return /&#123;object/&#125; response */**async function products(data) /&#123;  const result = await postRequest(      `$/&#123;configs.BASE_URL/&#125;/apis1/products`,      /&#123;        &#39;x-api-key&#39;: process.env.API_KEY,        &#39;content-type&#39;: &#39;application/json&#39;,      /&#125;,      data,  );  return result;/&#125;**</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 5 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="common-資料夾"><a href="#common-資料夾" class="headerlink" title="common 資料夾"></a>common 資料夾</h3><p>這一層主要是放一些官方沒有提供的 library 實作，或是共用的 function，以 jest 沒有提供的 object contain 為例，就會新增 jestExtend.js，其 code 如下，在 scenario API test 中將會用到。</p><pre><code>expect.extend(/&#123;  toContainObject(received, argument) /&#123;    const pass = this.equals(        received,        expect.arrayContaining([expect.objectContaining(argument)]),    );    if (pass) /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; not to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: true,      /&#125;;    /&#125; else /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: false,      /&#125;;    /&#125;  /&#125;,/&#125;);</code></pre><h3 id="tests-資料夾"><a href="#tests-資料夾" class="headerlink" title="tests 資料夾"></a>tests 資料夾</h3><p>這一層就是 Jest 的使用層了，會在這一層中使用各個 modules 來組成 test case。</p><p>API 測試種類大致上可以分成兩種</p><ul><li>單一 API 測試 (Single API test)</li><li>API 情境測試 (Scenario API test)</li></ul><p>單一 API 測試是指純粹只有這隻 API 是受測項目，完成測試的條件與其他 API 無關，是一個只需要使用單一一個 API 的測試項目，舉例來說 &#x2F;products API，帶給他 payload，其中會 lack fields，或是沒有帶 header，就稱之為 single API test。</p><p>API 情境測試是指要完成一個測試情境而需要用到多個 API，這裡就會需要引用到多個不同的 API 來達成某種目的，舉例來說 call &#x2F;prodcuts&#x2F;update 更新一個 product 然後再透過 &#x2F;products API 來取得預期被更新的 API，這邊就會引用到兩隻 API，這時候就稱之為 API 的情境測試。</p><p>Single API test，以 &#x2F;products API 為例子，其 code 如下</p><pre><code>const apis = require(&#39;../apis&#39;);test(&#39;Get products, should return 200&#39;, async () =&gt; /&#123;  const result = await apis.products.get();  expect(result.status).toBe(200);/&#125;);</code></pre><p>Scenario API test，以 &#x2F;products, &#x2F;products&#x2F;create 為例子，其 code 如下</p><pre><code>require(&#39;../../common/jestExtend&#39;);const apis = require(&#39;../../apis&#39;);const requestPayloads = require(&#39;../../requestPayloads&#39;);test(&#39;Create product, should get the product at /products&#39;, async () =&gt; /&#123;  const createResult = await apis.products.create(      requestPayloads.products.create,  );  expect(createResult.status).toBe(200);  const result = await apis.products.get();  expect(result.data).toContainObject(requestPayloads.products.create);/&#125;);</code></pre><h2 id="結語和本篇沒提到的事"><a href="#結語和本篇沒提到的事" class="headerlink" title="結語和本篇沒提到的事"></a>結語和本篇沒提到的事</h2><p>在這一篇中沒提到的有以下幾個事情</p><ul><li>json schema 的 validate</li><li>config</li></ul><p>依照目前的架構要擴充這兩件事情都可以很輕鬆，所以就沒有額外再寫出來記錄了</p><p>以上就是這一次整個 API automation 的思考與選擇的筆記<br>感謝各位大大看到這裡，如果有任何建議都可以跟我說，感謝 &lt;(_ _)&gt;</p><p>再次附上 repo: <a href="https://github.com/SQZ777/jest-for-api-automation-template">SQZ777&#x2F;jest-for-api-automation-template (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參</summary>
      
    
    
    
    
    <category term="Automation" scheme="https://sqz777.github.io/tags/Automation/"/>
    
    <category term="API" scheme="https://sqz777.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Prettier ESLint 出現的錯誤：Error: r is not a constructor</title>
    <link href="https://sqz777.github.io/2022/02/25/2022-180145/"/>
    <id>https://sqz777.github.io/2022/02/25/2022-180145/</id>
    <published>2022-02-25T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近做基礎建設踩到的雷</p><p>在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息</p><blockquote><p><strong>Error: r is not a constructor</strong></p></blockquote><p>目前在 github 上可以看到這個 issue ，而發生這個原因是因為目前 Prettier ESLint 還沒有支援到 eslint 8.0 以上，所以建議將版本降到 7.32.0，如圖</p><p><img src="/img/2022-180145/1645783122.png.png"></p><p><a href="https://github.com/idahogurl/vs-code-prettier-eslint/issues/26">官方的 GitHub issue</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做基礎建設踩到的雷&lt;/p&gt;
&lt;p&gt;在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Error: r is not a constructor&lt;/strong&gt;&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
    <category term="VSCode" scheme="https://sqz777.github.io/tags/VSCode/"/>
    
    <category term="vs-code-prettier-eslint" scheme="https://sqz777.github.io/tags/vs-code-prettier-eslint/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - Suite Setup V.S Test Setup</title>
    <link href="https://sqz777.github.io/2021/11/16/2021-224604/"/>
    <id>https://sqz777.github.io/2021/11/16/2021-224604/</id>
    <published>2021-11-16T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義</p><p>Test Setup</p><p><em><strong>a test setup is something that is executed before a test case, and a test teardown is executed after a test case.</strong></em></p><p>Suite Setup</p><p><em><strong>A suite setup is executed before any test cases or sub test suites in that test suite, and similarly a suite teardown is executed after them.</strong></em></p><p>原文連結：<a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#id594">Robot Framework User Guide #id594</a></p><p>簡單來說</p><ul><li>Test Setup 會在每次 case 開始前執行一次</li><li>Suite Setup 是 robot file 開始執行 test case 前執行一次</li></ul><p>Suite 單位為 .robot file<br>Test 的單位為 test case</p><p>廢話不多說，先上 code，Test Setup 的 code 如下</p><pre><code>*** Settings ***Test Setup    Log To Console    Setup in Test!*** Test Cases ***Test Setup 1    Log To Console    Test Case 1Test Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的 code 如下</p><pre><code>*** Settings ***Suite Setup    Log To Console   Setup in Suite!*** Test Cases ***Suite Setup 1    Log To Console    Test Case 1Suite Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073888.png"></p><p>Test Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073897.png"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從 Code 的執行結果來看，如果一個 robot file 中有多個 Test Case</p><ul><li>Suite Setup 只會被執行一次</li><li>Test Setup 會被執行多次</li></ul><p>以上為簡單的筆記，感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義&lt;/p&gt;
&lt;p&gt;Test Setup&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;a test setup is something that is executed before a test case, and a</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://sqz777.github.io/tags/RobotFramework/"/>
    
    <category term="SuiteSetup" scheme="https://sqz777.github.io/tags/SuiteSetup/"/>
    
    <category term="TestSetup" scheme="https://sqz777.github.io/tags/TestSetup/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 使用 config.ini 管理環境變數</title>
    <link href="https://sqz777.github.io/2021/11/08/2021-204911/"/>
    <id>https://sqz777.github.io/2021/11/08/2021-204911/</id>
    <published>2021-11-08T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.629Z</updated>
    
    <content type="html"><![CDATA[<p>這篇會介紹：</p><ul><li>為何要使用 config.ini</li><li>Variables 在 *** Settings ***</li><li>如何使用 config.ini</li></ul><p>安安 我來填坑了</p><p><img src="/img/2021-204911/1636375721.png"></p><h2 id="為什麼要使用-config-ini"><a href="#為什麼要使用-config-ini" class="headerlink" title="為什麼要使用 config.ini"></a>為什麼要使用 config.ini</h2><p>透過 config.ini 可以</p><ul><li>根據環境定義不同的環境變數</li><li>避免將機敏資料寫在程式碼中</li><li>避免第三方服務變更時，有大量的檔案需要被變更</li></ul><p>一般來說在開發任何的程式時都會有環境的區別，使用 config 檔案可以，除了環境的區別之外，還有不適合直接寫在程式碼中的資料例如：token、API 的 URL 等</p><h2 id="Variables-在-Settings"><a href="#Variables-在-Settings" class="headerlink" title="Variables 在 *** Settings ***"></a>Variables 在 *** Settings ***</h2><p>在知道如何使用 config.ini 之前須要先知道 Variables 在 Settings 中的作用是什麼</p><p>根據 <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variable-files">Robot Framework 的文件</a>可以看到 Variables 有兩種方式可以透過 .py 引入變數</p><ul><li>Getting variables directly from a module</li><li>Getting variables from a special function</li></ul><h3 id="Getting-variables-directly-from-a-module-的方式"><a href="#Getting-variables-directly-from-a-module-的方式" class="headerlink" title="Getting variables directly from a module 的方式"></a>Getting variables directly from a module 的方式</h3><p>官方定義：</p><p><em>Variables are specified as module attributes. In simple cases, the syntax is so simple that no real programming is needed. For example, creates a variable with the specified text as its value. One limitation of this approach is that it does not allow using arguments.MY_VAR &#x3D; ‘my value’$&#x2F;{MY_VAR&#x2F;}</em></p><p>以官方定義來說就可以直接看到這個方式的缺點就是沒有支援使用 arguments.MY_VAR 的方式使用變數</p><p>以範例來看使用這種方式的結果會是這樣</p><p>python 的程式碼：</p><pre><code>MY_NAME = &quot;SQZ777&quot;</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;_MY_NAME/&#125;</code></pre><p>執行結果就可以看到</p><p><img src="/img/2021-204911/1636374905.png"></p><h3 id="Getting-variables-from-a-special-function-的方法"><a href="#Getting-variables-from-a-special-function-的方法" class="headerlink" title="Getting variables from a special function 的方法"></a>Getting variables from a special function 的方法</h3><p>官方定義：</p><p><em>An alternative approach for getting variables is having a special function (also camelCase syntax is possible) in a variable file. If such a function exists, Robot Framework calls it and expects to receive variables as a Python dictionary or a Java with variable names as keys and variable values as values. Created variables can be used as scalars, lists, and dictionaries exactly like when getting variables directly from a module, and it is possible to use and prefixes to make creating list and dictionary variables more explicit. The example below is functionally identical to the first example related to getting variables directly from a module.get_variablesgetVariablesMapLIST__DICT__</em></p><p>簡單來說，透過這個方式就可以使變數有「環境」這一層的定義，除此之外還要注意的是，python 的檔案中要定義 function 的名稱為 <strong>get_variables</strong></p><p>直接來示範吧！</p><p>python 的程式碼：</p><pre><code>def get_variables():    var = &quot;BLOG_ENV.MY_NAME&quot;    variables = /&#123;/&#125;    variables[var] = &quot;SQZ777&quot;    return variables</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;BLOG_ENV.MY_NAME/&#125;</code></pre><p>在這裡就可以注意到我的變數已經可以隸屬於不同的環境了（BLOG_ENV 中的 MY_NAME）</p><h2 id="如何使用-config-ini"><a href="#如何使用-config-ini" class="headerlink" title="如何使用 config.ini"></a>如何使用 config.ini</h2><p>了解了兩種不同的引入環境變數的方式終於來到最後了解如何使用 config.ini 的部分啦！</p><p>透過 configparser 讀取 config.ini ，再將檔案中所有被定義好的變數回傳給 Robot Framework 就可以達成使用 config.ini 的方法</p><p>python 的程式碼：</p><pre><code>import configparserdef get_variables(config_path=&quot;./config.ini&quot;):    config = configparser.ConfigParser()    config.read(config_path)    variables = /&#123;/&#125;    print(config.sections)    for section in config.sections():        for key, value in config.items(section):            var = &quot;%s.%s&quot; % (section, key)            variables[var] = value    return variables</code></pre><p>config.ini 內容：</p><pre><code>[BLOG_ENV]MARVEL_URL = &lt;http://gateway.marvel.com/&gt;MARVEL_PUBLIC_KEY = 你的 public keyMARVEL_PRIVATE_KEY = 你的 private key</code></pre><p>在 robot 中使用 config，如下圖</p><p><img src="/img/2021-204911/1636374936.png"></p><p>在這裡就會出現一個疑問，這樣不就等於環境被寫死了嗎？</p><p><img src="/img/2021-204911/1636374948.png"></p><p>所以這邊為了讓使用上更方便，環境的定義可以透過 command line 來傳入，在執行 Robot Framework 時，代入參數，如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><p>而 .robot 的檔案則須要改成取用 ENV 這個在 command line 中傳入的變數。</p><p><img src="/img/2021-204911/1636374966.png"></p><p>這樣就能執行到指定的環境與變數囉!</p><p>感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇會介紹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為何要使用 config.ini&lt;/li&gt;
&lt;li&gt;Variables 在 *** Settings ***&lt;/li&gt;
&lt;li&gt;如何使用 config.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安安 我來填坑了&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    
    <category term="config" scheme="https://sqz777.github.io/tags/config/"/>
    
    <category term="RobotFramework" scheme="https://sqz777.github.io/tags/RobotFramework/"/>
    
    <category term="環境變數" scheme="https://sqz777.github.io/tags/%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 介紹一下</title>
    <link href="https://sqz777.github.io/2021/10/17/2021-191743/"/>
    <id>https://sqz777.github.io/2021/10/17/2021-191743/</id>
    <published>2021-10-17T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.629Z</updated>
    
    <content type="html"><![CDATA[<p>最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩</p><p>這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的</p><p><img src="/img/2021-191743/1634469178.png"></p><h2 id="介紹與使用場景"><a href="#介紹與使用場景" class="headerlink" title="介紹與使用場景"></a>介紹與使用場景</h2><p>Robot Framework 是一個基於 python 的 自動化框架，基本上可以用 python 達成的事情，Robot Framework 都可以做到，其應用的場景是 ATDD (Acceptance Test Driven Development)、BDD (Behavior Driven Development) 以及可以被機器化的流程。</p><p><img src="/img/2021-191743/1634469201.png"></p><h2 id="為何使用-Robot-Framework"><a href="#為何使用-Robot-Framework" class="headerlink" title="為何使用 Robot Framework?"></a>為何使用 Robot Framework?</h2><ul><li>學習資源易於取得</li><li>易於理解與學習的介面</li><li>已有豐富的 Keyword 可以使用</li></ul><p>Robot Framework 對於沒有程式基礎的人來說是「相對」易於理解的，因為他有最接近人類自然語言的介面讓人閱讀，在政治條件（？）上比較能夠說服他人使用這個工具。</p><p>你通常不太需要再自行開發 Keyword 就可以完成你需要執行的自動化流程，如果需要，你也能夠透過實作 Python 來完成你需要做的事。</p><h2 id="看懂-Robot-Framework"><a href="#看懂-Robot-Framework" class="headerlink" title="看懂 Robot Framework"></a>看懂 Robot Framework</h2><p>先來張圖，這張圖是 Robot Framework 的文件，紅框的部分：</p><p><img src="/img/2021-191743/1634469224.png"></p><h2 id="Settings"><a href="#Settings" class="headerlink" title="*** Settings ***"></a>*** Settings ***</h2><p>這裡是引入 library 以及初始化的地方</p><p><img src="/img/2021-191743/1634469248.png"></p><ul><li>如果你在別的 .robot 中定義好了需要被引入的 library 或是 Keywords 可以透過 Resource 來達成引入的動作</li><li>Suite Setup 則是在測試跑起來時會做的初始化動作</li></ul><p>這邊幫自己挖個坑，會再發一篇 Suite Setup 跟 Test Setup 的差別。<br>此坑已補上： <a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Robot Framework - Suite Setup V.S Test Setup | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a>  </p><p><img src="/img/2021-191743/1634469266.png"></p><p>看一下 settings.robot</p><p><img src="/img/2021-191743/1634469282.png"></p><p>會使用 settings.robot 來統一引入 library 的原因是為了避免 .robot 的檔案多了，每一個檔案都要重新引入那些 library 實在是麻煩，所以乾脆由一個 file 來控制需要被引入的 library，這樣簡單得多。<br>Variables 讓你可以直接透過檔案的形式讓你引入環境變數<br>Library 則是讓你可以引入 python 或是 Robot Framework 的 library<br>RequestsLibrary 是別人開發好的 Robot Framework 的 Library，需要使用以下指令安裝後才能使用，這個 library 可以讓我們省掉開發 Requests Keyword 的時間。</p><pre><code>python -m pip install robotframework-requests</code></pre><p><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html">RequestsLibrary Keyword 使用方法的文件點我</a></p><h2 id="Variables"><a href="#Variables" class="headerlink" title="*** Variables ***"></a>*** Variables ***</h2><p>這裡是定義這個檔案中會用到的常數</p><p><img src="/img/2021-191743/1634469327.png"></p><p>通常這裡的變數不會直接寫死在這裡，而是會在另一個檔案中定義 config.ini 之類的然後在透過變數來做取用</p><p>所以我這邊也是再挖一個坑，會再發一篇如何定義 config.ini 然後在 robot 裡面中引用那個環境變數<br>此坑已補上：<a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">Robot Framework - 使用 config.ini 管理環境變數 | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a></p><p><img src="/img/2021-191743/1634469353.png"></p><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="*** Keywords ***"></a>*** Keywords ***</h2><p>這裡是自定義關鍵字的地方，可以在這裡定義好關鍵字後，在 Test Case 中使用</p><p><img src="/img/2021-191743/1634469372.png"></p><p>Get Character With Beginning Of The Name，這個是 Keyword 的名稱</p><p>[Arguments] 讓 Keyword 被定義成是可以被傳入參數的，而這個參數名稱是 character_name，定義完成後即可在 Test Case 中使用</p><p>而 Keyword 再往下一層則是 python 的程式碼，以圖中行號 13 的 Get Md5 Hash 為例，這個 Get Md5 Hash 是我自行實作在 <a href="http://common.py/">common.py</a> 的一段 python code</p><p>P.S. <a href="http://common.py/">common.py</a> 已在 settings.robot 中引入。</p><pre><code>import hashlibdef get_md5_hash(data):    hasher = hashlib.md5()    hasher.update(data.encode(&quot;utf-8&quot;))    return hasher.hexdigest()</code></pre><p>以此為例，你可以使用 Get Md5 Hash 或是 get_md5_hash 都可以，只要文件內有統一的格式即可。</p><p>其他的 Keyword 對應官方文件有</p><ul><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Get%20Time">Get Time</a><br>可以指定格式取得 Datetime</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Create%20Dictionary">Create Dictionary</a><br>建立 Dictionary</li><li><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html#GET%20On%20Session">Get On Session</a><br>建立於 Session 上來 request 其方法為 Get</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Return%20From%20Keyword">Return From Keyword</a><br>Get Character With Beginning Of The Name 這一個 Keyword 即將返回的值</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal%20As%20Strings">Should Be Equal As Strings</a><br>斷言（Assert）兩個值的型態為 string 時會是相同的。</li></ul><h2 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="*** Test Cases ***"></a><strong>*** Test Cases ***</strong></h2><p>這裡是定義 Test Case 的地方，會透過使用 Keyword 來組合成需要被自動化的流程</p><p><img src="/img/2021-191743/1634469384.png"></p><h2 id="開發準備"><a href="#開發準備" class="headerlink" title="開發準備"></a><strong>開發準備</strong></h2><p>開發前要準備的就是環境啦</p><ul><li><p>python</p></li><li><p>python package: robotframework</p></li><li><p>python package: robotframework-requests</p><p>python -m pip install robotframework robotframework-requests</p></li></ul><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><p>package 安裝完成後，就可以開始寫一些需要自動化的項目了，開始寫之前先決定要做的自動化項目是什麼</p><ul><li>準備 request 過去 Marvel API 的 token 資訊，Marvel API 的 token 申請，可以參考 repo 中的 readme </li><li>透過 Marvel 的 API 取得角色名稱開頭為 “Tony” 的角色資訊</li><li>唯一一個角色開頭為 “Tony” 的人就是 Tony Stark 所以必須要能取得 Tony Stark 這個名字</li></ul><p>robot 的 Test Suite 如下</p><pre><code>*** Settings ***Resource    settings.robotSuite Setup    Create Session    MARVEL_API    $/&#123;$/&#123;ENV/&#125;.MARVEL_URL/&#125;*** Variables ***$/&#123;api_private_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PRIVATE_KEY/&#125;$/&#123;api_public_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PUBLIC_KEY/&#125;*** Keywords ***Get Character With Beginning Of The Name    [Arguments]    $/&#123;character_name/&#125;    $/&#123;timestamp/&#125;=    Get Time    epoch    $/&#123;hash/&#125;=    Get Md5 Hash    $/&#123;timestamp/&#125;$/&#123;api_private_key/&#125;$/&#123;api_public_key/&#125;    $/&#123;params/&#125;=    Create Dictionary    ts=$/&#123;timestamp/&#125;    apikey=$/&#123;api_public_key/&#125;    hash=$/&#123;hash/&#125;    nameStartsWith=$/&#123;character_name/&#125;    $/&#123;response/&#125;=    Get On Session    alias=MARVEL_API    url=/v1/public/characters    params=$/&#123;params/&#125;    expected_status=200    Return From Keyword    $/&#123;response/&#125;*** Test Cases ***Get Beginning With Tony&#39;s Character Name Info    $/&#123;result/&#125;=    Get Character With Beginning Of The Name    Tony    Should Be Equal As Strings    $/&#123;result.json()[&quot;data&quot;][&quot;results&quot;][0][&quot;name&quot;]/&#125;    Tony Stark</code></pre><h2 id="Repo-點我"><a href="#Repo-點我" class="headerlink" title="Repo 點我"></a><a href="https://github.com/SQZ777/robotframework-marvel">Repo 點我</a></h2><h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><p>若要執行指令如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><h2 id="執行中"><a href="#執行中" class="headerlink" title="執行中"></a>執行中</h2><p><img src="/img/2021-191743/1637074430.png"></p><h2 id="執行後"><a href="#執行後" class="headerlink" title="執行後"></a>執行後</h2><p>在執行後可以看到 Robot Framework 產出的 report</p><p><img src="/img/2021-191743/1637074439.png"></p><p>在 report 中可以看到執行的時間與成功數量等，除此之外，你也能夠透過 report 看見執行的細節，例如 API 的 response json、該步驟的執行時間等</p><p><img src="/img/2021-191743/1637074452.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這一篇介紹了為何要使用 Robot Framework，再到如何看懂 Robot Framework 的文件，希望大家可以因為這篇而看得懂 Robot Framework &lt;(_ _)&gt;</p><p>已補坑：</p><ul><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Suite Setup V.S. Test Setup</a></li><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">在 Robot Framework 中，使用 config.ini 的檔案定義環境變數</a></li></ul><p>2021&#x2F;11&#x2F;16：補充執行所需的環境準備以及實際的題目應用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩&lt;/p&gt;
&lt;p&gt;這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://sqz777.github.io/tags/RobotFramework/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 4/17 技術管理者論壇－商業與技術的平衡</title>
    <link href="https://sqz777.github.io/2021/04/18/2021-235858/"/>
    <id>https://sqz777.github.io/2021/04/18/2021-235858/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>好久沒參加社群了，筆記一下！ </p><p>昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了</p><p>這天講的內容印象最深刻有 2 個+1個</p><ul><li>Gipi 講的上游理論</li><li>91 來我們這組討論</li><li>我自己提出的問題（群組沒討論，但是我自己想了一輪 XD）</li></ul><h2 id="上游理論"><a href="#上游理論" class="headerlink" title="上游理論"></a>上游理論</h2><p>Gipi 描述了問了大家一個問題</p><blockquote><p>「今天你待的地方是在中游，有一天你發現上游的人開始丟垃圾、拉屎在河裡，讓你平常用的水變成垃圾水、糞水，請問你們會怎麼做？」</p></blockquote><p>台下的人很踴躍的回答了</p><p>「找上游的人理論」</p><p>「烙下游的人一起去找上游的人理論」</p><p>「找別條河」</p><p>．．．</p><p>最後有一個人回答了關鍵的答案 我猜是樁腳</p><blockquote><p>「去幫助上游的人」</p></blockquote><h3 id="為什麼是去幫助上游的人？"><a href="#為什麼是去幫助上游的人？" class="headerlink" title="為什麼是去幫助上游的人？"></a>為什麼是去幫助上游的人？</h3><p>因為上游的人讓河流變髒了，肯定是有原因的，沒有人平白無故把珍貴的資產－河流變糟<br>在幫助他們時，你就必須去了解他為什麼要把這些垃圾、排泄物丟進河裡 這會使你更能體諒他們為何這樣做，也會讓他們知道你不是來出一張嘴的</p><h3 id="和他們一起解決問題是最容易的"><a href="#和他們一起解決問題是最容易的" class="headerlink" title="和他們一起解決問題是最容易的"></a>和他們一起解決問題是最容易的</h3><p>就算你最後沒辦法和他們一同解決這些問題，你仍然能夠在這個幫助的過程中獲得一些經驗，而這些難得的經驗能夠成為你在抵達下一條河流時的養分。<br>千萬不要在發現河流中出現異樣時，只抱怨，不做事，這樣不但沒辦法改變現狀，也無法學習到任何事情。 上述所提到的河流可以替換成公司，中游則是你自己在公司所代表的角色，而上層可以替換成任何與你合作的對象。</p><h2 id="小組討論"><a href="#小組討論" class="headerlink" title="小組討論"></a>小組討論</h2><p>我們這組提到了不少問題，其中有被拿出來討論的就是</p><blockquote><p>如何讓技術能夠量化並且順利推動？</p></blockquote><p>91：「你要做到的是用他的語言來去描述你想做的事情，你所提出的事情要能夠打到他在意的點，舉例來說你要推 CI&#x2F;CD、TDD，商業的人，像是業務、老闆要怎麼懂？」<br>「你要做的是『你跟老闆說你做 OOXX 事情，目的可以節省多少時間』，而使用這個節省的時間來推算能夠節省的金錢」<br>「如果某些提出來的功能很急而影響到你目前的實作進度，你也可以透過埋 log、埋 GA，觀察他所謂『很急』的功能的使用率，讓數據說話」</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li>用對方在乎的事情解釋<ul><li>用時間推算金錢成本，花下去的成本用多少時間可以回收？</li></ul></li></ul><h2 id="我自己提出的問題"><a href="#我自己提出的問題" class="headerlink" title="我自己提出的問題"></a>我自己提出的問題</h2><p>我提出的問題沒有被我們這一組的其他人選擇，因為我自己提出的問題比較沒有符合今天的主題「商業與技術的平衡」（也許是因為菜味十足的我還沒碰到技術與商業平衡的問題 🤡🤡）</p><p>因為最近才剛開始在團隊中整理一些程式碼，幫忙寫一些 Unit Test，在這個過程中發現了一些現象，所以我提出的問題是</p><blockquote><p>如何讓團隊有一個更完整（良好）的開發規範</p></blockquote><p>例如：在 C# 中偏好使用 var 來做變數的宣告等…</p><p>這兩天我思考了一下，我覺得像這樣的程式語言的「使用偏好」，比較像是「傳教」，而不是商業與技術中的平衡，所以沒被拿出來很正常w</p><p><img src="/img/2021-235858/artworks-000118550301-1jpyp5-t500x500.jpg" alt="玖壹壹- 歪國人( 小八2015.5.25 ReMiX - ) by Dj小八Taiwan"></p><p>今天跟我弟討論了一輪，在對話的過程中，我找到了一個…出入，或許說是一個…題目？</p><blockquote><p>如何傳教成功？</p></blockquote><p>首先我必須先認知到傳教不是吵架辯論，而是你認為這個東西超讚，所以你覺得其他人也應該要跟我一起信仰他<br>如果我透過吵架辯論的方式，我應該永遠無法傳教成功，甚至會把他推得更遠（尤其是這個跟我辯論的人，是我的同事）<br>你應該很難想像騎腳踏車上路的傳教士跟機車騎士在路邊爭論打架吧？  </p><p>在這邊先打住，在這邊列一下今天我跟我弟的討論內容</p><p>我：「你覺得到底該怎麼樣，才能讓團隊裡面的人使用到這些偏好？」<br>他：「我覺得沒有必要推這件事，這件事（以偏好使用 var 來說）對於最後所產出的價值並不會影響到很大」<br>我：「所以你的意思是說這些偏好其實都是沒有價值的嗎？」<br>他：「也不能這樣說，舉個我前公司的例子，他們有一個規範是為了方便找到這個 Function 所以在 Class 中的所有 Function 排序是有一定規則的，當我問到我的 Team Lead 時，他就是這麼跟我解釋的，所以我也會認同這件事，因為這個規範就已經是存在，而且我們團隊的人都認同這件事。」 <br>我：「也就是說如果有一個規範，他是由團隊內德高望重的人在專案中使用，那他就會被大家遵守囉？」<br>他：「是」<br>我：「那假設你今天是團隊中德高望重的人，你要怎麼讓大家使用這些偏好？」<br>他、我：「…」</p><p>這個空氣靜默的時間很短，大概有一秒那麼長</p><p>我就想出了一個解答並說：</p><blockquote><p>「這件事並不是由團隊中德高望重的人來讓大家使用，而是在你做這件事情的時候，大家也都認同，在這個情況之下，你也不用『讓』大家使用這些偏好了，他們自己就會『自動』使用這些偏好了」</p></blockquote><p>所以最後的問題就不會是「如何傳教成功？」了</p><p>而是</p><blockquote><p>你在團隊中如何建立 Credit，影響到其他人？</p></blockquote><p>知道真正的問題是這個，做法就變得顯而易見了！</p><p>雖然心中有一些答案但是仍然想問大家的就是，我最後所提到的問題</p><p><strong>你在團隊中如何建立 Credit，影響到其他人？</strong></p><p>以上是今天的筆記，感謝大家收看，如有錯誤麻煩提出來讓我修正 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久沒參加社群了，筆記一下！ &lt;/p&gt;
&lt;p&gt;昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了&lt;/p&gt;
&lt;p&gt;這天講的內容印象最深刻有 2 個+1個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gipi 講的上游理論&lt;/li&gt;
&lt;li&gt;91 來我們這組討論&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="社群" scheme="https://sqz777.github.io/tags/%E7%A4%BE%E7%BE%A4/"/>
    
    <category term="筆記" scheme="https://sqz777.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="商業與技術" scheme="https://sqz777.github.io/tags/%E5%95%86%E6%A5%AD%E8%88%87%E6%8A%80%E8%A1%93/"/>
    
  </entry>
  
  <entry>
    <title>筆記－什麼是時序耦合（Temporal Coupling）？</title>
    <link href="https://sqz777.github.io/2021/04/18/2021-what-is-temporal-coupling/"/>
    <id>https://sqz777.github.io/2021/04/18/2021-what-is-temporal-coupling/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式</a><br>其中第四章提到了時序耦合（Temporal Coupling）<br>覺得是一個值得寫下來筆記的東西，所以就產出了這篇。</p><p>第一次看到時序耦合這個詞的時候還以為是…Dio?</p><p><img src="/img/2021-what-is-temporal-coupling/1618680807.png"></p><p>結果並不是，讓我太失望了（並沒有失望）</p><h2 id="正文開始"><a href="#正文開始" class="headerlink" title="正文開始"></a>正文開始</h2><p><strong>耦合是指程式中模組及模組之間資訊或參數依賴的程度。</strong><br><strong>其相對的一個概念的詞叫做聚合性，也就是說低耦合性代表高內聚性。</strong></p><p>時序耦合是多種耦合分類中的其中一種　<a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>時序耦合指的是這個 Class 中含有的 Functions 有隱性的「先後順序」的耦合性，這是一個「Design Smell」<br>舉參考資料的程式碼為例</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public void Initialize(string fileName)  /&#123;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>使用這個程式碼，會是這樣</p><pre><code>var fileName = &quot;C:\test.txt&quot;;var fileLogger = new FileLogger();fileLogger.Initialize(fileName);fileLogger.Write(&quot;Log message.&quot;);</code></pre><p>假設這個 fileLogger 沒有在呼叫 Write 這個 Function 之前先呼叫 Initialize 就會造成 fileLogger 在 Write 訊息的時候造成無法找到檔案名稱的錯誤<br>而這樣子的程式碼所造成的結果就稱之為時序耦合。</p><h2 id="如何避免時序耦合"><a href="#如何避免時序耦合" class="headerlink" title="如何避免時序耦合?"></a>如何避免時序耦合?</h2><h3 id="透過-Constructor-Injection-的方式"><a href="#透過-Constructor-Injection-的方式" class="headerlink" title="透過 Constructor Injection 的方式"></a>透過 Constructor Injection 的方式</h3><p>在這個案例中，可以透過 Constructor Injection 的方式進行注入 fileName 即可<br>範例程式碼</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public FileLoger(string fileName)  /&#123;    if(string.IsNullOrEmpty(fileName))    /&#123;      throw new ArgumentNullException(&quot;fileName&quot;);    /&#125;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>這樣的方式除了可以避免時序耦合之外，也能夠減少外部呼叫的次數（不需要再呼叫 Initialize）。<br>另外也能夠透過建構子的方式觀察到這個 FileLogger 本身所依賴的事情有哪些。</p><p>參考資料：<br><a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br><a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式 (Dependency Injection: Principles, Practices, Patterns, 2&#x2F;e)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>備註：<a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br>這篇當中有提到另一個避免時序耦合的方式（抽象工廠 <strong>abstract factory</strong>），但如果沒有特殊限制的話，我會比較偏好使用本篇所記錄的 constructor injection 的方式來避免時序耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看 &lt;a href=&quot;https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw&quot;&gt;依賴注入：原理、實作與設計模式&lt;/a&gt;&lt;br&gt;其中第四章提到了時序耦合（Temporal Couplin</summary>
      
    
    
    
    
    <category term="筆記" scheme="https://sqz777.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="DI" scheme="https://sqz777.github.io/tags/DI/"/>
    
    <category term="CodeSmell" scheme="https://sqz777.github.io/tags/CodeSmell/"/>
    
  </entry>
  
  <entry>
    <title>C# - Dotnet core 的 DI 如何在註冊時帶給建構子未註冊進 DI 的服務</title>
    <link href="https://sqz777.github.io/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/"/>
    <id>https://sqz777.github.io/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體</p><h2 id="註冊已經註冊進-DI-的實體"><a href="#註冊已經註冊進-DI-的實體" class="headerlink" title="註冊已經註冊進 DI 的實體"></a>註冊已經註冊進 DI 的實體</h2><h2 id="程式碼準備"><a href="#程式碼準備" class="headerlink" title="程式碼準備"></a>程式碼準備</h2><p>準備 interface IAction 跟 class Action</p><pre><code>public interface IAction/&#123;    void ShakeHands();/&#125;public class Action : IAction/&#123;    public void Dance()    /&#123;        Console.WriteLine(&quot;Dancing!&quot;);    /&#125;/&#125;</code></pre><p>準備一個 dog 的 interface 跟 他的 class，並且需要透過建構子注入 IAction 這個服務</p><pre><code>public interface IDog/&#123;    void DogDance();/&#125;public class Dog : IDog/&#123;    IAction _action;    public Dog(IAction action)    /&#123;        _action = action;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;/&#125;</code></pre><p>蛤? 你說狗不會跳舞怎麼可以繼承 IAction 然後 Dance?</p><p>這不是在跳了嗎(誤</p><p>主程式碼 長這個樣子</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog, Dog&gt;();    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();/&#125;</code></pre><p>就可以看到執行結果</p><pre><code>Dog isDancing!</code></pre><p>如果是已經註冊進 DI 的服務，服務在啟動時會自動幫忙注入已經註冊的實體，所以只要<code>serviceCollection.AddScoped&lt;IDog, Dog&gt;();</code>即可</p><h2 id="註冊時，代入未註冊進-DI-的實體"><a href="#註冊時，代入未註冊進-DI-的實體" class="headerlink" title="註冊時，代入未註冊進 DI 的實體"></a>註冊時，代入未註冊進 DI 的實體</h2><p>這時就需要將原本的 Dog 多新增一點需要依賴的服務啦，最近 Cyberpunk 2077 很紅，那就讓它變成機器狗吧</p><p><img src="/img/2021-DotnetCoreDIConstructorWithParameters/4137968e6d4fab392ba7db14017ec100.jpg" alt="Dogenator | Cyberpunk, Cyberpunk 2077, Dog communication"></p><p>所以就先定義一個 Machine 的 class 吧!</p><pre><code>public class Machine/&#123;    public void Glow()    /&#123;        Console.WriteLine(&quot;Glowing!&quot;);    /&#125;/&#125;</code></pre><p>機器人的特色就是會發光 所以就讓他可以 Glow!</p><p>接下來將狗的 Constructor 變成需要多依賴 Machine 這個 class 吧!</p><pre><code>public interface IDog/&#123;    void DogDance();    void DogGlow();/&#125;public class Dog : IDog/&#123;    IAction _action;    Machine _machine;    public Dog(IAction action, Machine machine)    /&#123;        _action = action;        _machine = machine;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;    public void DogGlow()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _machine.Glow();    /&#125;/&#125;</code></pre><p>主程式碼修改成這樣</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();    dog.DogGlow();/&#125;</code></pre><p>關鍵在於這一行，</p><pre><code>serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));</code></pre><p><code>svc</code> 的類別是 <code>IServiceProvider</code><br><code>new Dog</code> 的意思可以理解為 將 Dog 註冊至 IDog 中<br>而<code>svc.GetService&lt;IAction&gt;(), new Machine()</code>這部分可以理解為取得已經註冊的實體並注入進 new Dog 的這個 constructor 中</p><p>就可以看到執行結果</p><pre><code>Dog isDancing!Dog isGlowing!</code></pre><p>以上為今天的筆記<br>感謝收看!</p><p>本篇的 github 連結:<br><a href="https://github.com/SQZ777/DotnetCoreDIWithParamter">SQZ777&#x2F;DotnetCoreDIWithParamter (github.com)</a><br>Refrence:<br><a href="https://blog.darkthread.net/blog/aspnet-core-di-notes/">筆記 - 不可不知的 ASP.NET Core 依賴注入-黑暗執行緒 (darkthread.net)</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-5.0&WT.mc_id=DOP-MVP-37580#Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_AddScoped__1_Microsoft_Extensions_DependencyInjection_IServiceCollection_System_Func_System_IServiceProvider___0__">ServiceCollectionServiceExtensions.AddScoped 方法 (Microsoft.Extensions.DependencyInjection) | Microsoft Docs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體&lt;/p&gt;
&lt;h2 id=&quot;註冊已經註冊進-DI-的實體&quot;&gt;&lt;a href=&quot;#註冊已經註冊進-DI-的實體&quot; class=&quot;headerlink&quot; title=&quot;註冊已</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://sqz777.github.io/tags/NetCore/"/>
    
    <category term="Constructor" scheme="https://sqz777.github.io/tags/Constructor/"/>
    
    <category term="DI" scheme="https://sqz777.github.io/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>C# - 如何在 AWS lambda 裡面使用 dotnet core 的 DI</title>
    <link href="https://sqz777.github.io/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/"/>
    <id>https://sqz777.github.io/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/</id>
    <published>2021-03-14T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.630Z</updated>
    
    <content type="html"><![CDATA[<p>dotnet core 的 DI 很好用</p><p>所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI</p><p>首先先建立一個 interface, 就叫 ITalkService 好了~</p><pre><code>namespace AWSLambdaAndDI/&#123;    public interface ITalkService    /&#123;        string SayHello(string name);    /&#125;/&#125;</code></pre><p>再寫一個他的實體 TalkService</p><pre><code>namespace AWSLambdaAndDI/&#123;    public class TalkService : ITalkService    /&#123;        public string SayHello(string name)        /&#123;            return name + &quot;: hello!&quot;;        /&#125;    /&#125;/&#125;</code></pre><p>這樣一來我們已經有了 interface 也有實作他的 class，接下來就來看一下如何在一般的 function 使用 dotnet core 的 DI 吧</p><p>首先需要使用 dotnet core CLI 來新增 package</p><pre><code>dotnet add package Microsoft.Extensions.DependencyInjection</code></pre><p>裝完之後就可以看到相依性裡面的套件出現 Microsoft.Extensions.DependencyInjection</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615732181.png"></p><p>我使用了 Visual Studio 來建立了一個 AWS Lambda 的專案，初始的程式碼會長這樣，並將這個 lambda 的 function 相依於前面已經實作好的 interface</p><pre><code>using Amazon.Lambda.Core;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    private readonly ITalkService _talkService;    public class Function    /&#123;                /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return input?.ToUpper();        /&#125;    /&#125;/&#125;</code></pre><p>如果要加入 DI ，需要在 constructor 中將需要用的 instance 跟對應到的 interface 進行註冊</p><p>constructor 的 code 會長這個樣子</p><pre><code>public Function()/&#123;  // 建立 DI  var serviceCollection = new ServiceCollection();  // 將 TalkService 註冊進 DI  serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();  var serviceProvider = serviceCollection.BuildServiceProvider();  // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface  this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();/&#125;</code></pre><p>確定好 talkService 註冊並且注入進 this._talkService 之後，就將 talkService 放進 FunctionHandler 中吧!<br>目前的 Lambda Function code 就會長這個樣子</p><pre><code>using Amazon.Lambda.Core;using Microsoft.Extensions.DependencyInjection;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    public class Function    /&#123;        private readonly ITalkService _talkService;        public Function()        /&#123;            // 建立 DI            var serviceCollection = new ServiceCollection();            // 將 TalkService 註冊進 DI            serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();            var serviceProvider = serviceCollection.BuildServiceProvider();            // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface            this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();        /&#125;        // 如果需要 unit test 可以利用這個 constructor 來進行 mock talkService        public Function(ITalkService talkService)        /&#123;            this._talkService = talkService;        /&#125;        /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return this._talkService.SayHello(input);        /&#125;    /&#125;/&#125;</code></pre><p>接著來使用 Mock Lambda Test Tool 來執行看看吧</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615734335.png"></p><p>以上就可以看到結果囉 “SQZ777: hello!”</p><p>如果以上訊息有任何錯誤麻煩告知 感謝各位大大 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dotnet core 的 DI 很好用&lt;/p&gt;
&lt;p&gt;所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI&lt;/p&gt;
&lt;p&gt;首先先建立一個 interface, 就叫 ITalkService 好了~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://sqz777.github.io/tags/NetCore/"/>
    
    <category term="awsLambda" scheme="https://sqz777.github.io/tags/awsLambda/"/>
    
    <category term="dependencyInjection" scheme="https://sqz777.github.io/tags/dependencyInjection/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 將自己做好的 Discord bot 放在 Heroku 上</title>
    <link href="https://sqz777.github.io/2020/11/24/2020-putDiscordBotToHeroku/"/>
    <id>https://sqz777.github.io/2020/11/24/2020-putDiscordBotToHeroku/</id>
    <published>2020-11-24T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.629Z</updated>
    
    <content type="html"><![CDATA[<p>Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子</p><p>這一篇以 Discord bot 為示範</p><p>首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972847.png"></p><p>點選 Create new app，命名自己的 app</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972936.png"></p><p>新增完畢之後就可以看到這個畫面，接著點選 GitHub</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973124.png"></p><p>這邊要輸入自己要建置的 bot repo name然後按下 Search 之後再按下旁邊那個 Connect 的按鈕<br><a href="https://dotblogs.com.tw/Im_sqz777/2020/11/21/DiscordSetupHelloWorld">如何建置 Discord bot 點這裡</a></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973433.png"></p><p>連結完畢之後會看到這個畫面，下面那個 Deploy Branch 按下去就是把機器人建置起來了<br><strong>但是先等一下!!!</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973597.png"></p><p>這邊需要先設定環境變數，我的機器人範例程式碼是這樣寫的，可以看到我需要環境變數 <strong>DISCORD_TOKEN</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973739.png"></p><p>所以我需要在 Heroku 上面設定 <strong>DISCORD_TOKEN</strong> 這個環境變數，在上面那排欄位中找到 Settings 進來之後點選 Reveal Config Vars</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973843.png"></p><p>點完之後，輸入變數名稱跟變數的值按下 Add 就可以成功新增環境變數</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974007.png"></p><p>在按下 Deploy 前請先確定自己的 package.json 中，有沒有設定好 npm start 要建置的 js file，如下</p><p>Heroku 在 Node.js 的專案中會執行 npm start 來執行專案</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974115.png"></p><p>確認完畢之後就可以回到這個頁面按下 Deploy Branch 囉!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974271.png"></p><p>回到 Discord 就可以看到自己的機器人上線啦!!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974342.png"></p><h2 id="澳門首家線上賭場上線啦"><a href="#澳門首家線上賭場上線啦" class="headerlink" title="澳門首家線上賭場上線啦"></a>澳門首家線上賭場上線啦</h2><p>以上是今天的筆記 感謝大家。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子&lt;/p&gt;
&lt;p&gt;這一篇以 Discord bot 為示範&lt;/p&gt;
&lt;p&gt;首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i</summary>
      
    
    
    
    
    <category term="discord" scheme="https://sqz777.github.io/tags/discord/"/>
    
    <category term="heroku" scheme="https://sqz777.github.io/tags/heroku/"/>
    
    <category term="nodejs" scheme="https://sqz777.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - Node.js 環境變數套件 dotenv</title>
    <link href="https://sqz777.github.io/2020/11/21/2020-231542/"/>
    <id>https://sqz777.github.io/2020/11/21/2020-231542/</id>
    <published>2020-11-21T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>開發時一定會用到環境變數，確保 config 可以快速被切換、程式碼不要包含機敏資料等等目的，所以就會透過 config 檔的方式來讀取各種機密資料</p><p>而 Node.js 可以透過 dotenv 來達成這件事</p><p>開始前你需要先安裝套件 dotenv</p><pre><code>npm install dotenv</code></pre><p> 在程式碼中引入這個套件</p><pre><code>require(&#39;dotenv&#39;).config()</code></pre><p>在使用前你需要建立一個檔案叫做 <strong>.env</strong><br>這個套件會去讀取這個檔案，讓這個檔案成為可以被 process.env 讀取的變數，格是為 &#x2F;{&#x2F;{變數名稱&#x2F;}&#x2F;}&#x3D;&#x2F;{&#x2F;{變數資料&#x2F;}&#x2F;}</p><pre><code>BLOG_NAME=SQZ777der技術小本本SECRET_TOKEN=secret tokenDB_CONNECTION=db connection</code></pre><p>透過 dotenv 讀取變數的程式碼如下</p><pre><code>require(&#39;dotenv&#39;).config()console.log(process.env.BLOG_NAME)console.log(process.env.SECRET_TOKEN)console.log(process.env.DB_CONNECTION)</code></pre><p>執行結果如下</p><p><img src="/img/2020-231542/1605971407.png"></p><p>以上是 dotenv 的簡單筆記<br>這邊是上面那些寫的程式碼 repo<br><a href="https://github.com/SQZ777/nodejs_dotenv_for_blog">https://github.com/SQZ777/nodejs_dotenv_for_blog</a></p><p>在一般專案開發時，請勿將 .env 這個檔案 commit 上去，此 repo 只是為了筆記而 commit .env 這個檔案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;開發時一定會用到環境變數，確保 config 可以快速被切換、程式碼不要包含機敏資料等等目的，所以就會透過 config 檔的方式來讀取各種機密資料&lt;/p&gt;
&lt;p&gt;而 Node.js 可以透過 dotenv 來達成這件事&lt;/p&gt;
&lt;p&gt;開始前你需要先安裝套件 dotenv&lt;</summary>
      
    
    
    
    
    <category term="Node.js" scheme="https://sqz777.github.io/tags/Node-js/"/>
    
    <category term="config" scheme="https://sqz777.github.io/tags/config/"/>
    
    <category term="dotenv" scheme="https://sqz777.github.io/tags/dotenv/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 透過 Node.js 建置 Discord BOT</title>
    <link href="https://sqz777.github.io/2020/11/21/2020-DiscordSetupHelloWorld/"/>
    <id>https://sqz777.github.io/2020/11/21/2020-DiscordSetupHelloWorld/</id>
    <published>2020-11-21T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>筆記一下如何透過 Node.js 建置 Discord 機器人</p><h2 id="什麼是-Discord"><a href="#什麼是-Discord" class="headerlink" title="什麼是 Discord"></a>什麼是 Discord</h2><p>Discord 是一個聊天通訊軟體，pc&#x2F;mobile 都可以使用，跟以前的 RC、TS 的軟體蠻像的</p><p>大部分的使用者都是遊戲玩家居多</p><p>他跟 Line 一樣也有提供相關的 API 可以使用!</p><p>本文範例程式碼：<a href="https://github.com/SQZ777/discord_bot_for_blog">https://github.com/SQZ777/discord_bot_for_blog</a></p><h2 id="環境-前置"><a href="#環境-前置" class="headerlink" title="環境&amp;前置"></a>環境&amp;前置</h2><ul><li><a href="https://nodejs.org/zh-tw/download/">Node.js</a></li><li><a href="https://discord.js.org/#/">discord.js</a></li><li><a href="https://discord.com/">Discord account</a></li></ul><h2 id="建立-Discord-Application"><a href="#建立-Discord-Application" class="headerlink" title="建立 Discord Application"></a>建立 Discord Application</h2><p>進到 discord 管理 application 的頁面 <a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a></p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944300.png"></p><p>可以看到自己已經建立的機器人，你的畫面應該是還沒有，所有要點擊右上角 <strong>New Application</strong>，之後命名一下自己的機器人名稱</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944370.png"></p><p>建立完成之後可以看到自己的機器人相關的 token 等等的東西</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949979.png"></p><p>再來左邊的欄位選 bot 之後按下 Add Bot </p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949763.png">選 Yes, do it!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949840.png"></p><p>把 token 先存起來，等等要利用 nodejs 開發機器人的功能時會用到這個 token</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><h2 id="把機器人加入自己的伺服器"><a href="#把機器人加入自己的伺服器" class="headerlink" title="把機器人加入自己的伺服器"></a>把機器人加入自己的伺服器</h2><p>按下左邊欄位 OAuth2 之後 scopes 選擇 bot, 因為目前只有傳送訊息 所以 bot permissions 選擇 Send Messages，箭頭處的部分就是邀請 bot 加入伺服器的連結，把它複製起來。</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950673.png"></p><p>把剛才那個邀請連接用瀏覽器連結過去之後就會詢問你要將機器人放進哪個伺服器，選好之後按下繼續即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950830.png"></p><p>然後會問你是否需要授權，按下授權即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950878.png"></p><p>在伺服器就會看到機器人加入的訊息</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950936.png"></p><h2 id="開始透過-Node-js-建置機器人"><a href="#開始透過-Node-js-建置機器人" class="headerlink" title="開始透過 Node.js 建置機器人"></a>開始透過 Node.js 建置機器人</h2><p>先使用 npm init 建立 package.json，再透過 npm 安裝 <a href="https://discord.js.org/#/">discord.js</a></p><pre><code>npm i discord.js</code></pre><p>建立一個檔案 app.js，範例原始碼來自於 <a href="https://discord.js.org/#/">discord.js</a> </p><pre><code>const Discord = require(&#39;discord.js&#39;);const client = new Discord.Client();client.on(&#39;ready&#39;, () =&gt; /&#123;  console.log(`Logged in as $/&#123;client.user.tag/&#125;!`);/&#125;);client.on(&#39;message&#39;, msg =&gt; /&#123;  if (msg.content === &#39;ping&#39;) /&#123;    msg.reply(&#39;Pong!&#39;);  /&#125;/&#125;);client.login(&#39;token&#39;);</code></pre><p>以上程式碼將最下方 client.login(‘token’) 的 ‘token’ 取代成剛才複製起來的 token 就可以了，忘記在哪這邊圖片附上複製位置</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><p>將機器人加入伺服器之後會發現機器人都是離線狀態(如圖)，是因為機器人目前沒有登入，我們需要執行我們的程式碼讓機器人登入</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951075.png"></p><p>執行 npm start，就會發現機器人登入了</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951375.png"></p><p>這時候就可以透過自己傳送 訊息 “ping” 來讓機器人回應你 “pong”，這樣就成功完成了一個機器人的 Hello World 囉!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951410.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://discord.com/developers/docs/intro">Discord 官方文件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;筆記一下如何透過 Node.js 建置 Discord 機器人&lt;/p&gt;
&lt;h2 id=&quot;什麼是-Discord&quot;&gt;&lt;a href=&quot;#什麼是-Discord&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Discord&quot;&gt;&lt;/a&gt;什麼是 Discord&lt;/h</summary>
      
    
    
    
    
    <category term="Node.js" scheme="https://sqz777.github.io/tags/Node-js/"/>
    
    <category term="bot" scheme="https://sqz777.github.io/tags/bot/"/>
    
    <category term="discord" scheme="https://sqz777.github.io/tags/discord/"/>
    
    <category term="discord.js" scheme="https://sqz777.github.io/tags/discord-js/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 使用 PowerShell 安裝 aws cli</title>
    <link href="https://sqz777.github.io/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/"/>
    <id>https://sqz777.github.io/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/</id>
    <published>2020-09-24T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>最近蠻常用到 AWS 的服務，而且需要在建機器的時候透過 powershell 來安裝 aws cli，所以就記錄一下這篇</p><p>本篇記錄時間為 2020&#x2F;09&#x2F;24，aws cli 的版本會隨著時間更新，今天示範的版本是 aws cli v2<br>請注意以下 $dlurl 的檔案位置是否已被 AWS 官方變更!</p><pre><code>#https://docs.aws.amazon.com/zh_tw/cli/latest/userguide/install-cliv2-windows.html$dlurl = &quot;https://awscli.amazonaws.com/AWSCLIV2.msi&quot;$installerPath = Join-Path $env:TEMP (Split-Path $dlurl -Leaf)Invoke-WebRequest $dlurl -OutFile $installerPathStart-Process -FilePath msiexec -Args &quot;/i $installerPath /passive&quot; -Verb RunAs -WaitRemove-Item $installerPath</code></pre><p>執行結果如下</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600961818.png"></p><p>會發現透過 aws –version 來確認是否安裝完成時，會出現錯誤，這時候如過不想要重開 powershell 就執行<a href="https://dotblogs.com.tw/Im_sqz777/2020/09/24/ReloadThePathInPowerShell">上一篇記錄</a>的程式碼</p><pre><code>$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;Machine&quot;)+ &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;User&quot;)</code></pre><p>執行之後再執行一次 aws –version 就可以成功執行囉~</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600962069.png"></p><p>source: <a href="https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf">https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近蠻常用到 AWS 的服務，而且需要在建機器的時候透過 powershell 來安裝 aws cli，所以就記錄一下這篇&lt;/p&gt;
&lt;p&gt;本篇記錄時間為 2020&amp;#x2F;09&amp;#x2F;24，aws cli 的版本會隨著時間更新，今天示範的版本是 aws cli v2&lt;</summary>
      
    
    
    
    
    <category term="aws" scheme="https://sqz777.github.io/tags/aws/"/>
    
    <category term="cli" scheme="https://sqz777.github.io/tags/cli/"/>
    
    <category term="install" scheme="https://sqz777.github.io/tags/install/"/>
    
    <category term="powershell" scheme="https://sqz777.github.io/tags/powershell/"/>
    
    <category term="安裝" scheme="https://sqz777.github.io/tags/%E5%AE%89%E8%A3%9D/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell - 如何重新 load 環境變數</title>
    <link href="https://sqz777.github.io/2020/09/24/2020-ReloadThePathInPowerShell/"/>
    <id>https://sqz777.github.io/2020/09/24/2020-ReloadThePathInPowerShell/</id>
    <published>2020-09-24T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>最近在寫 powershell 來安裝一些哩哩摳摳的東西然後使用，所以遇到了需要不在重新開啟 powershell 的時候 re-load 環境變數的狀況</p><p>今天就紀錄一下在不關閉 powershell 的情況下，用指令重新 load 環境變數的方式</p><p>首先要知道如何看到得到目前的 環境變數，在 powershell 裡面用這個指令就可以得到環境變數</p><pre><code>$env:Path</code></pre><p>這次用 powershell 安裝 python 為示範</p><p><img src="/img/2020-ReloadThePathInPowerShell/1600957666.jpg"></p><p>可以看到安裝完 python 之後，使用 python –version 沒辦法找到 python，因為需要 reload 環境變數</p><p>這時候就需要用到以下指令</p><pre><code>$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;Machine&quot;)+ &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;User&quot;)</code></pre><p>下完指令就可以成功使用 python 的指令了</p><p><img src="/img/2020-ReloadThePathInPowerShell/1600957696.jpg"></p><p>source: <a href="https://stackoverflow.com/questions/17794507/reload-the-path-in-powershell/31845512">https://stackoverflow.com/questions/17794507/reload-the-path-in-powershell/31845512</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在寫 powershell 來安裝一些哩哩摳摳的東西然後使用，所以遇到了需要不在重新開啟 powershell 的時候 re-load 環境變數的狀況&lt;/p&gt;
&lt;p&gt;今天就紀錄一下在不關閉 powershell 的情況下，用指令重新 load 環境變數的方式&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://sqz777.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Python - Mutable Default Arguments 筆記</title>
    <link href="https://sqz777.github.io/2020/09/04/2020-090843/"/>
    <id>https://sqz777.github.io/2020/09/04/2020-090843/</id>
    <published>2020-09-04T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>過去遇到毛毛蟲總是會想著「為什麼」這個要出現毛毛蟲，而這一次出現毛毛蟲也同樣想了這個「為什麼」，而且覺得比較特別，所以就把他筆記一下w</p><p>先來寫了以下這段 code</p><pre><code>def add_something_to_array(element, array=[]):    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)</code></pre><p>結果也會很簡單的回覆給我 [‘a’]</p><p><img src="/img/2020-090843/1599181601.png"></p><h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>如果第二次呼叫他的時候，問題就會出現了</p><p>把 code 先改成以下的樣子</p><pre><code>def add_something_to_array(element, array=[]):    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)my_array_b = add_something_to_array(&quot;b&quot;)print(my_array_a)print(my_array_b)</code></pre><p>來看看執行的結果</p><p><img src="/img/2020-090843/1599181616.png"></p><p>就會發現到裡面這個 array，會被外部重複使用，原因是什麼呢?</p><p>Python 在定義 function 的預設參數時，只會被定義一次，而不是在每次呼叫的時候重新定義一次，所以上面這一小段 code: array &#x3D; [] 才會一直被重複使用。</p><h2 id="那該怎麼做呢"><a href="#那該怎麼做呢" class="headerlink" title="那該怎麼做呢?"></a>那該怎麼做呢?</h2><p>你應該要避免在預設的參數裡面設定一個可變動的變數，將可變動的預設參數改為 None，在程式碼裡面判斷並賦予原本預設的可變動變數，如下</p><pre><code>def add_something_to_array(element, array=None):    if array is None:        array=[]    array.append(element)    return arraymy_array_a = add_something_to_array(&quot;a&quot;)print(my_array_a)my_array_b = add_something_to_array(&quot;b&quot;)print(my_array_a)print(my_array_b)</code></pre><p>當初在 code review 的時候遇到這樣寫法，還以為是在炫技，抱歉是我錯了</p><p>執行結果如下，這樣一切就會跟我們預想的結果相同啦!</p><p><img src="/img/2020-090843/1599181631.png"></p><h2 id="感謝網友陳信宏補充，使用-frozenset-也能夠避免此-code-lint-警告"><a href="#感謝網友陳信宏補充，使用-frozenset-也能夠避免此-code-lint-警告" class="headerlink" title="感謝網友陳信宏補充，使用 frozenset() 也能夠避免此 code lint 警告"></a>感謝網友陳信宏補充，使用 frozenset() 也能夠避免此 code lint 警告</h2><pre><code>def aa(a, b=frozenset()):  return [*b, a]print(aa(&quot;1&quot;))# [&#39;1&#39;]print(aa(&quot;2&quot;, frozenset([&quot;a&quot;, &quot;v&quot;])))# [&#39;v&#39;, &#39;a&#39;, &#39;2&#39;]</code></pre><p><img src="/img/2020-090843/1599230662.png"></p><p>參考來源: <a href="https://docs.python-guide.org/writing/gotchas/">https://docs.python-guide.org/writing/gotchas/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;過去遇到毛毛蟲總是會想著「為什麼」這個要出現毛毛蟲，而這一次出現毛毛蟲也同樣想了這個「為什麼」，而且覺得比較特別，所以就把他筆記一下w&lt;/p&gt;
&lt;p&gt;先來寫了以下這段 code&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def add_something_to_array(elemen</summary>
      
    
    
    
    
    <category term="Mutable Default Arguments" scheme="https://sqz777.github.io/tags/Mutable-Default-Arguments/"/>
    
    <category term="Python" scheme="https://sqz777.github.io/tags/Python/"/>
    
    <category term="筆記" scheme="https://sqz777.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 您預計要執行 .Net Core 程式，但 dotnet-ef 並不存在。</title>
    <link href="https://sqz777.github.io/2020/09/03/2020-220256/"/>
    <id>https://sqz777.github.io/2020/09/03/2020-220256/</id>
    <published>2020-09-03T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>有點久沒寫 dotnet core</p><p>今天重新把環境都裝回來，然後趁機更新到最新版本的 dotnet core</p><p>於是在開發的第一步要執行 dotnet ef 就發生了錯誤</p><p>如圖</p><p><img src="/img/2020-220256/1599141736.png"></p><p>原來是因為在 dotnet core 3.0 之後 .NET SDK 就不再包含 dotnet ef，所以如果要在 dotnet 裡面用 dotnet ef 的指令，必須要先進行安裝</p><pre><code>dotnet tool install --global dotnet-ef</code></pre><p>執行安裝後就可以看到安裝完成的畫面啦</p><p><img src="/img/2020-220256/1599141755.png"></p><p>歡迎回來 dotnet-ef!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有點久沒寫 dotnet core&lt;/p&gt;
&lt;p&gt;今天重新把環境都裝回來，然後趁機更新到最新版本的 dotnet core&lt;/p&gt;
&lt;p&gt;於是在開發的第一步要執行 dotnet ef 就發生了錯誤&lt;/p&gt;
&lt;p&gt;如圖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2020-2</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://sqz777.github.io/tags/NetCore/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - ASP.NET Core 使用 LibMan CLI</title>
    <link href="https://sqz777.github.io/2020/09/03/2020-222746/"/>
    <id>https://sqz777.github.io/2020/09/03/2020-222746/</id>
    <published>2020-09-03T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>用 libman 來管理需要的前端程式庫</p><h2 id="libman-是甚麼"><a href="#libman-是甚麼" class="headerlink" title="libman 是甚麼?"></a>libman 是甚麼?</h2><p><em>程式庫管理員 (LibMan) 是輕量型的用戶端程式庫取得工具。 LibMan 會從檔案系統或內容傳遞網路 (CDN)下載熱門的程式庫和架構。 支援的 Cdn 包括 CDNJS、 jsDelivr和 unpkg。 所選程式庫檔會擷取並放置在 <a href="http://asp.net/">ASP.NET</a> Core 專案中的適當位置。</em></p><p>source: <a href="https://docs.microsoft.com/zh-tw/aspnet/core/client-side/libman/?view=aspnetcore-3.1">https://docs.microsoft.com/zh-tw/aspnet/core/client-side/libman/?view=aspnetcore-3.1</a></p><p>環境準備</p><ul><li>.NET Core 2.1 SDK 以上</li></ul><p>安裝指令</p><pre><code>dotnet tool install -g Microsoft.Web.LibraryManager.Cli</code></pre><p><img src="/img/2020-222746/1599143155.png"></p><p>使用指令來確認是否安裝成功</p><pre><code>libman --version</code></pre><p><img src="/img/2020-222746/1599143175.png"></p><p>使用指令來建立 libman.json</p><pre><code>libman init</code></pre><p>預設就直接用 cdnjs 即可 (直接按下 Enter)</p><p><img src="/img/2020-222746/1599143190.png"></p><p>會看到目前的資料夾出現 libman.json，內容為</p><pre><code>/&#123;  &quot;version&quot;: &quot;1.0&quot;,  &quot;defaultProvider&quot;: &quot;cdnjs&quot;,  &quot;libraries&quot;: []/&#125;</code></pre><h2 id="以安裝-jquery-為例"><a href="#以安裝-jquery-為例" class="headerlink" title="以安裝 jquery 為例"></a>以安裝 jquery 為例</h2><p>使用以下 libman 指令來安裝 jquery 到指定資料夾中</p><pre><code>libman install jquery@3.2.1 --provider cdnjs --destination wwwroot/scripts/jquery --files jquery.min.js</code></pre><p><img src="/img/2020-222746/1599143216.png"></p><p>安裝完成後 libman.json 的內容會如下</p><pre><code>/&#123;  &quot;version&quot;: &quot;1.0&quot;,  &quot;defaultProvider&quot;: &quot;cdnjs&quot;,  &quot;libraries&quot;: [    /&#123;      &quot;library&quot;: &quot;jquery@3.2.1&quot;,      &quot;destination&quot;: &quot;wwwroot/scripts/jquery&quot;,      &quot;files&quot;: [        &quot;jquery.min.js&quot;      ]    /&#125;  ]/&#125;</code></pre><p>之後只要根據這一個 libman.json 即可使用以下指令來重新還原專案需要的檔案</p><pre><code>libman restore</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 libman 來管理需要的前端程式庫&lt;/p&gt;
&lt;h2 id=&quot;libman-是甚麼&quot;&gt;&lt;a href=&quot;#libman-是甚麼&quot; class=&quot;headerlink&quot; title=&quot;libman 是甚麼?&quot;&gt;&lt;/a&gt;libman 是甚麼?&lt;/h2&gt;&lt;p&gt;&lt;em&gt;程式庫管</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://sqz777.github.io/tags/NetCore/"/>
    
    <category term="libman" scheme="https://sqz777.github.io/tags/libman/"/>
    
    <category term="工具" scheme="https://sqz777.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 使用 Windows 的 command 建立指定大小檔案</title>
    <link href="https://sqz777.github.io/2020/05/21/2020-171333/"/>
    <id>https://sqz777.github.io/2020/05/21/2020-171333/</id>
    <published>2020-05-21T00:00:00.000Z</published>
    <updated>2024-06-08T17:33:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>近期因為工作的關係所以需要測試到電腦 full disk 的狀態，所以紀錄一下該如何使用 command 的指令產生指定大小的檔案</p><p>這次要記錄的是指令 “fsutil”，data_length 的單位是 bytes</p><pre><code>fsutil file createnew &lt;file_name&gt; &lt;data_length&gt;</code></pre><p>1KB &#x3D; 1 * 1024 bytes &#x3D; 1024</p><p>1MB &#x3D; 1 * 1024 * 1024 bytes &#x3D; <a href="tel:1048576">1048576</a></p><p>1GB &#x3D; 1 * 1024 * 1024 * 1024 bytes &#x3D; <a href="tel:1073741824">1073741824</a></p><p>1TB &#x3D; 1 * 1024 * 1024 * 1024 * 1024 bytes &#x3D;<a href="tel:1099511627776">1099511627776</a></p><p>以建立 100MB 為例</p><p>因為 100MB &#x3D; 100 * 1024 * 1024 &#x3D; 104857600</p><p>所以，指令如下</p><pre><code>fsutil file createnew test 104857600</code></pre><p>產生檔案之後就可以右鍵看一下檔案的大小囉</p><p><img src="/img/2020-171333/1590052327.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期因為工作的關係所以需要測試到電腦 full disk 的狀態，所以紀錄一下該如何使用 command 的指令產生指定大小的檔案&lt;/p&gt;
&lt;p&gt;這次要記錄的是指令 “fsutil”，data_length 的單位是 bytes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fsutil </summary>
      
    
    
    
    
    <category term="Windows" scheme="https://sqz777.github.io/tags/Windows/"/>
    
    <category term="command" scheme="https://sqz777.github.io/tags/command/"/>
    
    <category term="file" scheme="https://sqz777.github.io/tags/file/"/>
    
    <category term="shellScript" scheme="https://sqz777.github.io/tags/shellScript/"/>
    
  </entry>
  
</feed>
