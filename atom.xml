<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SQZ777&#39;s blog</title>
  
  
  <link href="https://blogs.sqz777.com/atom.xml" rel="self"/>
  
  <link href="https://blogs.sqz777.com/"/>
  <updated>2025-09-01T14:55:46.831Z</updated>
  <id>https://blogs.sqz777.com/</id>
  
  <author>
    <name>SQZ777</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeWars 刷題系列，英文不好的我，也能理解 JavaScript 的 reduce 方法原來不是「減少」的意思！</title>
    <link href="https://blogs.sqz777.com/2025/09/01/2025-codewars-javascript-reduce-discovery/"/>
    <id>https://blogs.sqz777.com/2025/09/01/2025-codewars-javascript-reduce-discovery/</id>
    <published>2025-09-01T22:29:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>今天寫 JavaScript 用 CodeWars 暖暖手，年底到了，懂的都懂（？）<br>先從 8kyu 開始複習一下語法，平常寫自動化真的用不到太多原生函式，大多都是在處理測試邏輯和測試資料的整理，不然就是閱讀 RD&#x2F;QA 們寫的 code</p><h2 id="今天的題目：How-good-are-you-really"><a href="#今天的題目：How-good-are-you-really" class="headerlink" title="今天的題目：How good are you really?"></a>今天的題目：How good are you really?</h2><p><img src="/../img/2025-codewars-javascript-reduce-discovery/image.png" alt="image1-confusing-to-reduce"></p><p>總之，今天遇到的題目是「How good are you really?」，大意就是<br>你會拿到一個陣列，裡面是同學們的考試分數，計算平均分數，並和你的分數比較<br>如果你大於平均 return <code>true</code>，否則 return <code>false</code>。</p><h2 id="我的第一個解法"><a href="#我的第一個解法" class="headerlink" title="我的第一個解法"></a>我的第一個解法</h2><p>寫這種題目其實我更熟悉使用 C# 的 lib，只要把 array 透過 linq 做 <code>[].Average()</code> 再用判斷式處理就結束了<br>但是 JavaScript… 我沒有這麼熟悉他的原生 lib（畢竟寫自動化會用到的就那幾個 XD）</p><p>於是簡單寫的答案是這樣：</p><pre><code class="javascript">function betterThanAverage(classPoints, yourPoints) &#123;  let scoreSum = 0;  for(i = 0; i&lt; classPoints.length; i++)&#123;    scoreSum += classPoints[i];  &#125;  return yourPoints &gt; (scoreSum/classPoints.length);&#125;</code></pre><p>送出也成功解了！</p><h2 id="別人的解法讓我大開眼界"><a href="#別人的解法讓我大開眼界" class="headerlink" title="別人的解法讓我大開眼界"></a>別人的解法讓我大開眼界</h2><p>看了別人的答案，如下：</p><pre><code class="javascript">function betterThanAverage(classPoints, yourPoints) &#123;  return yourPoints &gt; classPoints.reduce((a, b) =&gt; a + b, 0) / classPoints.length; &#125;</code></pre><p>誒？原來有 <code>reduce</code> 這種函式啊…</p><p>但我怎麼想都想不通，我英文太爛了，<code>reduce</code> 不是「減少」的意思嗎？到底怎麼回事？</p><h2 id="偉哉時代的巨人，煩請-AI-老師救援"><a href="#偉哉時代的巨人，煩請-AI-老師救援" class="headerlink" title="偉哉時代的巨人，煩請 AI 老師救援"></a>偉哉時代的巨人，煩請 AI 老師救援</h2><p>偉哉 AI！下個 prompt 請他解釋才知道，喔！原來是這樣</p><p>我的 prompt：</p><pre><code class="text">把我當五歲小孩解釋為什麼裡面的 reduce 方法要叫 reduce, reduce 英文不是「減少」的意思嗎javascript[1,2,3].reduce((a,b) =&gt; a + b, 0);</code></pre><p>AI 回應：</p><pre><code class="text">好的小朋友！我來解釋給你聽～reduce 確實有「減少」的意思，但在程式設計裡，它的意思是「把很多東西變成一個東西」！想像一下：🍎🍎🍎 (很多蘋果) → 🥧 (一個蘋果派)reduce 就是這樣！它把一個陣列（很多數字）變成一個結果（一個數字）[1, 2, 3] → 6步驟是這樣的：1. 開始：a = 0（起始值）2. 第一輪：a = 0, b = 1 → a + b = 13. 第二輪：a = 1, b = 2 → a + b = 3  4. 第三輪：a = 3, b = 3 → a + b = 65. 結果：6所以 reduce 的「減少」是指：- 減少陣列的「複雜度」- 把「多個」元素變成「一個」結果- 把「大的資料結構」縮減成「小的結果」就像把很多積木組裝成一個玩具一樣！</code></pre><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>原來 <code>reduce</code> 在程式設計中的「減少」，指的是把多個元素「縮減」成一個結果！不是數量上的減少，而是複雜度的簡化<br>這邊提到的範例都是加法，但可以用上減法、乘法或是其他更細緻的應用喔！</p><p>我甚至不太相信 AI 給我的答案，請他給我國外社群討論時是否有提到如何理解 reduce，這邊提供幾個連結：</p><ul><li><a href="https://www.reddit.com/r/learnprogramming/comments/15ywksn/comment/jxfb89s/">Reddit - 為什麼叫 reduce？1</a>  </li><li><a href="https://www.reddit.com/r/learnjavascript/comments/s1e4g1/comment/hs8j32z/">Reddit - 為什麼叫 reduce？2</a></li></ul><p>這次的學習讓我想起程式設計中很多名詞的含義，往往跟我們日常理解的意思有些微妙的差異<br>繼續暖手，Keep Learning!</p><p>我真的蠻喜歡 CodeWars 提交後可以看到很多人的 submit，一來自己透過 for 迴圈達成了複習的目的，二來又可以根據別人的答案學習到不同的撰寫方法，不懂的地方問 AI，讓我更熟悉 JavaScript 的語法，在複習上更有效率了！覺得愉悅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天寫 JavaScript 用 CodeWars 暖暖手，年底到了，懂的都懂（？）&lt;br&gt;先從 8kyu 開始複習一下語法，平常寫自動化真的用不到太多原生函式，大多都是在處理測試邏輯和測試資料的整理，不然就是閱讀 RD&amp;#x2F;QA 們寫的 code&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://blogs.sqz777.com/tags/JavaScript/"/>
    
    <category term="CodeWars" scheme="https://blogs.sqz777.com/tags/CodeWars/"/>
    
    <category term="程式碼學習" scheme="https://blogs.sqz777.com/tags/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>我的 macbook 系統資料好大RRRRRRR</title>
    <link href="https://blogs.sqz777.com/2025/02/21/2025-mac-system-data-clean-up/"/>
    <id>https://blogs.sqz777.com/2025/02/21/2025-mac-system-data-clean-up/</id>
    <published>2025-02-21T16:44:21.000Z</published>
    <updated>2025-09-01T14:55:46.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>最近安裝 xcode 新的 simulator 時，我的 mac 出現了一個錯誤訊息是 <code>您的啟動硬碟將滿</code><br>於是我確認了一下整個硬碟空間的佔比，發現我的系統資料真的好大，竟然佔了一半(247.9GB)</p><p><img src="/img/2025-mac-system-data-clean-up/image1.png" alt="system-data"></p><p>：你的系統資料有多大？<br>：三、四層樓那麼大(X)</p><p><img src="/img/2025-mac-system-data-clean-up/gif1.gif" alt="alt text"></p><p>嘗試找呂布（Reboot）救援之後意外的少了 30GB</p><p><img src="/img/2025-mac-system-data-clean-up/image2.png" alt="system-data-after-reboot"></p><p>找 google 求救之後發現有很多工具和軟體可以使用，有些要付費有些則不需要，但本人我就比較奇葩，不喜歡裝一堆有的沒的，所以決定找看看有沒有不安裝軟體的解決方式</p><p>於是找到了這一篇 <a href="https://www.reddit.com/r/mac/comments/ynv4d0/system_data_taking_up_all_my_storage_how_do_i_fix/">reddit</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>簡單來說就是使用 <code>du</code> 和 <code>df</code> 指令來確認磁碟空間中使用最多的地方，然後再針對那些資料夾進行手動清理</p><p>df 指令如下，這行的目的是讓你了解目前硬碟空間的使用狀況，並且僅顯示 size 為 GB 層級的資訊</p><pre><code>df -h | grep Gi</code></pre><p>du 指令如下，這行指令會先用 du -h 計算 &#x2F;System&#x2F;Volumes&#x2F;Data 內所有檔案和資料夾的磁碟使用量（並以 KB、MB、GB 等易讀單位顯示）。接著 grep “G\t” 只篩選出顯示為 GB 的結果，再用 sort 進行排序，讓你能快速找出哪些資料夾或檔案最佔空間</p><pre><code>du -h /System/Volumes/Data | grep &quot;G\t&quot; | sort</code></pre><p>找到那些最佔空間的檔案之後就可以用 finder 手動找到他再自行判斷是否刪除<br>這一次我找到很多垃圾 image，還有一些不知道為什麼垃圾桶沒清空的內容<br>最後我總共刪了 100GB 左右的資料，真是清清爽爽</p><p><img src="/img/2025-mac-system-data-clean-up/image3.png"></p><p><img src="/img/2025-mac-system-data-clean-up/image4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;緣起&quot;&gt;&lt;a href=&quot;#緣起&quot; class=&quot;headerlink&quot; title=&quot;緣起&quot;&gt;&lt;/a&gt;緣起&lt;/h2&gt;&lt;p&gt;最近安裝 xcode 新的 simulator 時，我的 mac 出現了一個錯誤訊息是 &lt;code&gt;您的啟動硬碟將滿&lt;/code&gt;&lt;br&gt;於</summary>
      
    
    
    
    
    <category term="macOS" scheme="https://blogs.sqz777.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Playwright 攔截 request 簡易筆記和範例</title>
    <link href="https://blogs.sqz777.com/2024/09/08/2024-easy-playwright-intercept-note/"/>
    <id>https://blogs.sqz777.com/2024/09/08/2024-easy-playwright-intercept-note/</id>
    <published>2024-09-08T16:18:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>工作上測試遇到了一個情境是測試 Web SDK，主要類似於 GA 的那種監控網頁事件來發送 request 的受測對象<br>Web SDK 會根據當下使用者的事件觸發順序而產生不同的 request 內容<br>今天準備了一個可以觸發 request 的 HTML、接收 request 的簡單 Node.js Backend API Server<br>還有筆記用的 Playwright 攔截 request 範例程式碼</p><p>所有程式碼都放在這: <a href="https://github.com/SQZ777/playwright-intercept-example">範例程式碼</a></p><p>這張圖應該能表達到今天文章範例中的攔截器概念(?)</p><p><img src="/../img/2024-easy-playwright-intercept-note/1.png" alt="interceptor_meme"></p><p>自動化的執行流程:</p><ol><li>啟動 server.js，讓 html 可以透過本地伺服器瀏覽</li><li>使用瀏覽器瀏覽 localhost:3000</li><li>點擊按鈕觸發 request 發送的動作</li><li>攔截 request 驗證 request 被發送的正確性</li></ol><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p><del>可能不算程式碼…? 沒有人:可是它裡面有 js</del></p><p>此 HTML 會在按下按鈕後擷取當下瀏覽器中的 timezone，將 timezone 夾帶進去 request 發送到 Backend Server</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Playwright Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Playwright Intercept Request Example&lt;/h1&gt;    &lt;button id=&quot;sendRequest&quot;&gt;Send Request&lt;/button&gt;    &lt;script&gt;        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;        document.getElementById(&#39;sendRequest&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;            fetch(&#39;/api/data&#39;, &#123;                method: &#39;POST&#39;,                headers: &#123;                    &#39;Content-Type&#39;: &#39;application/json&#39;                &#125;,                body: JSON.stringify(&#123; location: timezone &#125;)            &#125;)                .then(response =&gt; response.json())                .then(data =&gt; console.log(&#39;Response from server:&#39;, data))                .catch(error =&gt; console.error(&#39;Error:&#39;, error));        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接收 request 以及讓 HTML 可以被瀏覽</p><p>Node.js Server</p><pre><code>const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();const port = 3000;app.use(express.json());// 提供 public 資料夾中的靜態檔案app.use(express.static(path.join(__dirname, &#39;public&#39;)));app.post(&#39;/api/data&#39;, (req, res) =&gt; &#123;    console.log(&#39;Received data:&#39;, req.body);    res.json(&#123; message: &#39;Data received successfully&#39;, receivedData: req.body &#125;);&#125;);// 服務 index.htmlapp.get(&#39;/&#39;, (req, res) =&gt; &#123;    res.sendFile(path.join(__dirname, &#39;index.html&#39;));&#125;);app.listen(port, () =&gt; &#123;    console.log(`Server is running on http://localhost:$&#123;port&#125;`);&#125;);</code></pre><h2 id="Playwright-攔截範例"><a href="#Playwright-攔截範例" class="headerlink" title="Playwright 攔截範例"></a>Playwright 攔截範例</h2><p>先寫一個不改變瀏覽器 timezone 的案例，瀏覽器會依照使用者當前的機器設定來設定 timezone<br>我目前待在台灣，所以 timezone id 會是 <code>Asia/Taipei</code></p><pre><code class="javascript">const &#123; test, expect &#125; = require(&#39;@playwright/test&#39;);test.describe(&#39;test with local and no change&#39;, () =&gt; &#123;    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Asia/Taipei&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>再寫一個改變瀏覽器 timezone 的案例，這個案例會先將 timezone 改為 <code>Europe/Paris</code>，再執行瀏覽 HTML 的動作</p><pre><code class="javascript">test.describe(&#39;test with franch&#39;, () =&gt; &#123;    test.use(&#123; timezoneId: &#39;Europe/Paris&#39; &#125;);    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Europe/Paris&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>兩個案例執行完之後在 console 中可以見到以下結果</p><p><img src="/../img/2024-easy-playwright-intercept-note/2.png" alt="playwright_result"></p><h2 id="額外筆記"><a href="#額外筆記" class="headerlink" title="額外筆記"></a>額外筆記</h2><p>因為這一種會持續監聽瀏覽器事件的 Web SDK，是不會有 request 停止的一刻，所以選擇使用的是 <code>page.waitForTimeout(1000)</code><br>而非 <code>page.waitForLoadState(&#39;networkidle&#39;)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作上測試遇到了一個情境是測試 Web SDK，主要類似於 GA 的那種監控網頁事件來發送 request 的受測對象&lt;br&gt;Web SDK 會根據當下使用者的事件觸發順序而產生不同的 request 內容&lt;br&gt;今天準備了一個可以觸發 request 的 HTML、接收 </summary>
      
    
    
    
    
    <category term="Playwright" scheme="https://blogs.sqz777.com/tags/Playwright/"/>
    
    <category term="攔截Request" scheme="https://blogs.sqz777.com/tags/%E6%94%94%E6%88%AARequest/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile x Postgres：Materialized View 的 REFRESH 奇幻（？）之旅！</title>
    <link href="https://blogs.sqz777.com/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/"/>
    <id>https://blogs.sqz777.com/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/</id>
    <published>2024-06-18T16:18:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2024-init-postgres-when-materialized-view-depends-on-remote-table/image1.png" alt="我是小丑"></p><p>遇到這個 Issue 是因為測試上的需求，情境是要做 API Automation<br>而 SUT(System Under Test) 的 API 相依於 Postgres 中的某一個 Materialized View<br>又剛好，這個 Materialized View 會用到 remote table 的資料<br>再剛好，這個 remote table 也是你要做 init DB 的對象（在同一個 image）<br>執行 REFRESH MATERIALIZED VIEW 的時候發生的問題<br>所以就發生了這個問題，錯誤訊息如下</p><pre><code class="shell">2024-06-18 00:51:17.451 UTC [68] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-18 00:51:17.451 UTC [68] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?2024-06-18 00:51:17.451 UTC [68] STATEMENT:  REFRESH MATERIALIZED VIEW test2_db_schema.test2_mvERROR:  could not connect to server &quot;test1_db&quot;DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="這次-issue-的相關檔案"><a href="#這次-issue-的相關檔案" class="headerlink" title="這次 issue 的相關檔案"></a>這次 issue 的相關檔案</h2><p>想要在 local 重現的話，執行一次這裡提到的檔案就可以看到了~</p><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile:"></a>dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sqlCOPY init.sh /docker-entrypoint-initdb.d/init.sh</code></pre><h3 id="init-sh"><a href="#init-sh" class="headerlink" title="init.sh:"></a>init.sh:</h3><pre><code class="shell">psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;</code></pre><h3 id="test1-sql"><a href="#test1-sql" class="headerlink" title="test1.sql:"></a>test1.sql:</h3><pre><code class="sql">CREATE SCHEMA test1_db_schema AUTHORIZATION postgres;-- test1_db_schema.test1_table definition-- Drop table-- DROP TABLE test1_db_schema.test1_table;CREATE TABLE test1_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)</code></pre><h3 id="test2-sql"><a href="#test2-sql" class="headerlink" title="test2.sql:"></a>test2.sql:</h3><pre><code class="sql">CREATE SCHEMA test2_db_schema AUTHORIZATION postgres;CREATE EXTENSION postgres_fdw;CREATE SERVER test1_db        FOREIGN DATA WRAPPER postgres_fdw        OPTIONS (host &#39;localhost&#39;, port &#39;5432&#39;, dbname &#39;test1&#39;);CREATE USER MAPPING FOR postgresSERVER test1_dbOPTIONS (user &#39;postgres&#39;, password &#39;12345&#39;);-- test2_db_schema.test1_table definition-- Drop table-- DROP FOREIGN TABLE test2_db_schema.test1_table;CREATE FOREIGN TABLE test2_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)SERVER test1_dbOPTIONS (schema_name &#39;test1_db_schema&#39;, table_name &#39;test1_table&#39;);-- PermissionsALTER TABLE test2_db_schema.test1_table OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test1_table TO postgres;CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;-- View indexes:CREATE UNIQUE INDEX uix_test2_mv ON test2_db_schema.test2_mv USING btree (cupid_id, outer_id);-- PermissionsALTER TABLE test2_db_schema.test2_mv OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test2_mv TO postgres;</code></pre><p>這裡特別提一下建立 Materialized View 時的細節，以下 script 擷取於上面提到的內容</p><pre><code>CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;</code></pre><p>如果這裡寫的是 WITH DATA，報錯會報在這裡，而不是 REFRESH 的時候，錯誤訊息會像這樣</p><pre><code class="shell">2024-06-23 09:28:15.912 UTC [59] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-23 09:28:15.912 UTC [59] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>根據 <a href="https://github.com/docker-library/postgres/blob/master/Dockerfile-alpine.template#L216">postgres 在 github 上的 dockerfile</a>，可以注意到</p><ol><li>原始 postgres 的 docker-entrypoint.sh 放置於 <code>/usr/local/bin</code></li><li>你的 dockerfile 中，位於 <code>/docker-entrypoint-initdb.d/</code> 的 shell script，會早於 postgres 啟動的時間點</li></ol><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><ol><li>init.sh 中啟動 postgres，並確認 postgres 啟動後再執行我們的原本要執行的 script，並讓 image 保持啟動狀態</li><li>dockerfile 改為 <code>RUN init.sh</code>，而非原本將 init.sh 放進 <code>/docker-entrypoint-initdb.d/</code> 的方式</li></ol><h3 id="改變後的-init-sh："><a href="#改變後的-init-sh：" class="headerlink" title="改變後的 init.sh："></a>改變後的 init.sh：</h3><pre><code class="shell">#!/bin/bashecho &quot;Starting PostgreSQL...&quot;/usr/local/bin/docker-entrypoint.sh postgres &amp; # 將 postgres 啟動until pg_isready -h localhost -p 5432; do # 檢查 postgres 啟動狀態  echo &quot;Waiting for PostgreSQL to start...&quot;  sleep 1done# psql -U postgres -c &quot;CREATE DATABASE test1;&quot;psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;tail -f /dev/null # 讓 container 保持運作狀態</code></pre><h3 id="改變後的-dockerfile"><a href="#改變後的-dockerfile" class="headerlink" title="改變後的 dockerfile:"></a>改變後的 dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sql# COPY init.sh /docker-entrypoint-initdb.d/init.shCOPY init.sh /init.shRUN chmod +x /init.shCMD [&quot;/init.sh&quot;]</code></pre><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我真的沒想到會遇到這種問題，一開始單純只是想要快樂 init DB schema 而已，所以就單純放在 <code>/docker-entrypoint-initdb.d/</code> 裡面<br>這個過程讓我學到 Dockerhub 上的 image 中，他的 Dockerfile 是如何被執行的<br>以及我們自己放在 <code>/docker-entrypoint-initdb.d/</code> 裡面的 shell script 的執行順序</p><p>不過我不知道我這個解法到底是對的還是錯的 XD</p><p>所以，最後想問一下<br>透過 Dockerfile 建置 postgres DB schema 的 best practice 是什麼？<br><del>不要跟我說透過 dockerfile 建置 postgres DB 本身就是錯的 XDD</del></p><p>如果有更好的解法或是有寫錯的地方，歡迎告訴我<br>感謝大家</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2024-init-postgres-when-materialized-view-depends-on-remote-table/image1.png&quot; alt=&quot;我是小丑&quot;&gt;&lt;/p&gt;
&lt;p&gt;遇到這個 Issue 是因為測試上的需求，情</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://blogs.sqz777.com/tags/Docker/"/>
    
    <category term="Postgres" scheme="https://blogs.sqz777.com/tags/Postgres/"/>
    
  </entry>
  
  <entry>
    <title>【翻譯】5 件與測試有關的難搞事</title>
    <link href="https://blogs.sqz777.com/2024/06/10/2024-five-tricky-things-with-testing/"/>
    <id>https://blogs.sqz777.com/2024/06/10/2024-five-tricky-things-with-testing/</id>
    <published>2024-06-10T22:18:05.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2024-five-tricky-things-with-testing/image.jpg"></p><p>這是一篇翻譯文，文末才會有一些個人的心得與見解<br>原文連結:<br><a href="https://thetesteye.com/blog/2016/09/five-tricky-things-with-testing/">Five Tricky Things With Testing - Rikard Edgren</a></p><h2 id="內文翻譯"><a href="#內文翻譯" class="headerlink" title="內文翻譯"></a>內文翻譯</h2><p>今天我去了哥德堡的 SAST Väst，進行了一個可以翻譯為 <em>5 件與測試有關的難搞事</em> 的<a href="https://thetesteye.com/presentations/Edgren_SASTVAST2016_FemBesvarligaSakerMedTestning.pdf">演講</a>。<br>這是一個非常愉快的日子，我見到了舊友和新朋友。這也是我好久以來第一次寫 Blogs 的機會，下面是非常簡潔的版本：</p><ol><li><p><strong>人們不懂測試</strong>，但都有自己的見解。<br>他們認為測試是一種成本，沒有考慮到它的價值。<br>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</p></li><li><p><strong>心理上的困難</strong><br>你找到的問題越多，完成的時間就會越長。<br>解決方法：強調長期利益，對自己和他人都一樣。</p></li><li><p><strong>你永遠不會完成</strong><br>總有更多的東西需要測試，但你必須停止。<br>解決方法：多與同事交流，進行更豐富的測試。</p></li><li><p><strong>隱性知識。</strong><br>極少數情況下，你能寫下如何測試，然後進行良好的測試。<br>解決方法：更多的深層的討論</p></li><li><p><strong>有需求，但薪水低。</strong><br>解決方法：用正確的詞語談論測試的價值，並用小的努力而不僅僅是找到漏洞來提供價值。</p></li></ol><p>總結：確保你的測試能提供價值，這也有助於測試社群。</p><p>演講中有一些好問題，其中一個特別困難：<br><strong>如何確保訊息傳達到應該接收的人？</strong></p><p>回答：對於離你近的人，這並不困難；從一開始就討論要報告哪些訊息以及如何報告。<br>我不喜歡模板，所以我通常為每個項目製作一個新模板，並詢問是否包含了正確的訊息。</p><p>但我猜你的意思是對於那些離你較遠的人，尤其是階層較高的人，這可能非常困難。這可能是一些你「不能」直接交談的人，你也不被邀請參加他們的會議。<br>我嘗試過的一個技巧是以一種容易傳播的格式報告，這樣很容易複製和貼上精華部分，使你的話語能夠傳達到你無法直接交談的參與者。</p><p>更好的答案需要你在自己的情境中找到。</p><p>作者: Rikard Edgren<br>日期: September 27, 2016</p><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>到了 2024 年，測試的工作仍然會遇到上面這些難搞事<br>測試相關的工作者永遠必須抱持的態度就是「持續溝通」<br>並且不斷地談論「測試價值」這件事</p><h3 id="關於第一點的個人看法"><a href="#關於第一點的個人看法" class="headerlink" title="關於第一點的個人看法"></a>關於第一點的個人看法</h3><blockquote><p><em>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</em></p></blockquote><p>這部分我個人認位作者想要表達的是測試人員應該不斷的與相關利益者或者團隊成員討論他們對於「測試結果」的需求，以及「測試」可以幫助他們瞭解的重要事項</p><p>這樣的討論就可以幫助到大家更好地理解測試的價值，而不單單只是將「測試」視為一種成本</p><h3 id="關於第四點的個人看法"><a href="#關於第四點的個人看法" class="headerlink" title="關於第四點的個人看法"></a>關於第四點的個人看法</h3><blockquote><p><em>「極少數情況下，你能寫下如何測試，然後進行良好的測試。」</em></p></blockquote><p>我認為非常的貼切，因為大部分的 bug，發生在你意料之外的地方，而不是你預想的地方<br>這一句話所代表的是，開發者在大多數的情況下，會依照功能的描述進行開發<br>測試者則必須同時保證功能描述與開發者的實作成果一致之外，還得探索功能以外的可能性<br>以確保功能在完成時給予客戶的是驚訝，而不是驚嚇</p><p>Photo by <a href="https://unsplash.com/@icons8?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Icons8 Team</a> on <a href="https://unsplash.com/photos/man-teaching-woman-while-pointing-on-gray-laptop-yTwXpLO5HAA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2024-five-tricky-things-with-testing/image.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是一篇翻譯文，文末才會有一些個人的心得與見解&lt;br&gt;原文連結:&lt;br&gt;&lt;a href=&quot;https://thetesteye</summary>
      
    
    
    
    
    <category term="翻譯系列" scheme="https://blogs.sqz777.com/tags/%E7%BF%BB%E8%AD%AF%E7%B3%BB%E5%88%97/"/>
    
    <category term="測試相關" scheme="https://blogs.sqz777.com/tags/%E6%B8%AC%E8%A9%A6%E7%9B%B8%E9%97%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChatGPT 進行部落格文章搬遷的我會被 AI 取代嗎?</title>
    <link href="https://blogs.sqz777.com/2024/06/08/2024-migrate-blog-by-chatgpt/"/>
    <id>https://blogs.sqz777.com/2024/06/08/2024-migrate-blog-by-chatgpt/</id>
    <published>2024-06-08T22:46:45.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-migrate-blog-by-chatgpt/image0.png"><br>圖是使用<a href="https://memes.tw/">梗圖產生器</a>產生的，AI 真的可以取代我們嗎? 讓我們繼續看下去</p><p>最近自己使用了 ChatGPT 進行部落格文章的搬遷<br>搬站的原因很膚淺，想知道的話再去<a href="https://sqz777.com/about/">關於我</a>看，就不多做贅述 🤣<br>原本這篇只是單純想記錄搬遷的過程，但剛好最近社團討論很熱烈就把文章的撰寫方式稍微改變一下<br>讓這篇可以更符合社團最近討論度很高的主題： </p><blockquote><p>因為 AI 的出現，工程師會不會失業?</p></blockquote><p><strong>本文使用的 ChatGPT 模型是 GPT-4o</strong></p><h2 id="正文開始，我的第一步是拆分需求"><a href="#正文開始，我的第一步是拆分需求" class="headerlink" title="正文開始，我的第一步是拆分需求"></a>正文開始，我的第一步是拆分需求</h2><p>需求很簡單</p><ul><li>提供 URL 將部落格的文章內容轉成 markdown</li><li>取得舊部落格的所有文章 URL</li><li>讓第一個需求可以批次處理</li></ul><p>這種一次性的 script，就不考慮維護性了<br>所以基本上所有 code 都讓 ChatGPT 產生再做細節的調整就好</p><h2 id="第二步，描述需求讓-ChatGPT-產生程式碼"><a href="#第二步，描述需求讓-ChatGPT-產生程式碼" class="headerlink" title="第二步，描述需求讓 ChatGPT 產生程式碼"></a>第二步，描述需求讓 ChatGPT 產生程式碼</h2><p>直接讓 ChatGPT 幫我產生一段關於文章內容轉成 markdown 的 Node.js Code</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image1.png"></p><p>以下是 ChatGPT 產生的 Node.js Code</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);const fs = require(&#39;fs&#39;);const URL = &#39;https://dotblogs.azurewebsites.net/Im_sqz777/2022/10/06/223559&#39;;axios.get(URL)  .then(response =&gt; &#123;    const html = response.data;    const $ = cheerio.load(html);    // 假設文章內容在 class 為 &#39;post-content&#39; 的元素中    const postContent = $(&#39;.post-content&#39;).html();    if (!postContent) &#123;      throw new Error(&#39;未能找到文章內容，請檢查選擇器是否正確&#39;);    &#125;    // 將 HTML 轉換為 Markdown 格式    const markdownContent = convertToMarkdown(postContent);    // 將 Markdown 內容寫入文件    fs.writeFileSync(&#39;article.md&#39;, markdownContent);    console.log(&#39;文章已成功轉換為 Markdown 格式並儲存至 article.md&#39;);  &#125;)  .catch(error =&gt; &#123;    console.error(&#39;發生錯誤:&#39;, error);  &#125;);function convertToMarkdown(html) &#123;  // 這裡使用 turndown 庫來轉換 HTML 為 Markdown  const TurndownService = require(&#39;turndown&#39;);  const turndownService = new TurndownService();  return turndownService.turndown(html);&#125;</code></pre><h2 id="第三步，修正-ChatGPT-的程式碼"><a href="#第三步，修正-ChatGPT-的程式碼" class="headerlink" title="第三步，修正 ChatGPT 的程式碼"></a>第三步，修正 ChatGPT 的程式碼</h2><p>我發現了 ChatGPT 提供的 code 中有一個「假設」</p><pre><code>// 假設文章內容在 class 為 &#39;post-content&#39; 的元素中const postContent = $(&#39;.post-content&#39;).html();</code></pre><p>這一個假設讓我需要回到文章的頁面中找到文章內容的 class 為 <code>article__content</code>，如圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image2.png"></p><p>將 <code>.post-content</code> 取代為 <code>.article__content</code> 了之後執行程式碼</p><blockquote><p>記得在<code>article__content</code>前面加上點: <code>.</code></p></blockquote><p>驗證產生出來的 markdown 有幾個小問題</p><ol><li>舊文章日期&#x2F;標籤&#x2F;標題，沒有被寫進我預期的格式中</li><li>檔案名稱是寫死的，舊文章產生的檔案名稱應該依照文章年份及對應名稱</li></ol><h2 id="第四步，修正小問題，讓-ChatGPT-重新產生程式碼"><a href="#第四步，修正小問題，讓-ChatGPT-重新產生程式碼" class="headerlink" title="第四步，修正小問題，讓 ChatGPT 重新產生程式碼"></a>第四步，修正小問題，讓 ChatGPT 重新產生程式碼</h2><p>依照小問題 1，我需要道舊文章中找到文章對應的標題&#x2F;標籤&#x2F;日期的 html，然後產生 prompt 讓 GPT 幫我改 code<br>prompt 如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image3.png"></p><p>避免文章太長，就不貼 GPT 產生的 code 了<br>接著再解小問題 2<br>這個問題很簡單，直接讓 GPT 修正並且改掉先前提到的文章內容 class 的問題</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image4.png"></p><p>小問題解完之後，執行了 script，確認 markdown 可以被 hexo 解析就可以進到下一步了</p><h2 id="第四步，讓-URL-可以批次輸入"><a href="#第四步，讓-URL-可以批次輸入" class="headerlink" title="第四步，讓 URL 可以批次輸入"></a>第四步，讓 URL 可以批次輸入</h2><p>為了讓舊站的連結可以透過 git 記錄，所以決定透過檔案的方式來進行批次處理<br>這樣一來我有紀錄的同時又可以透過檔案來進行文章的轉換，prompt 如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image5.png"></p><p>在檔案中隨便貼上兩個舊站的文章測試一下，確認沒問題之後就往下一步</p><h2 id="第五步，取得舊站所有文章的-URL"><a href="#第五步，取得舊站所有文章的-URL" class="headerlink" title="第五步，取得舊站所有文章的 URL"></a>第五步，取得舊站所有文章的 URL</h2><p>在舊站首頁中可以觀測到 title 的 class 為 <code>article__title</code><br>然後可以在 URL 觀測到頁面會因為尾數不同而換頁，URL 如下</p><blockquote><p><a href="https://dotblogs.com.tw/Im_sqz777/1">https://dotblogs.com.tw/Im_sqz777/1</a> &lt;&lt; 這個 1 就是頁數</p></blockquote><p>我們就可依照這個狀況產生對應的 prompt:</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image6.png"></p><p>產生的程式碼如下</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);async function fetchArticleTitles(variable) &#123;    const url = `https://dotblogs.com.tw/Im_sqz777/$&#123;variable&#125;`;    try &#123;        const &#123; data &#125; = await axios.get(url);        const $ = cheerio.load(data);        // 選擇所有 class 為 article__title 的元素        $(&#39;.article__title a&#39;).each((index, element) =&gt; &#123;            const titleUrl = $(element).attr(&#39;href&#39;);            console.log(titleUrl);        &#125;);    &#125; catch (error) &#123;        console.error(`Error fetching data from $&#123;url&#125;:`, error);    &#125;&#125;// 迭代變數 1 到 8for (let i = 1; i &lt;= 8; i++) &#123;    fetchArticleTitles(i);&#125;</code></pre><p>接著執行產生的程式碼會發現他並沒有符合我們的需求，如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image7.png"></p><p>我們的需求是需要讓 text file 中描述 URL，所以只需要在第 14 行加入 <code>&#39;https://dotblogs.com.tw&#39; + </code> 就可以了<br>執行結果如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image8.png"></p><h2 id="第六步，修復-hexo-解析的問題"><a href="#第六步，修復-hexo-解析的問題" class="headerlink" title="第六步，修復 hexo 解析的問題"></a>第六步，修復 hexo 解析的問題</h2><p>接著就會發現 hexo 解析的 2 個錯誤</p><ol><li>title 格式的問題<br><img src="/img/2024-migrate-blog-by-chatgpt/image9.png"></li><li>舊文中出現大括弧 <code>&#123;&#125;</code> 時的解析問題</li></ol><p>title 的格式問題很簡單，在原程式碼中的 title 中加入單引號即可，如下</p><pre><code>---title: &#39;$&#123;title&#125;&#39;date: $&#123;date&#125;tags: $&#123;tags.map(tag =&gt; `  - $&#123;tag&#125;`).join(&#39;\n&#39;)&#125;---</code></pre><p>第 2 個問題直接讓 ChatGPT 解決</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image10.png"><br>但是 ChatGPT 提供的程式碼有問題，關鍵程式碼如下</p><pre><code>  // 替換文章內容中的 &#123; 和 &#125; 字符  markdownContent = markdownContent.replace(/(&#123;|&#125;)/g, &#39;\\$1&#39;);</code></pre><p>我預期和描述的 prompt 斜線是 <code>/</code>，但 ChatGPT 睜眼說瞎話的寫成了 <code>\</code>，改掉之後確認解析沒問題後</p><p>還剩下一個細節的需求，是一開始需求分析時沒有寫到的:</p><ul><li>圖片應該要下載下來，並且在 markdown 中顯示</li></ul><p>但這一段 ChatGPT 完美的解決了我的問題，所以就不記錄了，想要看最後的程式碼的話可以到 Github 上看<br>連結附上</p><ul><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/dotblogTurnMarkdown.js">DotBlogs 文章轉 markdown</a></li><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/getDotblogPostsURLs.js">取得 DotBlogs 的文章 URLs</a></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>總結一下透過 ChatGPT 搬遷 blogs 文章會需要的技能</p><ol><li>知道網站相關的知識<ul><li>知道在程式碼中描述 class 前面要加上 <code>.</code></li><li>知道 URL 中哪個值是對應頁數</li></ul></li><li>知道如何使用 Chrome 的開發者工具</li><li>知道 regex 的組成</li><li>知道錯誤訊息怎麼看<ul><li>如何快速定位哪一篇是發生錯誤的文章</li></ul></li><li>知道 hexo 解析錯誤的原因<ul><li>在 {} 前要加上 <code>/</code> 而非 <code>\</code></li><li>在標題中出現 <code>&#39;</code> 要在 script 中針對標題兩側加上 <code>&#39;</code></li></ul></li><li>…之後想到再補充</li></ol><p>以上程式碼的內容，要我自己寫是完全沒問題，有 AI 之後<br>原本可能要花 1 小時左右的時間，最後壓縮成 20 分鐘內甚至更短就解決了<br>依照今天這樣子的搬遷紀錄來看，我應該還不至於被「純粹的 AI 工具」或是「無基礎但使用 AI 工具的人」取代</p><p>不過要注意的是那些努力且能夠善用 AI 工具的人，這些人的生產力可能會是 AI 出現前的好幾倍</p><p>不說了，我要睡了，明早再修這個 blog theme 程式碼會置中的問題了 🙈🙈🙈<br>感謝大家收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-migrate-blog-by-chatgpt/image0.png&quot;&gt;&lt;br&gt;圖是使用&lt;a href=&quot;https://memes.tw/&quot;&gt;梗圖產生器&lt;/a&gt;產生的，AI 真的可以取代我們嗎? 讓我們繼續看下去&lt;/p&gt;
&lt;p&gt;最近</summary>
      
    
    
    
    
    <category term="AI" scheme="https://blogs.sqz777.com/tags/AI/"/>
    
    <category term="ChatGPT" scheme="https://blogs.sqz777.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>更改 Chrome 時區的方法</title>
    <link href="https://blogs.sqz777.com/2024/06/06/2024-how-to-change-time-zone-in-chrome/"/>
    <id>https://blogs.sqz777.com/2024/06/06/2024-how-to-change-time-zone-in-chrome/</id>
    <published>2024-06-06T22:29:10.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-how-to-change-time-zone-in-chrome/image.png" alt="checkTimeZone"></p><p>最近測試時遇到驗證不同時區狀況的需求</p><p>直覺上認為開啟 VPN 或是更改電腦的設定是不合理的<br>所以嘗試找看看 Chrome 有沒有辦法更改 Chrome 自身的時區設定<br>然後就讓我找到了 <a href="https://developer.chrome.com/docs/devtools/settings/locations?hl=zh-tw">Chrome 的文件</a> !</p><h2 id="設定前確認時區"><a href="#設定前確認時區" class="headerlink" title="設定前確認時區"></a>設定前確認時區</h2><p>更改之前，透過 F12 的 Console 來確認當前的時區</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image1.png" alt="checkTimeZone"></p><h2 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h2><p>於右上角三個點 &gt; More tools &gt; Sensors</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image2.png" alt="settingLocation"></p><p>接著在下方的 Sensors tab 就可以找到複寫 Location 的設定，我們這裡選擇 Tokyo</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image3.png" alt="settingLocation"></p><h2 id="確認結果"><a href="#確認結果" class="headerlink" title="確認結果"></a>確認結果</h2><p>在 Console 中確認時區是否已被覆寫</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image4.png" alt="settingLocation"></p><p>這樣就可以完成時區的修改啦!<br>當前端會根據 Chrome 本身設定的時區進行時區顯示上的修改時，就會需要用到這一個 Chrome 的覆寫時區功能了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-how-to-change-time-zone-in-chrome/image.png&quot; alt=&quot;checkTimeZone&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近測試時遇到驗證不同時區狀況的需求&lt;/p&gt;
&lt;p&gt;直覺上認為開啟 VPN 或是更改電腦</summary>
      
    
    
    
    
    <category term="Chrome" scheme="https://blogs.sqz777.com/tags/Chrome/"/>
    
    <category term="時區" scheme="https://blogs.sqz777.com/tags/%E6%99%82%E5%8D%80/"/>
    
  </entry>
  
  <entry>
    <title>API 自動化的技術選擇與 Modules 的分層思考</title>
    <link href="https://blogs.sqz777.com/2022/10/06/2022-223559/"/>
    <id>https://blogs.sqz777.com/2022/10/06/2022-223559/</id>
    <published>2022-10-06T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。</p><p><a href="https://github.com/SQZ777/jest-for-api-automation-template.git">https://github.com/SQZ777/jest-for-api-automation-template.git</a></p><p>各個 subtitle 如下</p><ul><li>為何不使用 Postman 來做 API Automation</li><li>語言選擇</li><li>測試框架選擇</li><li>Modules 的分層</li><li>各個 Modules 的介紹與實作</li><li>結語和本篇沒提到的事</li></ul><p>首先在使用程式碼撰寫 API 自動化的測試案例時，一定會先遇到這個問題</p><h2 id="為何不使用-Postman-來做-API-Automation？"><a href="#為何不使用-Postman-來做-API-Automation？" class="headerlink" title="為何不使用 Postman 來做 API Automation？"></a>為何不使用 Postman 來做 API Automation？</h2><p><img src="/img/2022-223559/1665066616.png.png"></p><p>所以就先來列一下 Postman 的優&#x2F;缺點吧</p><p>優點如下</p><ul><li>UI 介面容易使用，門檻極低</li><li>可以透過 JavaScript 來實作檢查 response 的 script</li><li>各個平台（Mac, Windows）都可以使用</li><li>可以透過 newman（CLI）來建置 CI 的流程</li></ul><p>接著列一下使用 Postman 執行管理自動化案例會遇到的問題</p><ul><li>大量自動化案例會產生極大的維護成本<ul><li>無法重用的 test script</li><li>受測 API 如果新增 required fields，會需要手動更新大量既有的 script</li></ul></li><li>執行 collection runner 再透過 csv 檔案來匯入測試資料的過程過於繁瑣</li></ul><p>Postman 在實作小型的 API 驗證時，是一個非常好用的工具，但需要實作大量 API 測試案例時，在 Postman 上管理這些案例會產生很大的維護成本，不信的話你可以試試，所以我們需要透過撰寫程式的方式來管理這些即將被實作的 API 測試案例。</p><h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>首先要選擇的是語言，依照公司內部現有的技術而選，策略是以不增加公司同事之間跨越職能障礙為主要目標，其次是這個語言的資源，再其次是學習的門檻，因為有尚未開發過自動化的 QA ，所以選擇語言起手的難易度也需要列為考量。</p><p><img src="/img/2022-223559/1665066630.png.png"></p><p>抱歉了 Java XD</p><p>公司內部的 backend 是 Java，而 front-end 則是 Vue.js，所以就剩下 JavaScript 及 Java 的選項能夠選擇，考量到學習的難易度與學習資源取得的容易度，就選了 JavaScript 了，其中考量到 JavaScript 的原因還有就是公司是有需要驗證 Web 上面顯示資料正確性的需求，所以如果學會了 JavaScript ，就可以 JavaScript 實作一些工具直接在 console 上執行來協助測試。</p><h2 id="測試框架選擇"><a href="#測試框架選擇" class="headerlink" title="測試框架選擇"></a>測試框架選擇</h2><p>接下來就可以找 JavaScript 在 2021 的統計，可以參考<a href="https://2021.stateofjs.com/en-US/">這個網站</a>，可以從圖表看到使用率最高的是 Jest。</p><p><img src="/img/2022-223559/1665066647.png.png"></p><p>使用率最高不代表他就是一個值得讓人使用的框架，所以再次參考了「時間推移體驗」這個數據，也可以觀察到 Jest 是一個會讓人願意再次使用的框架。</p><p><img src="/img/2022-223559/1665066655.png.png"></p><p>所以依照上面的數據，問了幾個身邊的朋友，得到的回饋也是好的，所以就選擇了 Jest 作為這次實作自動化的框架。</p><h2 id="Modules-的分層"><a href="#Modules-的分層" class="headerlink" title="Modules 的分層"></a>Modules 的分層</h2><p>為了解決 Postman 所遇到的痛點，所以我們需要</p><ul><li>tests 層<ul><li>使用其他 modules 來組成 test case 的地方</li></ul></li><li>request API 的部分要抽成 apis 的 module</li><li>request payloads 的部分要抽成 requestPayloads 的 module</li><li>有一些需要共用的 lib 抽成 common 的 module</li></ul><p>相依的關係可以畫成這個樣子</p><p><img src="/img/2022-223559/1665066676.png.png"></p><p>資料夾結構如下</p><pre><code>├─apis│      apis1.js│      apis2.js│      api/&#123;.../&#125;.js│      index.js│      requestHelper.js├─common│      jestExtend.js│          ├─requestPayloads│      apis1Request.js│      apis2Request.js│      apis/&#123;.../&#125;Request.js│      index.js│      └─tests    │   singleApi1.test.js    │   singleApi2.test.js    │   singleApi/&#123;.../&#125;.test.js    │          └─stories           stories.test.js</code></pre><h2 id="各個-Modules-的介紹與實作"><a href="#各個-Modules-的介紹與實作" class="headerlink" title="各個 Modules 的介紹與實作"></a>各個 Modules 的介紹與實作</h2><h3 id="requestPayloads-資料夾"><a href="#requestPayloads-資料夾" class="headerlink" title="requestPayloads 資料夾"></a>requestPayloads 資料夾</h3><p>requestPayloads 資料夾中的 indejx.js 是用來統整各個 API 的預設 request payloads</p><pre><code>const apis1= require(&#39;./apis1Request&#39;);const apis2= require(&#39;./apis2Request&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>預設 request payloads 的定義為：Server 不會回應「lack of fields response」的 payload</p><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis1Request.js 內容就會如下：</p><pre><code>const products = /&#123;  product_id: 1,  product_info: /&#123;    product_name: &#39;Car Engine&#39;,  /&#125;,/&#125;;module.exports = /&#123;  products,/&#125;;</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 4 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="apis-資料夾"><a href="#apis-資料夾" class="headerlink" title="apis 資料夾"></a>apis 資料夾</h3><p>apis 資料夾中的 index.js 是用來統整 apis1, apis2…等 api 的地方</p><pre><code>const apis1 = require(&#39;./apis1&#39;);const apis2 = require(&#39;./apis2&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>apis 資料夾中的 requestHelper.js 是用來管理 request API 的 HTTP method 的一層，如 get, post 等 在這一層會與 report 那一層作結合，多讓 jest 的 report 多帶一些在打 api request 的相關結果 程式碼單純以 post 為例子</p><pre><code>const axios = require(&#39;axios&#39;);/** * @param /&#123;string/&#125; baseURL for base URL * @param /&#123;object/&#125; headers for request headers * @param /&#123;object/&#125; data for request payload */async function postRequest(baseURL, headers, data) /&#123;  const result = await axios(/&#123;    method: &#39;post&#39;,    url: baseURL,    headers: headers,    data: data,  /&#125;)      .then((result) =&gt; /&#123;        return result;      /&#125;)      .catch((err) =&gt; /&#123;        console.log(err);      /&#125;);  return result;/&#125;module.exports = /&#123;  postRequest,/&#125;;</code></pre><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis.js 中則會引用到 requestHelper.js 來 request API，apis.js code 如下</p><pre><code>const /&#123;postRequest/&#125; = require(&#39;./requestHelper&#39;);require(&#39;dotenv&#39;).config();/** * @param /&#123;object/&#125; request payload * @return /&#123;object/&#125; response */**async function products(data) /&#123;  const result = await postRequest(      `$/&#123;configs.BASE_URL/&#125;/apis1/products`,      /&#123;        &#39;x-api-key&#39;: process.env.API_KEY,        &#39;content-type&#39;: &#39;application/json&#39;,      /&#125;,      data,  );  return result;/&#125;**</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 5 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="common-資料夾"><a href="#common-資料夾" class="headerlink" title="common 資料夾"></a>common 資料夾</h3><p>這一層主要是放一些官方沒有提供的 library 實作，或是共用的 function，以 jest 沒有提供的 object contain 為例，就會新增 jestExtend.js，其 code 如下，在 scenario API test 中將會用到。</p><pre><code>expect.extend(/&#123;  toContainObject(received, argument) /&#123;    const pass = this.equals(        received,        expect.arrayContaining([expect.objectContaining(argument)]),    );    if (pass) /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; not to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: true,      /&#125;;    /&#125; else /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: false,      /&#125;;    /&#125;  /&#125;,/&#125;);</code></pre><h3 id="tests-資料夾"><a href="#tests-資料夾" class="headerlink" title="tests 資料夾"></a>tests 資料夾</h3><p>這一層就是 Jest 的使用層了，會在這一層中使用各個 modules 來組成 test case。</p><p>API 測試種類大致上可以分成兩種</p><ul><li>單一 API 測試 (Single API test)</li><li>API 情境測試 (Scenario API test)</li></ul><p>單一 API 測試是指純粹只有這隻 API 是受測項目，完成測試的條件與其他 API 無關，是一個只需要使用單一一個 API 的測試項目，舉例來說 &#x2F;products API，帶給他 payload，其中會 lack fields，或是沒有帶 header，就稱之為 single API test。</p><p>API 情境測試是指要完成一個測試情境而需要用到多個 API，這裡就會需要引用到多個不同的 API 來達成某種目的，舉例來說 call &#x2F;prodcuts&#x2F;update 更新一個 product 然後再透過 &#x2F;products API 來取得預期被更新的 API，這邊就會引用到兩隻 API，這時候就稱之為 API 的情境測試。</p><p>Single API test，以 &#x2F;products API 為例子，其 code 如下</p><pre><code>const apis = require(&#39;../apis&#39;);test(&#39;Get products, should return 200&#39;, async () =&gt; /&#123;  const result = await apis.products.get();  expect(result.status).toBe(200);/&#125;);</code></pre><p>Scenario API test，以 &#x2F;products, &#x2F;products&#x2F;create 為例子，其 code 如下</p><pre><code>require(&#39;../../common/jestExtend&#39;);const apis = require(&#39;../../apis&#39;);const requestPayloads = require(&#39;../../requestPayloads&#39;);test(&#39;Create product, should get the product at /products&#39;, async () =&gt; /&#123;  const createResult = await apis.products.create(      requestPayloads.products.create,  );  expect(createResult.status).toBe(200);  const result = await apis.products.get();  expect(result.data).toContainObject(requestPayloads.products.create);/&#125;);</code></pre><h2 id="結語和本篇沒提到的事"><a href="#結語和本篇沒提到的事" class="headerlink" title="結語和本篇沒提到的事"></a>結語和本篇沒提到的事</h2><p>在這一篇中沒提到的有以下幾個事情</p><ul><li>json schema 的 validate</li><li>config</li></ul><p>依照目前的架構要擴充這兩件事情都可以很輕鬆，所以就沒有額外再寫出來記錄了</p><p>以上就是這一次整個 API automation 的思考與選擇的筆記<br>感謝各位大大看到這裡，如果有任何建議都可以跟我說，感謝 &lt;(_ _)&gt;</p><p>再次附上 repo: <a href="https://github.com/SQZ777/jest-for-api-automation-template">SQZ777&#x2F;jest-for-api-automation-template (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參</summary>
      
    
    
    
    
    <category term="Automation" scheme="https://blogs.sqz777.com/tags/Automation/"/>
    
    <category term="API" scheme="https://blogs.sqz777.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Prettier ESLint 出現的錯誤：Error: r is not a constructor</title>
    <link href="https://blogs.sqz777.com/2022/02/25/2022-180145/"/>
    <id>https://blogs.sqz777.com/2022/02/25/2022-180145/</id>
    <published>2022-02-25T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>最近做基礎建設踩到的雷</p><p>在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息</p><blockquote><p><strong>Error: r is not a constructor</strong></p></blockquote><p>目前在 github 上可以看到這個 issue ，而發生這個原因是因為目前 Prettier ESLint 還沒有支援到 eslint 8.0 以上，所以建議將版本降到 7.32.0，如圖</p><p><img src="/img/2022-180145/1645783122.png.png"></p><p><a href="https://github.com/idahogurl/vs-code-prettier-eslint/issues/26">官方的 GitHub issue</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做基礎建設踩到的雷&lt;/p&gt;
&lt;p&gt;在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Error: r is not a constructor&lt;/strong&gt;&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
    <category term="VSCode" scheme="https://blogs.sqz777.com/tags/VSCode/"/>
    
    <category term="vs-code-prettier-eslint" scheme="https://blogs.sqz777.com/tags/vs-code-prettier-eslint/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - Suite Setup V.S Test Setup</title>
    <link href="https://blogs.sqz777.com/2021/11/16/2021-224604/"/>
    <id>https://blogs.sqz777.com/2021/11/16/2021-224604/</id>
    <published>2021-11-16T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義</p><p>Test Setup</p><p><em><strong>a test setup is something that is executed before a test case, and a test teardown is executed after a test case.</strong></em></p><p>Suite Setup</p><p><em><strong>A suite setup is executed before any test cases or sub test suites in that test suite, and similarly a suite teardown is executed after them.</strong></em></p><p>原文連結：<a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#id594">Robot Framework User Guide #id594</a></p><p>簡單來說</p><ul><li>Test Setup 會在每次 case 開始前執行一次</li><li>Suite Setup 是 robot file 開始執行 test case 前執行一次</li></ul><p>Suite 單位為 .robot file<br>Test 的單位為 test case</p><p>廢話不多說，先上 code，Test Setup 的 code 如下</p><pre><code>*** Settings ***Test Setup    Log To Console    Setup in Test!*** Test Cases ***Test Setup 1    Log To Console    Test Case 1Test Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的 code 如下</p><pre><code>*** Settings ***Suite Setup    Log To Console   Setup in Suite!*** Test Cases ***Suite Setup 1    Log To Console    Test Case 1Suite Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073888.png"></p><p>Test Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073897.png"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從 Code 的執行結果來看，如果一個 robot file 中有多個 Test Case</p><ul><li>Suite Setup 只會被執行一次</li><li>Test Setup 會被執行多次</li></ul><p>以上為簡單的筆記，感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義&lt;/p&gt;
&lt;p&gt;Test Setup&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;a test setup is something that is executed before a test case, and a</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
    <category term="SuiteSetup" scheme="https://blogs.sqz777.com/tags/SuiteSetup/"/>
    
    <category term="TestSetup" scheme="https://blogs.sqz777.com/tags/TestSetup/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 使用 config.ini 管理環境變數</title>
    <link href="https://blogs.sqz777.com/2021/11/08/2021-204911/"/>
    <id>https://blogs.sqz777.com/2021/11/08/2021-204911/</id>
    <published>2021-11-08T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>這篇會介紹：</p><ul><li>為何要使用 config.ini</li><li>Variables 在 *** Settings ***</li><li>如何使用 config.ini</li></ul><p>安安 我來填坑了</p><p><img src="/img/2021-204911/1636375721.png"></p><h2 id="為什麼要使用-config-ini"><a href="#為什麼要使用-config-ini" class="headerlink" title="為什麼要使用 config.ini"></a>為什麼要使用 config.ini</h2><p>透過 config.ini 可以</p><ul><li>根據環境定義不同的環境變數</li><li>避免將機敏資料寫在程式碼中</li><li>避免第三方服務變更時，有大量的檔案需要被變更</li></ul><p>一般來說在開發任何的程式時都會有環境的區別，使用 config 檔案可以，除了環境的區別之外，還有不適合直接寫在程式碼中的資料例如：token、API 的 URL 等</p><h2 id="Variables-在-Settings"><a href="#Variables-在-Settings" class="headerlink" title="Variables 在 *** Settings ***"></a>Variables 在 *** Settings ***</h2><p>在知道如何使用 config.ini 之前須要先知道 Variables 在 Settings 中的作用是什麼</p><p>根據 <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variable-files">Robot Framework 的文件</a>可以看到 Variables 有兩種方式可以透過 .py 引入變數</p><ul><li>Getting variables directly from a module</li><li>Getting variables from a special function</li></ul><h3 id="Getting-variables-directly-from-a-module-的方式"><a href="#Getting-variables-directly-from-a-module-的方式" class="headerlink" title="Getting variables directly from a module 的方式"></a>Getting variables directly from a module 的方式</h3><p>官方定義：</p><p><em>Variables are specified as module attributes. In simple cases, the syntax is so simple that no real programming is needed. For example, creates a variable with the specified text as its value. One limitation of this approach is that it does not allow using arguments.MY_VAR &#x3D; ‘my value’$&#x2F;{MY_VAR&#x2F;}</em></p><p>以官方定義來說就可以直接看到這個方式的缺點就是沒有支援使用 arguments.MY_VAR 的方式使用變數</p><p>以範例來看使用這種方式的結果會是這樣</p><p>python 的程式碼：</p><pre><code>MY_NAME = &quot;SQZ777&quot;</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;_MY_NAME/&#125;</code></pre><p>執行結果就可以看到</p><p><img src="/img/2021-204911/1636374905.png"></p><h3 id="Getting-variables-from-a-special-function-的方法"><a href="#Getting-variables-from-a-special-function-的方法" class="headerlink" title="Getting variables from a special function 的方法"></a>Getting variables from a special function 的方法</h3><p>官方定義：</p><p><em>An alternative approach for getting variables is having a special function (also camelCase syntax is possible) in a variable file. If such a function exists, Robot Framework calls it and expects to receive variables as a Python dictionary or a Java with variable names as keys and variable values as values. Created variables can be used as scalars, lists, and dictionaries exactly like when getting variables directly from a module, and it is possible to use and prefixes to make creating list and dictionary variables more explicit. The example below is functionally identical to the first example related to getting variables directly from a module.get_variablesgetVariablesMapLIST__DICT__</em></p><p>簡單來說，透過這個方式就可以使變數有「環境」這一層的定義，除此之外還要注意的是，python 的檔案中要定義 function 的名稱為 <strong>get_variables</strong></p><p>直接來示範吧！</p><p>python 的程式碼：</p><pre><code>def get_variables():    var = &quot;BLOG_ENV.MY_NAME&quot;    variables = /&#123;/&#125;    variables[var] = &quot;SQZ777&quot;    return variables</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;BLOG_ENV.MY_NAME/&#125;</code></pre><p>在這裡就可以注意到我的變數已經可以隸屬於不同的環境了（BLOG_ENV 中的 MY_NAME）</p><h2 id="如何使用-config-ini"><a href="#如何使用-config-ini" class="headerlink" title="如何使用 config.ini"></a>如何使用 config.ini</h2><p>了解了兩種不同的引入環境變數的方式終於來到最後了解如何使用 config.ini 的部分啦！</p><p>透過 configparser 讀取 config.ini ，再將檔案中所有被定義好的變數回傳給 Robot Framework 就可以達成使用 config.ini 的方法</p><p>python 的程式碼：</p><pre><code>import configparserdef get_variables(config_path=&quot;./config.ini&quot;):    config = configparser.ConfigParser()    config.read(config_path)    variables = /&#123;/&#125;    print(config.sections)    for section in config.sections():        for key, value in config.items(section):            var = &quot;%s.%s&quot; % (section, key)            variables[var] = value    return variables</code></pre><p>config.ini 內容：</p><pre><code>[BLOG_ENV]MARVEL_URL = &lt;http://gateway.marvel.com/&gt;MARVEL_PUBLIC_KEY = 你的 public keyMARVEL_PRIVATE_KEY = 你的 private key</code></pre><p>在 robot 中使用 config，如下圖</p><p><img src="/img/2021-204911/1636374936.png"></p><p>在這裡就會出現一個疑問，這樣不就等於環境被寫死了嗎？</p><p><img src="/img/2021-204911/1636374948.png"></p><p>所以這邊為了讓使用上更方便，環境的定義可以透過 command line 來傳入，在執行 Robot Framework 時，代入參數，如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><p>而 .robot 的檔案則須要改成取用 ENV 這個在 command line 中傳入的變數。</p><p><img src="/img/2021-204911/1636374966.png"></p><p>這樣就能執行到指定的環境與變數囉!</p><p>感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇會介紹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為何要使用 config.ini&lt;/li&gt;
&lt;li&gt;Variables 在 *** Settings ***&lt;/li&gt;
&lt;li&gt;如何使用 config.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安安 我來填坑了&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    
    <category term="config" scheme="https://blogs.sqz777.com/tags/config/"/>
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
    <category term="環境變數" scheme="https://blogs.sqz777.com/tags/%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 介紹一下</title>
    <link href="https://blogs.sqz777.com/2021/10/17/2021-191743/"/>
    <id>https://blogs.sqz777.com/2021/10/17/2021-191743/</id>
    <published>2021-10-17T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩</p><p>這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的</p><p><img src="/img/2021-191743/1634469178.png"></p><h2 id="介紹與使用場景"><a href="#介紹與使用場景" class="headerlink" title="介紹與使用場景"></a>介紹與使用場景</h2><p>Robot Framework 是一個基於 python 的 自動化框架，基本上可以用 python 達成的事情，Robot Framework 都可以做到，其應用的場景是 ATDD (Acceptance Test Driven Development)、BDD (Behavior Driven Development) 以及可以被機器化的流程。</p><p><img src="/img/2021-191743/1634469201.png"></p><h2 id="為何使用-Robot-Framework"><a href="#為何使用-Robot-Framework" class="headerlink" title="為何使用 Robot Framework?"></a>為何使用 Robot Framework?</h2><ul><li>學習資源易於取得</li><li>易於理解與學習的介面</li><li>已有豐富的 Keyword 可以使用</li></ul><p>Robot Framework 對於沒有程式基礎的人來說是「相對」易於理解的，因為他有最接近人類自然語言的介面讓人閱讀，在政治條件（？）上比較能夠說服他人使用這個工具。</p><p>你通常不太需要再自行開發 Keyword 就可以完成你需要執行的自動化流程，如果需要，你也能夠透過實作 Python 來完成你需要做的事。</p><h2 id="看懂-Robot-Framework"><a href="#看懂-Robot-Framework" class="headerlink" title="看懂 Robot Framework"></a>看懂 Robot Framework</h2><p>先來張圖，這張圖是 Robot Framework 的文件，紅框的部分：</p><p><img src="/img/2021-191743/1634469224.png"></p><h2 id="Settings"><a href="#Settings" class="headerlink" title="*** Settings ***"></a>*** Settings ***</h2><p>這裡是引入 library 以及初始化的地方</p><p><img src="/img/2021-191743/1634469248.png"></p><ul><li>如果你在別的 .robot 中定義好了需要被引入的 library 或是 Keywords 可以透過 Resource 來達成引入的動作</li><li>Suite Setup 則是在測試跑起來時會做的初始化動作</li></ul><p>這邊幫自己挖個坑，會再發一篇 Suite Setup 跟 Test Setup 的差別。<br>此坑已補上： <a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Robot Framework - Suite Setup V.S Test Setup | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a>  </p><p><img src="/img/2021-191743/1634469266.png"></p><p>看一下 settings.robot</p><p><img src="/img/2021-191743/1634469282.png"></p><p>會使用 settings.robot 來統一引入 library 的原因是為了避免 .robot 的檔案多了，每一個檔案都要重新引入那些 library 實在是麻煩，所以乾脆由一個 file 來控制需要被引入的 library，這樣簡單得多。<br>Variables 讓你可以直接透過檔案的形式讓你引入環境變數<br>Library 則是讓你可以引入 python 或是 Robot Framework 的 library<br>RequestsLibrary 是別人開發好的 Robot Framework 的 Library，需要使用以下指令安裝後才能使用，這個 library 可以讓我們省掉開發 Requests Keyword 的時間。</p><pre><code>python -m pip install robotframework-requests</code></pre><p><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html">RequestsLibrary Keyword 使用方法的文件點我</a></p><h2 id="Variables"><a href="#Variables" class="headerlink" title="*** Variables ***"></a>*** Variables ***</h2><p>這裡是定義這個檔案中會用到的常數</p><p><img src="/img/2021-191743/1634469327.png"></p><p>通常這裡的變數不會直接寫死在這裡，而是會在另一個檔案中定義 config.ini 之類的然後在透過變數來做取用</p><p>所以我這邊也是再挖一個坑，會再發一篇如何定義 config.ini 然後在 robot 裡面中引用那個環境變數<br>此坑已補上：<a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">Robot Framework - 使用 config.ini 管理環境變數 | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a></p><p><img src="/img/2021-191743/1634469353.png"></p><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="*** Keywords ***"></a>*** Keywords ***</h2><p>這裡是自定義關鍵字的地方，可以在這裡定義好關鍵字後，在 Test Case 中使用</p><p><img src="/img/2021-191743/1634469372.png"></p><p>Get Character With Beginning Of The Name，這個是 Keyword 的名稱</p><p>[Arguments] 讓 Keyword 被定義成是可以被傳入參數的，而這個參數名稱是 character_name，定義完成後即可在 Test Case 中使用</p><p>而 Keyword 再往下一層則是 python 的程式碼，以圖中行號 13 的 Get Md5 Hash 為例，這個 Get Md5 Hash 是我自行實作在 <a href="http://common.py/">common.py</a> 的一段 python code</p><p>P.S. <a href="http://common.py/">common.py</a> 已在 settings.robot 中引入。</p><pre><code>import hashlibdef get_md5_hash(data):    hasher = hashlib.md5()    hasher.update(data.encode(&quot;utf-8&quot;))    return hasher.hexdigest()</code></pre><p>以此為例，你可以使用 Get Md5 Hash 或是 get_md5_hash 都可以，只要文件內有統一的格式即可。</p><p>其他的 Keyword 對應官方文件有</p><ul><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Get%20Time">Get Time</a><br>可以指定格式取得 Datetime</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Create%20Dictionary">Create Dictionary</a><br>建立 Dictionary</li><li><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html#GET%20On%20Session">Get On Session</a><br>建立於 Session 上來 request 其方法為 Get</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Return%20From%20Keyword">Return From Keyword</a><br>Get Character With Beginning Of The Name 這一個 Keyword 即將返回的值</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal%20As%20Strings">Should Be Equal As Strings</a><br>斷言（Assert）兩個值的型態為 string 時會是相同的。</li></ul><h2 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="*** Test Cases ***"></a><strong>*** Test Cases ***</strong></h2><p>這裡是定義 Test Case 的地方，會透過使用 Keyword 來組合成需要被自動化的流程</p><p><img src="/img/2021-191743/1634469384.png"></p><h2 id="開發準備"><a href="#開發準備" class="headerlink" title="開發準備"></a><strong>開發準備</strong></h2><p>開發前要準備的就是環境啦</p><ul><li><p>python</p></li><li><p>python package: robotframework</p></li><li><p>python package: robotframework-requests</p><p>python -m pip install robotframework robotframework-requests</p></li></ul><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><p>package 安裝完成後，就可以開始寫一些需要自動化的項目了，開始寫之前先決定要做的自動化項目是什麼</p><ul><li>準備 request 過去 Marvel API 的 token 資訊，Marvel API 的 token 申請，可以參考 repo 中的 readme </li><li>透過 Marvel 的 API 取得角色名稱開頭為 “Tony” 的角色資訊</li><li>唯一一個角色開頭為 “Tony” 的人就是 Tony Stark 所以必須要能取得 Tony Stark 這個名字</li></ul><p>robot 的 Test Suite 如下</p><pre><code>*** Settings ***Resource    settings.robotSuite Setup    Create Session    MARVEL_API    $/&#123;$/&#123;ENV/&#125;.MARVEL_URL/&#125;*** Variables ***$/&#123;api_private_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PRIVATE_KEY/&#125;$/&#123;api_public_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PUBLIC_KEY/&#125;*** Keywords ***Get Character With Beginning Of The Name    [Arguments]    $/&#123;character_name/&#125;    $/&#123;timestamp/&#125;=    Get Time    epoch    $/&#123;hash/&#125;=    Get Md5 Hash    $/&#123;timestamp/&#125;$/&#123;api_private_key/&#125;$/&#123;api_public_key/&#125;    $/&#123;params/&#125;=    Create Dictionary    ts=$/&#123;timestamp/&#125;    apikey=$/&#123;api_public_key/&#125;    hash=$/&#123;hash/&#125;    nameStartsWith=$/&#123;character_name/&#125;    $/&#123;response/&#125;=    Get On Session    alias=MARVEL_API    url=/v1/public/characters    params=$/&#123;params/&#125;    expected_status=200    Return From Keyword    $/&#123;response/&#125;*** Test Cases ***Get Beginning With Tony&#39;s Character Name Info    $/&#123;result/&#125;=    Get Character With Beginning Of The Name    Tony    Should Be Equal As Strings    $/&#123;result.json()[&quot;data&quot;][&quot;results&quot;][0][&quot;name&quot;]/&#125;    Tony Stark</code></pre><h2 id="Repo-點我"><a href="#Repo-點我" class="headerlink" title="Repo 點我"></a><a href="https://github.com/SQZ777/robotframework-marvel">Repo 點我</a></h2><h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><p>若要執行指令如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><h2 id="執行中"><a href="#執行中" class="headerlink" title="執行中"></a>執行中</h2><p><img src="/img/2021-191743/1637074430.png"></p><h2 id="執行後"><a href="#執行後" class="headerlink" title="執行後"></a>執行後</h2><p>在執行後可以看到 Robot Framework 產出的 report</p><p><img src="/img/2021-191743/1637074439.png"></p><p>在 report 中可以看到執行的時間與成功數量等，除此之外，你也能夠透過 report 看見執行的細節，例如 API 的 response json、該步驟的執行時間等</p><p><img src="/img/2021-191743/1637074452.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這一篇介紹了為何要使用 Robot Framework，再到如何看懂 Robot Framework 的文件，希望大家可以因為這篇而看得懂 Robot Framework &lt;(_ _)&gt;</p><p>已補坑：</p><ul><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Suite Setup V.S. Test Setup</a></li><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">在 Robot Framework 中，使用 config.ini 的檔案定義環境變數</a></li></ul><p>2021&#x2F;11&#x2F;16：補充執行所需的環境準備以及實際的題目應用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩&lt;/p&gt;
&lt;p&gt;這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 4/17 技術管理者論壇－商業與技術的平衡</title>
    <link href="https://blogs.sqz777.com/2021/04/18/2021-235858/"/>
    <id>https://blogs.sqz777.com/2021/04/18/2021-235858/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>好久沒參加社群了，筆記一下！ </p><p>昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了</p><p>這天講的內容印象最深刻有 2 個+1個</p><ul><li>Gipi 講的上游理論</li><li>91 來我們這組討論</li><li>我自己提出的問題（群組沒討論，但是我自己想了一輪 XD）</li></ul><h2 id="上游理論"><a href="#上游理論" class="headerlink" title="上游理論"></a>上游理論</h2><p>Gipi 描述了問了大家一個問題</p><blockquote><p>「今天你待的地方是在中游，有一天你發現上游的人開始丟垃圾、拉屎在河裡，讓你平常用的水變成垃圾水、糞水，請問你們會怎麼做？」</p></blockquote><p>台下的人很踴躍的回答了</p><p>「找上游的人理論」</p><p>「烙下游的人一起去找上游的人理論」</p><p>「找別條河」</p><p>．．．</p><p>最後有一個人回答了關鍵的答案 我猜是樁腳</p><blockquote><p>「去幫助上游的人」</p></blockquote><h3 id="為什麼是去幫助上游的人？"><a href="#為什麼是去幫助上游的人？" class="headerlink" title="為什麼是去幫助上游的人？"></a>為什麼是去幫助上游的人？</h3><p>因為上游的人讓河流變髒了，肯定是有原因的，沒有人平白無故把珍貴的資產－河流變糟<br>在幫助他們時，你就必須去了解他為什麼要把這些垃圾、排泄物丟進河裡 這會使你更能體諒他們為何這樣做，也會讓他們知道你不是來出一張嘴的</p><h3 id="和他們一起解決問題是最容易的"><a href="#和他們一起解決問題是最容易的" class="headerlink" title="和他們一起解決問題是最容易的"></a>和他們一起解決問題是最容易的</h3><p>就算你最後沒辦法和他們一同解決這些問題，你仍然能夠在這個幫助的過程中獲得一些經驗，而這些難得的經驗能夠成為你在抵達下一條河流時的養分。<br>千萬不要在發現河流中出現異樣時，只抱怨，不做事，這樣不但沒辦法改變現狀，也無法學習到任何事情。 上述所提到的河流可以替換成公司，中游則是你自己在公司所代表的角色，而上層可以替換成任何與你合作的對象。</p><h2 id="小組討論"><a href="#小組討論" class="headerlink" title="小組討論"></a>小組討論</h2><p>我們這組提到了不少問題，其中有被拿出來討論的就是</p><blockquote><p>如何讓技術能夠量化並且順利推動？</p></blockquote><p>91：「你要做到的是用他的語言來去描述你想做的事情，你所提出的事情要能夠打到他在意的點，舉例來說你要推 CI&#x2F;CD、TDD，商業的人，像是業務、老闆要怎麼懂？」<br>「你要做的是『你跟老闆說你做 OOXX 事情，目的可以節省多少時間』，而使用這個節省的時間來推算能夠節省的金錢」<br>「如果某些提出來的功能很急而影響到你目前的實作進度，你也可以透過埋 log、埋 GA，觀察他所謂『很急』的功能的使用率，讓數據說話」</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li>用對方在乎的事情解釋<ul><li>用時間推算金錢成本，花下去的成本用多少時間可以回收？</li></ul></li></ul><h2 id="我自己提出的問題"><a href="#我自己提出的問題" class="headerlink" title="我自己提出的問題"></a>我自己提出的問題</h2><p>我提出的問題沒有被我們這一組的其他人選擇，因為我自己提出的問題比較沒有符合今天的主題「商業與技術的平衡」（也許是因為菜味十足的我還沒碰到技術與商業平衡的問題 🤡🤡）</p><p>因為最近才剛開始在團隊中整理一些程式碼，幫忙寫一些 Unit Test，在這個過程中發現了一些現象，所以我提出的問題是</p><blockquote><p>如何讓團隊有一個更完整（良好）的開發規範</p></blockquote><p>例如：在 C# 中偏好使用 var 來做變數的宣告等…</p><p>這兩天我思考了一下，我覺得像這樣的程式語言的「使用偏好」，比較像是「傳教」，而不是商業與技術中的平衡，所以沒被拿出來很正常w</p><p><img src="/img/2021-235858/artworks-000118550301-1jpyp5-t500x500.jpg" alt="玖壹壹- 歪國人( 小八2015.5.25 ReMiX - ) by Dj小八Taiwan"></p><p>今天跟我弟討論了一輪，在對話的過程中，我找到了一個…出入，或許說是一個…題目？</p><blockquote><p>如何傳教成功？</p></blockquote><p>首先我必須先認知到傳教不是吵架辯論，而是你認為這個東西超讚，所以你覺得其他人也應該要跟我一起信仰他<br>如果我透過吵架辯論的方式，我應該永遠無法傳教成功，甚至會把他推得更遠（尤其是這個跟我辯論的人，是我的同事）<br>你應該很難想像騎腳踏車上路的傳教士跟機車騎士在路邊爭論打架吧？  </p><p>在這邊先打住，在這邊列一下今天我跟我弟的討論內容</p><p>我：「你覺得到底該怎麼樣，才能讓團隊裡面的人使用到這些偏好？」<br>他：「我覺得沒有必要推這件事，這件事（以偏好使用 var 來說）對於最後所產出的價值並不會影響到很大」<br>我：「所以你的意思是說這些偏好其實都是沒有價值的嗎？」<br>他：「也不能這樣說，舉個我前公司的例子，他們有一個規範是為了方便找到這個 Function 所以在 Class 中的所有 Function 排序是有一定規則的，當我問到我的 Team Lead 時，他就是這麼跟我解釋的，所以我也會認同這件事，因為這個規範就已經是存在，而且我們團隊的人都認同這件事。」 <br>我：「也就是說如果有一個規範，他是由團隊內德高望重的人在專案中使用，那他就會被大家遵守囉？」<br>他：「是」<br>我：「那假設你今天是團隊中德高望重的人，你要怎麼讓大家使用這些偏好？」<br>他、我：「…」</p><p>這個空氣靜默的時間很短，大概有一秒那麼長</p><p>我就想出了一個解答並說：</p><blockquote><p>「這件事並不是由團隊中德高望重的人來讓大家使用，而是在你做這件事情的時候，大家也都認同，在這個情況之下，你也不用『讓』大家使用這些偏好了，他們自己就會『自動』使用這些偏好了」</p></blockquote><p>所以最後的問題就不會是「如何傳教成功？」了</p><p>而是</p><blockquote><p>你在團隊中如何建立 Credit，影響到其他人？</p></blockquote><p>知道真正的問題是這個，做法就變得顯而易見了！</p><p>雖然心中有一些答案但是仍然想問大家的就是，我最後所提到的問題</p><p><strong>你在團隊中如何建立 Credit，影響到其他人？</strong></p><p>以上是今天的筆記，感謝大家收看，如有錯誤麻煩提出來讓我修正 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久沒參加社群了，筆記一下！ &lt;/p&gt;
&lt;p&gt;昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了&lt;/p&gt;
&lt;p&gt;這天講的內容印象最深刻有 2 個+1個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gipi 講的上游理論&lt;/li&gt;
&lt;li&gt;91 來我們這組討論&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="社群" scheme="https://blogs.sqz777.com/tags/%E7%A4%BE%E7%BE%A4/"/>
    
    <category term="筆記" scheme="https://blogs.sqz777.com/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="商業與技術" scheme="https://blogs.sqz777.com/tags/%E5%95%86%E6%A5%AD%E8%88%87%E6%8A%80%E8%A1%93/"/>
    
  </entry>
  
  <entry>
    <title>筆記－什麼是時序耦合（Temporal Coupling）？</title>
    <link href="https://blogs.sqz777.com/2021/04/18/2021-what-is-temporal-coupling/"/>
    <id>https://blogs.sqz777.com/2021/04/18/2021-what-is-temporal-coupling/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式</a><br>其中第四章提到了時序耦合（Temporal Coupling）<br>覺得是一個值得寫下來筆記的東西，所以就產出了這篇。</p><p>第一次看到時序耦合這個詞的時候還以為是…Dio?</p><p><img src="/img/2021-what-is-temporal-coupling/1618680807.png"></p><p>結果並不是，讓我太失望了（並沒有失望）</p><h2 id="正文開始"><a href="#正文開始" class="headerlink" title="正文開始"></a>正文開始</h2><p><strong>耦合是指程式中模組及模組之間資訊或參數依賴的程度。</strong><br><strong>其相對的一個概念的詞叫做聚合性，也就是說低耦合性代表高內聚性。</strong></p><p>時序耦合是多種耦合分類中的其中一種　<a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>時序耦合指的是這個 Class 中含有的 Functions 有隱性的「先後順序」的耦合性，這是一個「Design Smell」<br>舉參考資料的程式碼為例</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public void Initialize(string fileName)  /&#123;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>使用這個程式碼，會是這樣</p><pre><code>var fileName = &quot;C:\test.txt&quot;;var fileLogger = new FileLogger();fileLogger.Initialize(fileName);fileLogger.Write(&quot;Log message.&quot;);</code></pre><p>假設這個 fileLogger 沒有在呼叫 Write 這個 Function 之前先呼叫 Initialize 就會造成 fileLogger 在 Write 訊息的時候造成無法找到檔案名稱的錯誤<br>而這樣子的程式碼所造成的結果就稱之為時序耦合。</p><h2 id="如何避免時序耦合"><a href="#如何避免時序耦合" class="headerlink" title="如何避免時序耦合?"></a>如何避免時序耦合?</h2><h3 id="透過-Constructor-Injection-的方式"><a href="#透過-Constructor-Injection-的方式" class="headerlink" title="透過 Constructor Injection 的方式"></a>透過 Constructor Injection 的方式</h3><p>在這個案例中，可以透過 Constructor Injection 的方式進行注入 fileName 即可<br>範例程式碼</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public FileLoger(string fileName)  /&#123;    if(string.IsNullOrEmpty(fileName))    /&#123;      throw new ArgumentNullException(&quot;fileName&quot;);    /&#125;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>這樣的方式除了可以避免時序耦合之外，也能夠減少外部呼叫的次數（不需要再呼叫 Initialize）。<br>另外也能夠透過建構子的方式觀察到這個 FileLogger 本身所依賴的事情有哪些。</p><p>參考資料：<br><a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br><a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式 (Dependency Injection: Principles, Practices, Patterns, 2&#x2F;e)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>備註：<a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br>這篇當中有提到另一個避免時序耦合的方式（抽象工廠 <strong>abstract factory</strong>），但如果沒有特殊限制的話，我會比較偏好使用本篇所記錄的 constructor injection 的方式來避免時序耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看 &lt;a href=&quot;https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw&quot;&gt;依賴注入：原理、實作與設計模式&lt;/a&gt;&lt;br&gt;其中第四章提到了時序耦合（Temporal Couplin</summary>
      
    
    
    
    
    <category term="筆記" scheme="https://blogs.sqz777.com/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="DI" scheme="https://blogs.sqz777.com/tags/DI/"/>
    
    <category term="CodeSmell" scheme="https://blogs.sqz777.com/tags/CodeSmell/"/>
    
  </entry>
  
  <entry>
    <title>C# - Dotnet core 的 DI 如何在註冊時帶給建構子未註冊進 DI 的服務</title>
    <link href="https://blogs.sqz777.com/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/"/>
    <id>https://blogs.sqz777.com/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.831Z</updated>
    
    <content type="html"><![CDATA[<p>因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體</p><h2 id="註冊已經註冊進-DI-的實體"><a href="#註冊已經註冊進-DI-的實體" class="headerlink" title="註冊已經註冊進 DI 的實體"></a>註冊已經註冊進 DI 的實體</h2><h2 id="程式碼準備"><a href="#程式碼準備" class="headerlink" title="程式碼準備"></a>程式碼準備</h2><p>準備 interface IAction 跟 class Action</p><pre><code>public interface IAction/&#123;    void ShakeHands();/&#125;public class Action : IAction/&#123;    public void Dance()    /&#123;        Console.WriteLine(&quot;Dancing!&quot;);    /&#125;/&#125;</code></pre><p>準備一個 dog 的 interface 跟 他的 class，並且需要透過建構子注入 IAction 這個服務</p><pre><code>public interface IDog/&#123;    void DogDance();/&#125;public class Dog : IDog/&#123;    IAction _action;    public Dog(IAction action)    /&#123;        _action = action;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;/&#125;</code></pre><p>蛤? 你說狗不會跳舞怎麼可以繼承 IAction 然後 Dance?</p><p>這不是在跳了嗎(誤</p><p>主程式碼 長這個樣子</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog, Dog&gt;();    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();/&#125;</code></pre><p>就可以看到執行結果</p><pre><code>Dog isDancing!</code></pre><p>如果是已經註冊進 DI 的服務，服務在啟動時會自動幫忙注入已經註冊的實體，所以只要<code>serviceCollection.AddScoped&lt;IDog, Dog&gt;();</code>即可</p><h2 id="註冊時，代入未註冊進-DI-的實體"><a href="#註冊時，代入未註冊進-DI-的實體" class="headerlink" title="註冊時，代入未註冊進 DI 的實體"></a>註冊時，代入未註冊進 DI 的實體</h2><p>這時就需要將原本的 Dog 多新增一點需要依賴的服務啦，最近 Cyberpunk 2077 很紅，那就讓它變成機器狗吧</p><p><img src="/img/2021-DotnetCoreDIConstructorWithParameters/4137968e6d4fab392ba7db14017ec100.jpg" alt="Dogenator | Cyberpunk, Cyberpunk 2077, Dog communication"></p><p>所以就先定義一個 Machine 的 class 吧!</p><pre><code>public class Machine/&#123;    public void Glow()    /&#123;        Console.WriteLine(&quot;Glowing!&quot;);    /&#125;/&#125;</code></pre><p>機器人的特色就是會發光 所以就讓他可以 Glow!</p><p>接下來將狗的 Constructor 變成需要多依賴 Machine 這個 class 吧!</p><pre><code>public interface IDog/&#123;    void DogDance();    void DogGlow();/&#125;public class Dog : IDog/&#123;    IAction _action;    Machine _machine;    public Dog(IAction action, Machine machine)    /&#123;        _action = action;        _machine = machine;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;    public void DogGlow()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _machine.Glow();    /&#125;/&#125;</code></pre><p>主程式碼修改成這樣</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();    dog.DogGlow();/&#125;</code></pre><p>關鍵在於這一行，</p><pre><code>serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));</code></pre><p><code>svc</code> 的類別是 <code>IServiceProvider</code><br><code>new Dog</code> 的意思可以理解為 將 Dog 註冊至 IDog 中<br>而<code>svc.GetService&lt;IAction&gt;(), new Machine()</code>這部分可以理解為取得已經註冊的實體並注入進 new Dog 的這個 constructor 中</p><p>就可以看到執行結果</p><pre><code>Dog isDancing!Dog isGlowing!</code></pre><p>以上為今天的筆記<br>感謝收看!</p><p>本篇的 github 連結:<br><a href="https://github.com/SQZ777/DotnetCoreDIWithParamter">SQZ777&#x2F;DotnetCoreDIWithParamter (github.com)</a><br>Refrence:<br><a href="https://blog.darkthread.net/blog/aspnet-core-di-notes/">筆記 - 不可不知的 ASP.NET Core 依賴注入-黑暗執行緒 (darkthread.net)</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-5.0&WT.mc_id=DOP-MVP-37580#Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_AddScoped__1_Microsoft_Extensions_DependencyInjection_IServiceCollection_System_Func_System_IServiceProvider___0__">ServiceCollectionServiceExtensions.AddScoped 方法 (Microsoft.Extensions.DependencyInjection) | Microsoft Docs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體&lt;/p&gt;
&lt;h2 id=&quot;註冊已經註冊進-DI-的實體&quot;&gt;&lt;a href=&quot;#註冊已經註冊進-DI-的實體&quot; class=&quot;headerlink&quot; title=&quot;註冊已</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://blogs.sqz777.com/tags/NetCore/"/>
    
    <category term="Constructor" scheme="https://blogs.sqz777.com/tags/Constructor/"/>
    
    <category term="DI" scheme="https://blogs.sqz777.com/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>C# - 如何在 AWS lambda 裡面使用 dotnet core 的 DI</title>
    <link href="https://blogs.sqz777.com/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/"/>
    <id>https://blogs.sqz777.com/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/</id>
    <published>2021-03-14T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>dotnet core 的 DI 很好用</p><p>所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI</p><p>首先先建立一個 interface, 就叫 ITalkService 好了~</p><pre><code>namespace AWSLambdaAndDI/&#123;    public interface ITalkService    /&#123;        string SayHello(string name);    /&#125;/&#125;</code></pre><p>再寫一個他的實體 TalkService</p><pre><code>namespace AWSLambdaAndDI/&#123;    public class TalkService : ITalkService    /&#123;        public string SayHello(string name)        /&#123;            return name + &quot;: hello!&quot;;        /&#125;    /&#125;/&#125;</code></pre><p>這樣一來我們已經有了 interface 也有實作他的 class，接下來就來看一下如何在一般的 function 使用 dotnet core 的 DI 吧</p><p>首先需要使用 dotnet core CLI 來新增 package</p><pre><code>dotnet add package Microsoft.Extensions.DependencyInjection</code></pre><p>裝完之後就可以看到相依性裡面的套件出現 Microsoft.Extensions.DependencyInjection</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615732181.png"></p><p>我使用了 Visual Studio 來建立了一個 AWS Lambda 的專案，初始的程式碼會長這樣，並將這個 lambda 的 function 相依於前面已經實作好的 interface</p><pre><code>using Amazon.Lambda.Core;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    private readonly ITalkService _talkService;    public class Function    /&#123;                /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return input?.ToUpper();        /&#125;    /&#125;/&#125;</code></pre><p>如果要加入 DI ，需要在 constructor 中將需要用的 instance 跟對應到的 interface 進行註冊</p><p>constructor 的 code 會長這個樣子</p><pre><code>public Function()/&#123;  // 建立 DI  var serviceCollection = new ServiceCollection();  // 將 TalkService 註冊進 DI  serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();  var serviceProvider = serviceCollection.BuildServiceProvider();  // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface  this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();/&#125;</code></pre><p>確定好 talkService 註冊並且注入進 this._talkService 之後，就將 talkService 放進 FunctionHandler 中吧!<br>目前的 Lambda Function code 就會長這個樣子</p><pre><code>using Amazon.Lambda.Core;using Microsoft.Extensions.DependencyInjection;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    public class Function    /&#123;        private readonly ITalkService _talkService;        public Function()        /&#123;            // 建立 DI            var serviceCollection = new ServiceCollection();            // 將 TalkService 註冊進 DI            serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();            var serviceProvider = serviceCollection.BuildServiceProvider();            // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface            this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();        /&#125;        // 如果需要 unit test 可以利用這個 constructor 來進行 mock talkService        public Function(ITalkService talkService)        /&#123;            this._talkService = talkService;        /&#125;        /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return this._talkService.SayHello(input);        /&#125;    /&#125;/&#125;</code></pre><p>接著來使用 Mock Lambda Test Tool 來執行看看吧</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615734335.png"></p><p>以上就可以看到結果囉 “SQZ777: hello!”</p><p>如果以上訊息有任何錯誤麻煩告知 感謝各位大大 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dotnet core 的 DI 很好用&lt;/p&gt;
&lt;p&gt;所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI&lt;/p&gt;
&lt;p&gt;首先先建立一個 interface, 就叫 ITalkService 好了~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://blogs.sqz777.com/tags/NetCore/"/>
    
    <category term="awsLambda" scheme="https://blogs.sqz777.com/tags/awsLambda/"/>
    
    <category term="dependencyInjection" scheme="https://blogs.sqz777.com/tags/dependencyInjection/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 將自己做好的 Discord bot 放在 Heroku 上</title>
    <link href="https://blogs.sqz777.com/2020/11/24/2020-putDiscordBotToHeroku/"/>
    <id>https://blogs.sqz777.com/2020/11/24/2020-putDiscordBotToHeroku/</id>
    <published>2020-11-24T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子</p><p>這一篇以 Discord bot 為示範</p><p>首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972847.png"></p><p>點選 Create new app，命名自己的 app</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972936.png"></p><p>新增完畢之後就可以看到這個畫面，接著點選 GitHub</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973124.png"></p><p>這邊要輸入自己要建置的 bot repo name然後按下 Search 之後再按下旁邊那個 Connect 的按鈕<br><a href="https://dotblogs.com.tw/Im_sqz777/2020/11/21/DiscordSetupHelloWorld">如何建置 Discord bot 點這裡</a></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973433.png"></p><p>連結完畢之後會看到這個畫面，下面那個 Deploy Branch 按下去就是把機器人建置起來了<br><strong>但是先等一下!!!</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973597.png"></p><p>這邊需要先設定環境變數，我的機器人範例程式碼是這樣寫的，可以看到我需要環境變數 <strong>DISCORD_TOKEN</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973739.png"></p><p>所以我需要在 Heroku 上面設定 <strong>DISCORD_TOKEN</strong> 這個環境變數，在上面那排欄位中找到 Settings 進來之後點選 Reveal Config Vars</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973843.png"></p><p>點完之後，輸入變數名稱跟變數的值按下 Add 就可以成功新增環境變數</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974007.png"></p><p>在按下 Deploy 前請先確定自己的 package.json 中，有沒有設定好 npm start 要建置的 js file，如下</p><p>Heroku 在 Node.js 的專案中會執行 npm start 來執行專案</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974115.png"></p><p>確認完畢之後就可以回到這個頁面按下 Deploy Branch 囉!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974271.png"></p><p>回到 Discord 就可以看到自己的機器人上線啦!!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974342.png"></p><h2 id="澳門首家線上賭場上線啦"><a href="#澳門首家線上賭場上線啦" class="headerlink" title="澳門首家線上賭場上線啦"></a>澳門首家線上賭場上線啦</h2><p>以上是今天的筆記 感謝大家。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子&lt;/p&gt;
&lt;p&gt;這一篇以 Discord bot 為示範&lt;/p&gt;
&lt;p&gt;首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i</summary>
      
    
    
    
    
    <category term="discord" scheme="https://blogs.sqz777.com/tags/discord/"/>
    
    <category term="heroku" scheme="https://blogs.sqz777.com/tags/heroku/"/>
    
    <category term="nodejs" scheme="https://blogs.sqz777.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - Node.js 環境變數套件 dotenv</title>
    <link href="https://blogs.sqz777.com/2020/11/21/2020-231542/"/>
    <id>https://blogs.sqz777.com/2020/11/21/2020-231542/</id>
    <published>2020-11-21T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>開發時一定會用到環境變數，確保 config 可以快速被切換、程式碼不要包含機敏資料等等目的，所以就會透過 config 檔的方式來讀取各種機密資料</p><p>而 Node.js 可以透過 dotenv 來達成這件事</p><p>開始前你需要先安裝套件 dotenv</p><pre><code>npm install dotenv</code></pre><p> 在程式碼中引入這個套件</p><pre><code>require(&#39;dotenv&#39;).config()</code></pre><p>在使用前你需要建立一個檔案叫做 <strong>.env</strong><br>這個套件會去讀取這個檔案，讓這個檔案成為可以被 process.env 讀取的變數，格是為 &#x2F;{&#x2F;{變數名稱&#x2F;}&#x2F;}&#x3D;&#x2F;{&#x2F;{變數資料&#x2F;}&#x2F;}</p><pre><code>BLOG_NAME=SQZ777der技術小本本SECRET_TOKEN=secret tokenDB_CONNECTION=db connection</code></pre><p>透過 dotenv 讀取變數的程式碼如下</p><pre><code>require(&#39;dotenv&#39;).config()console.log(process.env.BLOG_NAME)console.log(process.env.SECRET_TOKEN)console.log(process.env.DB_CONNECTION)</code></pre><p>執行結果如下</p><p><img src="/img/2020-231542/1605971407.png"></p><p>以上是 dotenv 的簡單筆記<br>這邊是上面那些寫的程式碼 repo<br><a href="https://github.com/SQZ777/nodejs_dotenv_for_blog">https://github.com/SQZ777/nodejs_dotenv_for_blog</a></p><p>在一般專案開發時，請勿將 .env 這個檔案 commit 上去，此 repo 只是為了筆記而 commit .env 這個檔案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;開發時一定會用到環境變數，確保 config 可以快速被切換、程式碼不要包含機敏資料等等目的，所以就會透過 config 檔的方式來讀取各種機密資料&lt;/p&gt;
&lt;p&gt;而 Node.js 可以透過 dotenv 來達成這件事&lt;/p&gt;
&lt;p&gt;開始前你需要先安裝套件 dotenv&lt;</summary>
      
    
    
    
    
    <category term="Node.js" scheme="https://blogs.sqz777.com/tags/Node-js/"/>
    
    <category term="config" scheme="https://blogs.sqz777.com/tags/config/"/>
    
    <category term="dotenv" scheme="https://blogs.sqz777.com/tags/dotenv/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 透過 Node.js 建置 Discord BOT</title>
    <link href="https://blogs.sqz777.com/2020/11/21/2020-DiscordSetupHelloWorld/"/>
    <id>https://blogs.sqz777.com/2020/11/21/2020-DiscordSetupHelloWorld/</id>
    <published>2020-11-21T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>筆記一下如何透過 Node.js 建置 Discord 機器人</p><h2 id="什麼是-Discord"><a href="#什麼是-Discord" class="headerlink" title="什麼是 Discord"></a>什麼是 Discord</h2><p>Discord 是一個聊天通訊軟體，pc&#x2F;mobile 都可以使用，跟以前的 RC、TS 的軟體蠻像的</p><p>大部分的使用者都是遊戲玩家居多</p><p>他跟 Line 一樣也有提供相關的 API 可以使用!</p><p>本文範例程式碼：<a href="https://github.com/SQZ777/discord_bot_for_blog">https://github.com/SQZ777/discord_bot_for_blog</a></p><h2 id="環境-前置"><a href="#環境-前置" class="headerlink" title="環境&amp;前置"></a>環境&amp;前置</h2><ul><li><a href="https://nodejs.org/zh-tw/download/">Node.js</a></li><li><a href="https://discord.js.org/#/">discord.js</a></li><li><a href="https://discord.com/">Discord account</a></li></ul><h2 id="建立-Discord-Application"><a href="#建立-Discord-Application" class="headerlink" title="建立 Discord Application"></a>建立 Discord Application</h2><p>進到 discord 管理 application 的頁面 <a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a></p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944300.png"></p><p>可以看到自己已經建立的機器人，你的畫面應該是還沒有，所有要點擊右上角 <strong>New Application</strong>，之後命名一下自己的機器人名稱</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605944370.png"></p><p>建立完成之後可以看到自己的機器人相關的 token 等等的東西</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949979.png"></p><p>再來左邊的欄位選 bot 之後按下 Add Bot </p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949763.png">選 Yes, do it!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949840.png"></p><p>把 token 先存起來，等等要利用 nodejs 開發機器人的功能時會用到這個 token</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><h2 id="把機器人加入自己的伺服器"><a href="#把機器人加入自己的伺服器" class="headerlink" title="把機器人加入自己的伺服器"></a>把機器人加入自己的伺服器</h2><p>按下左邊欄位 OAuth2 之後 scopes 選擇 bot, 因為目前只有傳送訊息 所以 bot permissions 選擇 Send Messages，箭頭處的部分就是邀請 bot 加入伺服器的連結，把它複製起來。</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950673.png"></p><p>把剛才那個邀請連接用瀏覽器連結過去之後就會詢問你要將機器人放進哪個伺服器，選好之後按下繼續即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950830.png"></p><p>然後會問你是否需要授權，按下授權即可</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950878.png"></p><p>在伺服器就會看到機器人加入的訊息</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605950936.png"></p><h2 id="開始透過-Node-js-建置機器人"><a href="#開始透過-Node-js-建置機器人" class="headerlink" title="開始透過 Node.js 建置機器人"></a>開始透過 Node.js 建置機器人</h2><p>先使用 npm init 建立 package.json，再透過 npm 安裝 <a href="https://discord.js.org/#/">discord.js</a></p><pre><code>npm i discord.js</code></pre><p>建立一個檔案 app.js，範例原始碼來自於 <a href="https://discord.js.org/#/">discord.js</a> </p><pre><code>const Discord = require(&#39;discord.js&#39;);const client = new Discord.Client();client.on(&#39;ready&#39;, () =&gt; /&#123;  console.log(`Logged in as $/&#123;client.user.tag/&#125;!`);/&#125;);client.on(&#39;message&#39;, msg =&gt; /&#123;  if (msg.content === &#39;ping&#39;) /&#123;    msg.reply(&#39;Pong!&#39;);  /&#125;/&#125;);client.login(&#39;token&#39;);</code></pre><p>以上程式碼將最下方 client.login(‘token’) 的 ‘token’ 取代成剛才複製起來的 token 就可以了，忘記在哪這邊圖片附上複製位置</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605949915.png"></p><p>將機器人加入伺服器之後會發現機器人都是離線狀態(如圖)，是因為機器人目前沒有登入，我們需要執行我們的程式碼讓機器人登入</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951075.png"></p><p>執行 npm start，就會發現機器人登入了</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951375.png"></p><p>這時候就可以透過自己傳送 訊息 “ping” 來讓機器人回應你 “pong”，這樣就成功完成了一個機器人的 Hello World 囉!</p><p><img src="/img/2020-DiscordSetupHelloWorld/1605951410.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://discord.com/developers/docs/intro">Discord 官方文件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;筆記一下如何透過 Node.js 建置 Discord 機器人&lt;/p&gt;
&lt;h2 id=&quot;什麼是-Discord&quot;&gt;&lt;a href=&quot;#什麼是-Discord&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Discord&quot;&gt;&lt;/a&gt;什麼是 Discord&lt;/h</summary>
      
    
    
    
    
    <category term="Node.js" scheme="https://blogs.sqz777.com/tags/Node-js/"/>
    
    <category term="bot" scheme="https://blogs.sqz777.com/tags/bot/"/>
    
    <category term="discord" scheme="https://blogs.sqz777.com/tags/discord/"/>
    
    <category term="discord.js" scheme="https://blogs.sqz777.com/tags/discord-js/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 使用 PowerShell 安裝 aws cli</title>
    <link href="https://blogs.sqz777.com/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/"/>
    <id>https://blogs.sqz777.com/2020/09/24/2020-InstallAwsCliV2ViaPowerShell/</id>
    <published>2020-09-24T00:00:00.000Z</published>
    <updated>2025-09-01T14:55:46.830Z</updated>
    
    <content type="html"><![CDATA[<p>最近蠻常用到 AWS 的服務，而且需要在建機器的時候透過 powershell 來安裝 aws cli，所以就記錄一下這篇</p><p>本篇記錄時間為 2020&#x2F;09&#x2F;24，aws cli 的版本會隨著時間更新，今天示範的版本是 aws cli v2<br>請注意以下 $dlurl 的檔案位置是否已被 AWS 官方變更!</p><pre><code>#https://docs.aws.amazon.com/zh_tw/cli/latest/userguide/install-cliv2-windows.html$dlurl = &quot;https://awscli.amazonaws.com/AWSCLIV2.msi&quot;$installerPath = Join-Path $env:TEMP (Split-Path $dlurl -Leaf)Invoke-WebRequest $dlurl -OutFile $installerPathStart-Process -FilePath msiexec -Args &quot;/i $installerPath /passive&quot; -Verb RunAs -WaitRemove-Item $installerPath</code></pre><p>執行結果如下</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600961818.png"></p><p>會發現透過 aws –version 來確認是否安裝完成時，會出現錯誤，這時候如過不想要重開 powershell 就執行<a href="https://dotblogs.com.tw/Im_sqz777/2020/09/24/ReloadThePathInPowerShell">上一篇記錄</a>的程式碼</p><pre><code>$env:Path = [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;Machine&quot;)+ &quot;;&quot; + [System.Environment]::GetEnvironmentVariable(&quot;Path&quot;, &quot;User&quot;)</code></pre><p>執行之後再執行一次 aws –version 就可以成功執行囉~</p><p><img src="/img/2020-InstallAwsCliV2ViaPowerShell/1600962069.png"></p><p>source: <a href="https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf">https://gist.github.com/dansmith65/79275f15fe25550e65ccd4d6bf1448cf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近蠻常用到 AWS 的服務，而且需要在建機器的時候透過 powershell 來安裝 aws cli，所以就記錄一下這篇&lt;/p&gt;
&lt;p&gt;本篇記錄時間為 2020&amp;#x2F;09&amp;#x2F;24，aws cli 的版本會隨著時間更新，今天示範的版本是 aws cli v2&lt;</summary>
      
    
    
    
    
    <category term="aws" scheme="https://blogs.sqz777.com/tags/aws/"/>
    
    <category term="cli" scheme="https://blogs.sqz777.com/tags/cli/"/>
    
    <category term="install" scheme="https://blogs.sqz777.com/tags/install/"/>
    
    <category term="powershell" scheme="https://blogs.sqz777.com/tags/powershell/"/>
    
    <category term="安裝" scheme="https://blogs.sqz777.com/tags/%E5%AE%89%E8%A3%9D/"/>
    
  </entry>
  
</feed>
