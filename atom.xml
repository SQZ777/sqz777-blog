<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SQZ777&#39;s blog</title>
  
  
  <link href="https://blogs.sqz777.com/atom.xml" rel="self"/>
  
  <link href="https://blogs.sqz777.com/"/>
  <updated>2026-01-13T15:11:53.133Z</updated>
  <id>https://blogs.sqz777.com/</id>
  
  <author>
    <name>SQZ777</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>形上、懷疑、批判：知識論視角的軟體測試</title>
    <link href="https://blogs.sqz777.com/2026/01/11/2026-epistemology-and-software-testing.md/"/>
    <id>https://blogs.sqz777.com/2026/01/11/2026-epistemology-and-software-testing.md/</id>
    <published>2026-01-11T14:21:42.000Z</published>
    <updated>2026-01-13T15:11:53.133Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2026-epistemology-and-software-testing/image.png"></p><p>當代知識論學者雷勒 (Keith Lehrer) 觀察到的研究進路 (approach) 有三個</p><ol><li>形上</li><li>懷疑</li><li>批判</li></ol><p>形上知識論的代表哲學家可追溯至柏拉圖 (Plato)、亞里斯多德 (Aristotle)<br>形上學本身關心的是事物的根本性問題<br>因此形上知識論主要在探討「知識的本質是什麼」<br>也就是知識由哪些要素構成、它以什麼方式存在</p><p>懷疑知識論的代表哲學家是笛卡兒 (Descartes) (我思故我在)<br>懷疑知識論與形上知識論的最大差別在於<br>它並不先假定知識存在，而是採取方法論上的懷疑<br>暫時對一切知識主張保持不承認的態度<br>藉此回答「在懷疑一切的情況下，仍然無法被否定的基礎是什麼」</p><p>批判知識論看起來並沒有單一的代表哲學家<br>而是一種由多位哲學家共同發展出的研究進路<br>它關注的不是先給出知識的形而上結構<br>也不同於懷疑論對一切知識主張的全面否定<br>而是反思我們實際如何主張、辯護與修正知識本身</p><hr><p>如果用上面三個知識研究進路來思考軟體測試的話</p><p>得到的對應會是</p><h2 id="形上"><a href="#形上" class="headerlink" title="形上"></a>形上</h2><blockquote><p>假定系統的品質、行為、缺陷是「客觀存在的東西」</p></blockquote><ul><li>測試的本質是什麼?</li><li>bug 是什麼? (哪些條件構成一個 bug?)<ul><li>少了哪個條件，就不能算是缺陷?</li></ul></li><li>…</li></ul><h2 id="懷疑"><a href="#懷疑" class="headerlink" title="懷疑"></a>懷疑</h2><blockquote><p>任何「系統是安全的／可用的」說法都值得被懷疑</p></blockquote><ul><li>我們真的「知道」它沒問題嗎?</li><li>我們憑什麼相信這個測試結果?</li><li>我們如何排除「自己被誤導」的可能?</li><li>…</li></ul><h2 id="批判"><a href="#批判" class="headerlink" title="批判"></a>批判</h2><blockquote><p>測試是在不確定中，為「現在是否足夠可信」負責的判斷活動</p></blockquote><ul><li>在目前資訊下，我們是否「有理由」相信系統可用?</li><li>哪些風險是我們已知但選擇承擔的?</li><li>有沒有合理的反駁會推翻我現在的信心?</li></ul><hr><p>之前看到 James Bach 的書籍中或者訪談中都提到去理解知識論、價值論、形上學等哲學都可以幫助到測試</p><p>原本以為他想表達的是幫助到「執行測試的過程」，但稍微去了解知識論看到了這三種知識論的研究進路之後，才知道原來幫助的是「整個測試」，讓自己能夠透過哲學思考的工具來回答一些沒有好好思考會難以回答的問題</p><p>雖然這些問題在職涯上沒有少想過，但用哲學的角度來思考有一種…不一樣的感受?🤔</p><hr><p>在 2020 年寫過一篇 <a href="https://blogs.sqz777.com/2020/04/23/2020-224619/">從哲學解釋測試</a><br>文末列了不少偏批判會關心的測試問題</p><p>有趣的是最後一個問題<br>「這座橋怎麼樣才算是完成?」－決定這座橋的驗收方式，讓其他蓋這座橋的人也知道 DOD （definition of done）<br>用知識論的三種研究進路來看，會發現它其實同時涵蓋了三個層次</p><p>形上: 什麼條件構成一座完成的橋?<br>懷疑: 你怎麼知道這些驗收條件真的足夠?<br>批判: 我們在什麼條件下，合理主張這座橋完成了?</p><p>也就是說定義 DOD 會同時需要面對三個問題<br>拆解之後就知道定義 DOD 為甚麼是困難且重要的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2026-epistemology-and-software-testing/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;當代知識論學者雷勒 (Keith Lehrer) 觀察到的研究進路 (approach) 有三個&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="哲學" scheme="https://blogs.sqz777.com/tags/%E5%93%B2%E5%AD%B8/"/>
    
    <category term="軟體測試與哲學" scheme="https://blogs.sqz777.com/tags/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6%E8%88%87%E5%93%B2%E5%AD%B8/"/>
    
    <category term="軟體測試" scheme="https://blogs.sqz777.com/tags/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
  </entry>
  
  <entry>
    <title>一個測試者的獨白</title>
    <link href="https://blogs.sqz777.com/2026/01/04/2026-testing-paradigm-confusion/"/>
    <id>https://blogs.sqz777.com/2026/01/04/2026-testing-paradigm-confusion/</id>
    <published>2026-01-04T23:53:00.000Z</published>
    <updated>2026-01-13T15:11:53.133Z</updated>
    
    <content type="html"><![CDATA[<p>促使我開始寫這篇文章的契機，應該是源自 2021 年 11 月 17 日（好久以前），好朋友 Terry Wang 寫的<a href="https://wangterryonagile.blogspot.com/2021/11/scrum-master.html">《一個 Scrum Master 的獨白》</a>帶給我的啟發，<a href="https://www.youtube.com/watch?v=igRixuQpxns">影片版點我</a></p><p>這篇文章記錄了我身為一個偏 Developer 的人，在敏捷文化正於台灣崛起的浪潮裡選擇擔任 Tester，走過那些迷惘的敏捷&#x2F;測試旅程</p><p>近年我一直嘗試著把自己在測試職涯的「自我定位」寫下來，但最後都只停在幾段零碎的草稿<br>寫來寫去才發現我應該寫的是自己的迷惘，但始終無法解決自己在職涯上的迷惘，直到 2025 年 11 月，那本書的出現…</p><h2 id="2017-年"><a href="#2017-年" class="headerlink" title="2017 年"></a>2017 年</h2><p>2017 年，intern 時期跟另外 3 名 intern 一起維運著公司的人才庫系統，認識了 91（<a href="https://tdd.best/about/">Joey Chen</a>，不是 91APP），受到了很多的啟發，也是我決定了解敏捷文化的契機</p><p>現在回想起來那半年的實習，真的是我經歷過最教科書級的 Scrum，我猜是因為大家都沒有正職經驗，反而更願意照著 Scrum Guide 和 Scrum Master 的指示把節奏跑完整，Refinement, Planning, Daily, Review, Retro，一個迭代接一個迭代，單純、清楚、有效</p><blockquote><p><em>P.S. 現在 Scrum Guide 裡面沒有 Refinement Meeting，至少 2020 (latest) 的版本似乎沒有提到 😆</em> </p></blockquote><p>在這裡感謝當時的 tech lead Tim, Cash，讓我學到了很多技術和敏捷相關的事情，也感謝 Tamama team members，以及 Tamama team 的 scrum master Amy, Elton, Eason</p><p><img src="/../img/2026-testing-paradigm-confusion/image.png" alt="Tamama 的來由：在一部叫做《Keroro 軍曹》的動畫，裡面有一個見習的二等兵角色叫做 Tamama照片中的模型是從 intern 畢業時收到的禮物"></p><blockquote><p><em>Tamama 的來由：在一部叫做《Keroro 軍曹》的動畫，裡面有一個見習的二等兵角色叫做 Tamama<br>照片中的模型是從 intern 畢業時收到的禮物</em></p></blockquote><p>回想 2017 年真的是敏捷盛行的年代，各種 meetup 和討論都在那一年不斷的發生</p><p>實習結束之後，到了一間做開店平台服務的公司擔任 QA 一職，當年決定加入的原因有 2 個</p><ol><li>公司正在導入敏捷，我很想親眼看看「導入敏捷」在真實世界裡到底會發生什麼事，這在當時的氛圍下對我超有吸引力</li><li>我那時對 QA 的想像就是「測試」，而測試需要的能力面向很廣，剛好很符合我的個性。</li></ol><p>加入公司之前，我去參加了至少 2 場 Agile meetup，去問了各個業界的前輩關於如何當一個好的 QA&#x2F;QE，得到了許多的 feedback，感謝當時的自己寫下了一些筆記，或許可以找個時間來寫一個現在我對於測試工作的一些看法（挖坑）</p><p>第一份工作開始沒多久，我就成了公司裡蠻受關注的新人。原因很簡單，我跟當時公司裡其他測試人員不太一樣，我會一直用自己擁有的開發者技能，去做一些能輔助測試、也能幫到團隊的工具。那時候的我像海綿一樣，瘋狂閱讀、吸收測試相關知識，也很常在團隊裡主動嘗試新做法，例如舉辦 Bug Bash、Coding Dojo…等。這裡也要特別感謝當時的 Test Team Lead Matt, Ruddy 老師，願意鼓勵我去做這些事</p><p>在這份工作裡，我最難忘的，果然還是第一次加入的「導流 Team」。我們從 0 開始把系統建起來，測試工作真的不一定要追著開發進度跑</p><p>RD 願意也有能力把需求切碎、分批交付<br>PM 願意和我高頻率溝通<br>而我的自動化節奏也因此跟得上</p><p>每次調整或新增功能，我們都先用 E2E 自動化把各個路徑跑過一輪，幾分鐘內就能對版本建立信心，上線後也確實沒有遇到什麼嚴重問題（但我也不確定是不是記憶美化了，至少我印象中沒有遇過需要 rollback 的狀況）</p><p>真的很感謝當時導流 Team 的每一位，你們都很棒，這段經歷對我來說非常珍貴</p><p>另外，這份工作還有一件事對我後來職涯影響很深，在這裡開始接觸「測試環境」的建置<br>印象中當時是 Ken 和 Jason 一起把測試環境 build 起來<br>我那時其實貢獻不多，更多只是協助確認環境起來後需要的 init data 與可運作狀態<br>但這段經驗，卻奠定了我後來對測試環境建置與使用的一些想法。會開始重視「環境」這件事，也跟 Rick 有關，畢竟我算是看著 Rick 的部落格長大的（？），其中<a href="https://rickhw.github.io/2015/10/11/SQA/How-To-Be-An-SQA/">那篇文章</a>讓我更清楚建立環境的重要性</p><p>後來我也陸續加入其他 team，遇到很多有趣的事。只是那時候我還不夠成熟，在溝通與協作的細節上，現在回頭看其實有不少可以做得更好 🚬</p><p>在做這一份工作的後半段，或許是為了回應新團隊的期待，也或許是當時認為這樣才能展現我的價值，又或許是其他事情，我測試的工作也全然地改成「實作自動化」，而不再是以「手動測試」為主了(基本上已經不能叫做測試工作了)</p><p>現在回過頭來看，這個時間點是我職涯迷惘的開始（好早）</p><h2 id="迷惘是一陣一陣地"><a href="#迷惘是一陣一陣地" class="headerlink" title="迷惘是一陣一陣地"></a>迷惘是一陣一陣地</h2><p>迷惘來的時候很像潮汐，不會天天發生，但每次一來，腦袋就會自動跳出幾個困惑：</p><ul><li>把所有想到的案例都做成自動化，因為「測試」就是把案例走完了就好，所以這是測試者唯一能展現的價值？</li><li>敏捷團隊的願景是希望每一位開發者都進行測試，「每一個人」都為產出品質負責，「只」做測試不開發的我，是什麼？</li><li>Sprint 迭代的過程很快，能測試的時間很短，做完 Happy Test 以及簡單的邊界案例之後，把時間都拿去做自動化，感覺怪怪的？但看起來大家都覺得這是對的方向，Why？</li><li>…還有好多好多</li></ul><p>我一方面認為測試者真正能展現的價值，是在當下需求的 context 裡提出洞見、驗證風險<br>另一方面是實作自動化、把產出流程的品質顧好，也確實能替團隊帶來長期效益<br>再一方面是只要整個團隊都在意測試，那就不需要測試人員…嗎?</p><p>但不論在團隊內部或就業市場，「自動化」都被反覆強調。當時我一邊想把這些疑惑搞清楚，一邊也考量職涯的發展與收入，所以離開第一間公司，轉去做防毒軟體&#x2F;金流&#x2F;行銷的公司<br>只是到了新團隊，我依然主要在做自動化導入與架構設計<br>這些工作用不同方式落地時，我仍然感覺自己在創造價值，卻也更常思考所謂「有效率的測試」，究竟應該怎麼被執行、又該如何被記錄下來？</p><p>這個問號大多只停在我腦袋裡。我的工作與職涯重心仍然放在寫程式把自動化做得更完整、開發測試所需的輔助 Tools、建立自動化執行的 Pipeline 與測試環境……但我始終覺得，理解產品、揭露風險才是測試工作的本質<br>也因此，我一直覺得哪裡怪怪der，便持續翻閱各種測試文章想找答案<br>偏偏文章之間在細節上常互相衝突，而那些衝突，也正是讓我的迷惘反覆出現的原因</p><h2 id="走出迷惘"><a href="#走出迷惘" class="headerlink" title="走出迷惘"></a>走出迷惘</h2><p><img src="/../img/2026-testing-paradigm-confusion/takingTestingSeriously.jpg"></p><p>直到 2025 年 11 月，James Bach 以及 Michael Bolton 的著作 <a href="https://www.tenlong.com.tw/products/9781394253197"><em>《Taking Testing Seriously》</em></a>發表了出來，看完了第一章之後才理解原來我的疑惑正是關於測試的「思想學派」之間的衝突，下面是我將書中內容丟給 AI 做的翻譯（有些小地方我有調整一點用詞）</p><hr><p>1999 年，Cem Kaner、James Bach，以及另外幾位朋友，宣告我們是一個獨特的測試思想「學派（school）」，並把它命名為 Context-Driven。</p><p>成立一個學派，是為了把我們和其他學派區隔開來——至少就我們的理解是如此。雖然外界從來沒有形成廣泛共識，說這些學派應該如何辨識、如何命名，但目前我們（Michael 與 James）把它們大致分成以下幾類：</p><ul><li><strong>Factory School（工廠學派）</strong>：認為測試應該以產物與演算法為核心，而不是以測試者為核心——像大型工廠一樣，理論上工人可以被機器人取代。這個學派在產業界最主流，尤其是政府部門與受高度監管的情境。</li><li><strong>Quality School（品質學派）</strong>：認為「打造品質」才是核心，測試只是相對次要、甚至有點討人厭的活動；比起測試，更重要的是品質倡議。這個學派常反對設置專職測試者，因為他們主張「整個團隊都擁有品質」。</li><li><strong>Agile&#x2F;DevOps School（敏捷&#x2F;DevOps 學派）</strong>：類似品質學派，但更被產品交付的命令式要求與機制主導。認為測試應由開發者做，並在持續交付管線中自動化；主張不該有全職測試者，除非只是暫時的權宜之計。</li><li><strong>Analytical School（分析學派）</strong>：幾乎只存在於學界。把測試視為電腦科學的一部分，當作演算法流程；追求在受控條件下，用數學模型化與最佳化測試的理論與方法。</li><li><strong>Context-Driven School（情境驅動學派）</strong>：認為不存在「最佳實務」，專業測試者應培養能力，去設計並論證適合自己專案的測試做法。此學派認為測試是社會性的、心理性的、啟發式（heuristic）的過程。<strong>Rapid Software Testing (RST)</strong> 是一種情境驅動的方法論。</li></ul><p>每一個思想學派都是一種<strong>典範（paradigm）</strong>——也就是一個包山包海的世界觀。科學中「典範」這個概念，最早是由 Thomas Kuhn 在其經典著作 <em>The Structure of Scientific Revolutions《科學革命的結構》</em>中提出的。<br>我們之所以說上述這些學派是典範，是因為當我們遇到其他學派的思想者時，常常根本不覺得他們在談「測試」。差異就是大到這種程度。典範之間的對話向來很難，不只因為同樣的詞會被用出不同意思，更因為對其中一方而言很重要的問題，對另一方可能根本不存在。舉例來說，<strong>Factory School</strong> 的測試實作者很在意「測試案例有沒有寫對」；但 <strong>Context-Driven</strong> 的測試者可能整個專案跑完，都沒想過「測試案例」這件事。當一個 Factory School 的人漏掉 bug，他會想：「我漏掉是因為我沒有某個測試案例，解法就是把那個案例加上去。」而當我們在 <strong>RST（Rapid Software Testing）</strong> 裡漏掉 bug，我們會想：「我能從這件事學到什麼？只有先學到，我才知道接下來該怎麼做。」從 Factory 的角度看，RST 像是自我膨脹的哲學空談；從 RST 的角度看，Factory 像是在做一套討好主管的儀式。<br>Ludwig Wittgenstein 用「<strong>form of life（生活形式）</strong>」這個詞，來描述構成人類社會生活的整體：各種實作、行為、規則、模式等等。他有個著名主張：所有語言都扎根於某種生活形式，離開孕育它的活動就無法理解。你若沒有沉浸在那些詞所屬的文化裡，就不可能真正理解那些詞的意思。</p><p>那我們為什麼要寫這麼多哲學？是為了<strong>讓你先做好準備</strong>。本書描述的測試文化，很可能跟你在一般軟體專案裡觀察到的、或在網路上看測試 demo 所吸收到的很不一樣。Context-Driven 的方式不只是一種方法：它同時也是一種典範、一種文化、一種生活形式。</p><p>看看書名吧。準備好<strong>認真看待測試 (Preparing to taking testing seriously)</strong><br>如果你想把自己培養成軟體測試的專家，我們希望幫你在「測試思想的市場」裡，成為一個有鑑別力的顧客。</p><p>但如果典範是包山包海的世界觀，那人怎麼可能改變典範？又為什麼有人想從不同典範裡挑挑選選？畢竟每個典範都涵蓋世界的一切。Thomas Kuhn 的回答是：典範彼此競爭，取決於它們留下哪些「無法解的謎題」。當你被那些謎題折磨得夠久，你就會對其他存在與工作的方式敞開心胸——而這正是科學革命之所以發生的原因。</p><p>其他測試典範在追求一套完美的「最佳實務」。而所有難題中的那個無解難題，歸根究柢就是這件事。本書作者相信他們永遠不會成功。</p><p>工廠學派自 1960 年代以來主導這個領域，他們拿得出來的成果是：<strong>V-model</strong>、把 <strong>ISTQB</strong> 證照發給任何能死背制式答案的人，以及一個在本文寫作當下反而比 40 年前更不被尊重的測試產業。<strong>Agile&#x2F;DevOps</strong> 陣營如今聲勢正旺，結果是沒人想當 tester。（他們希望你只是「team member」，而不是把重心放在測試上。）以 <strong>AI</strong> 為基礎的測試工具，有些確實耐人尋味，有些則爛得讓人訝異，卻把管理者搞糊塗了，以為按個按鈕就能測試。整個產業一路從趨勢晃到趨勢（trend to trend）、從工具換到工具（tool to tool），但仍然有太多軟體產品不可靠、用起來不令人滿意；使用者甚至被騙得以為，期待產品如承諾般正常運作，是要求太多。</p><p>我們在情境驅動典範裡相信：<strong>人、啟發式、技能、倫理</strong>才是核心，因為這能找出更多 bug、也找出更重要的 bug；能吸引更有天份的人投入測試；也能讓社會更好。對我們而言最難的謎題是：如何訓練與管理測試者，讓他們能在一個主要只在乎快速賺錢、並希望測試是一套固定演算法而不是開放式調查的世界裡運作。</p><hr><p>以上是書中第一章的一部分翻譯</p><p>讀到這段之後，我才發現多年來的迷惘，是我內心中的「典範」一直在互相衝撞，而且不是兩個，是三個</p><p>第一個，是 Context-Driven 的世界觀，與邰曉梅老師的著作<em>《海盜派測試》</em>，是相同的世界觀。這個世界觀在意的是 Context (上下文)，你必須自行識別風險並彈性的調整目標抱持著好奇心不斷地進行測試，在每一次測試後都要不斷地問問自己「你真的了解產品了嗎？」、「你真的知道此刻最重要的風險了嗎？」、「你能描述這整個測試的脈絡，並清楚知道為甚麼這樣測嗎？」</p><p>第二個，來自敏捷團隊常見的說法「品質是『整個團隊』的責任、測試應該由開發者在 pipeline 裡完成、專職 tester 只是暫時的過渡角色。」這讓我卡在一個很自我衝突的位置，如果每個人都應該做測試，那我的責任是不是讓團隊不需要倚賴測試人員？</p><p>第三個，是把測試當成可被流程化的工廠，把需求拆成測試案例、把案例跑完、把案例自動化，最後用「覆蓋率」與「通過率」交差。於是我腦中常浮現一種焦慮：「是不是只要我把想到的案例全部變成自動化，測試者的價值就算交付了？好像測試等於把 checklist 打勾，越多越好？」</p><p>Sprint 迭代很快、可測時間很短，我做完 Happy Path 與幾個邊界就差不多要交付了，接下來把時間全部砸去做自動化，心裡卻一直覺得怪。我知道這對交付流程有幫助，但它看起來更像在追求「可量化的產出」，而不是在追問「產品此刻最大的風險是什麼」<br>偏偏團隊與就業市場又一致強調「自動化」的重要性，彷彿不自動化就不專業、不進步</p><p>我一直同時相信兩件事：</p><ul><li>測試者真正的價值，是在特定需求與情境（context）下，提出洞見、test ideas 、揭露風險</li><li>自動化、工具與流程品質也很有價值，能讓團隊交付更穩、更快、更可重複</li></ul><p>問題在於當大家把「自動化」當成測試本體時，測試的本質就被擠到暗黑的角落，而我自己也隨波逐流，遺忘了測試的本質（真虧我自己以前還分享過測試本質的演講…haha）</p><p>看到這本書之前，我一邊寫程式把自動化做得更完整，一邊又不斷翻測試文章想找答案<br>但越看越矛盾，有些文章把 test cases 與 best practices 說得像唯一正解，有些又強調測試應該回到人、技能、判斷與探索。這些細節上的互相衝突，一直在我內心不斷的碰撞著</p><p>直到我讀到這本書把「不同測試文化&#x2F;典範」列出來，我才終於明白，我的內心一直在這幾個世界觀之間打架<br>當我用其中一個世界觀去衡量另一個世界觀時，當然會覺得哪裡都怪怪 Der</p><p>感謝這本書的出現，讓我在得知這些學派之後，能夠好好地思考想要精進的方向</p><h2 id="接下來呢"><a href="#接下來呢" class="headerlink" title="接下來呢?"></a>接下來呢?</h2><p>正如<a href="https://www.youtube.com/watch?v=m9tNBHBKMpU&t=1s">邱威傑在 TED Talk</a> 所說：「人生沒有一條路是白走的」，我相信接下來的職涯，會讓我更清楚自己真正想走的路會長成什麼樣子</p><p>當我終於釐清了這些困惑與內心衝突，接下來要面對的，就不再是「感覺怎樣都怪怪的」，而是如何重新調整我在工作上的投入比例，以及我想交付的工作內容，哪些要用工程手段把地基打穩、哪些要把心力放回理解產品與揭露風險</p><p>一路上前輩們的指點都是有用的，一路上我做過的那些技術實作，像是測試環境的建置自動化、Automation 架構設計、CI&#x2F;CD Pipeline 規劃與落地也都不是繞遠路。它們讓我更懂得如何讓團隊跑得更穩、更快，也讓我有能力把「測試」從一次次手動執行，推進到可重複、可擴張、能長期維護的系統</p><p>首先感謝自己在 2025 年 10 月 17 日決定斷絕所有社群平台，歷經長達 11 周的無社群平台生活，讓我多了很多時間可以閱讀、寫作、關心自己應該關心的事情🏃‍♂️<br>感謝 Esther 和 Jersey 在 6 年前的留言鼓勵，雖然每年的 blog post 產量仍然遠不及 2017, 2018 的自己，但我會持續的努力<br><img src="/../img/2026-testing-paradigm-confusion/image%201.png" alt="image.png"><br>也很感謝 Ruddy 老師在我離開第一份工作的那一天，對我說的那句話：「勇於嘗試。」<br>這句話不斷地在提醒我別怕走一段不確定的路，因為每一步都會在未來串成答案</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;促使我開始寫這篇文章的契機，應該是源自 2021 年 11 月 17 日（好久以前），好朋友 Terry Wang 寫的&lt;a href=&quot;https://wangterryonagile.blogspot.com/2021/11/scrum-master.html&quot;&gt;《一個</summary>
      
    
    
    
    
    <category term="軟體測試" scheme="https://blogs.sqz777.com/tags/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    <category term="測試職涯" scheme="https://blogs.sqz777.com/tags/%E6%B8%AC%E8%A9%A6%E8%81%B7%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>好爽喔，原來可以在瀏覽器 Console 操作 Pinia 狀態</title>
    <link href="https://blogs.sqz777.com/2025/10/08/2025-how-to-control-pinia-in-browser-console/"/>
    <id>https://blogs.sqz777.com/2025/10/08/2025-how-to-control-pinia-in-browser-console/</id>
    <published>2025-10-08T22:26:30.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2025-how-to-control-pinia-in-browser-console/image.png" alt="alt text"></p><p>今天在測試 Vue 專案時，我臨時需要切換某個使用者狀態，這招從 AI 偷學來的😜<br>結果發現透過瀏覽器的 console 就能直接操作 Pinia 的 state，像這樣</p><pre><code class="js">const pinia = document.querySelector(&#39;#app&#39;).__vue_app__.config.globalProperties.$piniapinia.state.value.user.isWarningMessageDismissed = false</code></pre><p>執行後畫面立刻更新，完全不需要重新登入或透過後端修改資料，太爽辣~<br>但爽歸爽還是得注意一下相關的風險</p><p>這篇就來簡單介紹一下 Pinia，並說明為什麼這種做法 <strong>不建議</strong> 用在較複雜的測試或正式驗證流程中<br>以及該如何用更穩健的方式處理</p><h2 id="🧩-什麼是-Pinia？"><a href="#🧩-什麼是-Pinia？" class="headerlink" title="🧩 什麼是 Pinia？"></a>🧩 什麼是 Pinia？</h2><p>Pinia 是 <strong>Vue.js</strong> 官方推薦的狀態管理工具，用來集中管理應用的共用資料<br>它的概念類似 React 的 Redux 或 Zustand<br>…<br>蝦？什麼？你說講人話？<br>好，簡單來說<br>可以把它想成整個網站的「中央資料中心」<br>不論是哪一個頁面或按鈕，只要要用到同樣的資料<br>都能從這個中心取得或更新，讓資料保持一致</p><p>舉例來說，一個簡單的 <code>user</code> store：</p><pre><code>import &#123; defineStore &#125; from &#39;pinia&#39;export const useUserStore = defineStore(&#39;user&#39;, &#123;  state: () =&gt; (&#123;    isWarningMessageDismissed: true  &#125;),  actions: &#123;    toggleConsent() &#123;      this.isWarningMessageDismissed = !this.isWarningMessageDismissed    &#125;  &#125;&#125;)</code></pre><p>在任何元件裡都可以用：</p><pre><code>import &#123; useUserStore &#125; from &#39;@/stores/user&#39;const user = useUserStore()console.log(user.isWarningMessageDismissed)</code></pre><h2 id="⚡測試時的快速修改：直接改-Pinia-state"><a href="#⚡測試時的快速修改：直接改-Pinia-state" class="headerlink" title="⚡測試時的快速修改：直接改 Pinia state"></a>⚡測試時的快速修改：直接改 Pinia state</h2><p>當你在瀏覽器中開啟 Vue 應用（假設掛在 #app 上）時，<br>Vue 會把整個應用程式的實例存在 DOM 元素中，因此你可以這樣取得：</p><pre><code>document.querySelector(&#39;#app&#39;).__vue_app__</code></pre><p>這個物件底下有一個 config.globalProperties.$pinia，<br>就是整個應用的 Pinia 實例</p><p>於是我們可以：</p><pre><code>const pinia = document.querySelector(&#39;#app&#39;).__vue_app__.config.globalProperties.$piniapinia.state.value.user.isWarningMessageDismissed = false</code></pre><p>這樣就能直接修改狀態，而不必打開 DevTools 或修改程式碼<br>在開發或 debug 階段確實非常方便 😜</p><h2 id="⚠️但這個方法比較適合簡單的測試情境"><a href="#⚠️但這個方法比較適合簡單的測試情境" class="headerlink" title="⚠️但這個方法比較適合簡單的測試情境"></a>⚠️但這個方法比較適合簡單的測試情境</h2><p>雖然這個技巧很炫炮，但它其實有幾個問題</p><ol><li><p>繞過應用邏輯<br>你直接修改 state，沒有經過 actions 或 getters，可能導致邏輯流程與實際應用不一致</p></li><li><p>缺乏狀態追蹤<br>直接改值的操作不會出現在 Pinia DevTools 的 mutation log 中，測試結果難以重現，也不容易讓其他人理解狀態是怎麼變的</p></li><li><p>在多 store 或非同步行為中容易出錯<br>當應用內有多個 store、或 state 與 API 綁定時，直接操作可能讓某些資料失去同步，導致測試結果不穩定</p></li></ol><h2 id="✅-較佳的解法"><a href="#✅-較佳的解法" class="headerlink" title="✅ 較佳的解法"></a>✅ 較佳的解法</h2><p>如果只是為了方便測試，可以採用以下幾種更好的方式</p><h3 id="1️⃣-在-store-中建立「測試模式」的-action"><a href="#1️⃣-在-store-中建立「測試模式」的-action" class="headerlink" title="1️⃣ 在 store 中建立「測試模式」的 action"></a>1️⃣ 在 store 中建立「測試模式」的 action</h3><pre><code>export const useUserStore = defineStore(&#39;user&#39;, &#123;  state: () =&gt; (&#123;    isWarningMessageDismissed: true  &#125;),  actions: &#123;    setConsentForTest(value) &#123;      if (import.meta.env.MODE === &#39;development&#39;) &#123;        this.isWarningMessageDismissed = value      &#125;    &#125;  &#125;&#125;)</code></pre><p>然後在 console 中：</p><pre><code>const user = useUserStore()user.setConsentForTest(false)</code></pre><p>好處是：</p><blockquote><p>狀態變化仍透過 action 流程，可被追蹤、受控，且不會污染正式驗證邏輯</p></blockquote><h3 id="2️⃣-使用-Vue-js-DevTools"><a href="#2️⃣-使用-Vue-js-DevTools" class="headerlink" title="2️⃣ 使用 Vue.js DevTools"></a>2️⃣ 使用 Vue.js DevTools</h3><p>在 Vue DevTools 開啟 Pinia 模組，可直接修改 state、呼叫 action<br>有視覺化界面，也能記錄 mutation log</p><h2 id="🧠-結語"><a href="#🧠-結語" class="headerlink" title="🧠 結語"></a>🧠 結語</h2><p>在開發階段用 Console 快速改 Pinia 狀態沒啥大問題<br>但在需要模擬多層邏輯、非同步請求或狀態流的測試中<br>這種方式就不夠穩定、也不容易重現結果<br>如果要走比較正規一點的方式個人會比較偏好使用 Vue.js DevTools，但就需要請 RD 把那個開關打開<br>重新佈署到 dev 或其他測試環境上</p><p>最後，因為照片不知道用什麼，所以…<br>就隨便用散步路上隨手拍的好了😜</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2025-how-to-control-pinia-in-browser-console/image.png&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天在測試 Vue 專案時，我臨時需要切換某個使用者狀態，這招從 AI 偷學來的</summary>
      
    
    
    
    
    <category term="Vue.js" scheme="https://blogs.sqz777.com/tags/Vue-js/"/>
    
    <category term="Pinia" scheme="https://blogs.sqz777.com/tags/Pinia/"/>
    
  </entry>
  
  <entry>
    <title>CodeWars 刷題系列，英文不好的我，也能理解 JavaScript 的 reduce 方法原來不是「減少」的意思！</title>
    <link href="https://blogs.sqz777.com/2025/09/01/2025-codewars-javascript-reduce-discovery/"/>
    <id>https://blogs.sqz777.com/2025/09/01/2025-codewars-javascript-reduce-discovery/</id>
    <published>2025-09-01T22:29:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p>今天寫 JavaScript 用 CodeWars 暖暖手，年底到了，懂的都懂（？）<br>先從 8kyu 開始複習一下語法，平常寫自動化真的用不到太多原生函式，大多都是在處理測試邏輯和測試資料的整理，不然就是閱讀 RD&#x2F;QA 們寫的 code</p><h2 id="今天的題目：How-good-are-you-really"><a href="#今天的題目：How-good-are-you-really" class="headerlink" title="今天的題目：How good are you really?"></a>今天的題目：How good are you really?</h2><p><img src="/../img/2025-codewars-javascript-reduce-discovery/image.png" alt="image1-confusing-to-reduce"></p><p>總之，今天遇到的題目是「How good are you really?」，大意就是<br>你會拿到一個陣列，裡面是同學們的考試分數，計算平均分數，並和你的分數比較<br>如果你大於平均 return <code>true</code>，否則 return <code>false</code>。</p><h2 id="我的第一個解法"><a href="#我的第一個解法" class="headerlink" title="我的第一個解法"></a>我的第一個解法</h2><p>寫這種題目其實我更熟悉使用 C# 的 lib，只要把 array 透過 linq 做 <code>[].Average()</code> 再用判斷式處理就結束了<br>但是 JavaScript… 我沒有這麼熟悉他的原生 lib（畢竟寫自動化會用到的就那幾個 XD）</p><p>於是簡單寫的答案是這樣：</p><pre><code class="javascript">function betterThanAverage(classPoints, yourPoints) &#123;  let scoreSum = 0;  for(i = 0; i&lt; classPoints.length; i++)&#123;    scoreSum += classPoints[i];  &#125;  return yourPoints &gt; (scoreSum/classPoints.length);&#125;</code></pre><p>送出也成功解了！</p><h2 id="別人的解法讓我大開眼界"><a href="#別人的解法讓我大開眼界" class="headerlink" title="別人的解法讓我大開眼界"></a>別人的解法讓我大開眼界</h2><p>看了別人的答案，如下：</p><pre><code class="javascript">function betterThanAverage(classPoints, yourPoints) &#123;  return yourPoints &gt; classPoints.reduce((a, b) =&gt; a + b, 0) / classPoints.length; &#125;</code></pre><p>誒？原來有 <code>reduce</code> 這種函式啊…</p><p>但我怎麼想都想不通，我英文太爛了，<code>reduce</code> 不是「減少」的意思嗎？到底怎麼回事？</p><h2 id="偉哉時代的巨人，煩請-AI-老師救援"><a href="#偉哉時代的巨人，煩請-AI-老師救援" class="headerlink" title="偉哉時代的巨人，煩請 AI 老師救援"></a>偉哉時代的巨人，煩請 AI 老師救援</h2><p>偉哉 AI！下個 prompt 請他解釋才知道，喔！原來是這樣</p><p>我的 prompt：</p><pre><code class="text">把我當五歲小孩解釋為什麼裡面的 reduce 方法要叫 reduce, reduce 英文不是「減少」的意思嗎javascript[1,2,3].reduce((a,b) =&gt; a + b, 0);</code></pre><p>AI 回應：</p><pre><code class="text">好的小朋友！我來解釋給你聽～reduce 確實有「減少」的意思，但在程式設計裡，它的意思是「把很多東西變成一個東西」！想像一下：🍎🍎🍎 (很多蘋果) → 🥧 (一個蘋果派)reduce 就是這樣！它把一個陣列（很多數字）變成一個結果（一個數字）[1, 2, 3] → 6步驟是這樣的：1. 開始：a = 0（起始值）2. 第一輪：a = 0, b = 1 → a + b = 13. 第二輪：a = 1, b = 2 → a + b = 3  4. 第三輪：a = 3, b = 3 → a + b = 65. 結果：6所以 reduce 的「減少」是指：- 減少陣列的「複雜度」- 把「多個」元素變成「一個」結果- 把「大的資料結構」縮減成「小的結果」就像把很多積木組裝成一個玩具一樣！</code></pre><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>原來 <code>reduce</code> 在程式設計中的「減少」，指的是把多個元素「縮減」成一個結果！不是數量上的減少，而是複雜度的簡化<br>這邊提到的範例都是加法，但可以用上減法、乘法或是其他更細緻的應用喔！</p><p>我甚至不太相信 AI 給我的答案，請他給我國外社群討論時是否有提到如何理解 reduce，這邊提供幾個連結：</p><ul><li><a href="https://www.reddit.com/r/learnprogramming/comments/15ywksn/comment/jxfb89s/">Reddit - 為什麼叫 reduce？1</a>  </li><li><a href="https://www.reddit.com/r/learnjavascript/comments/s1e4g1/comment/hs8j32z/">Reddit - 為什麼叫 reduce？2</a></li></ul><p>這次的學習讓我想起程式設計中很多名詞的含義，往往跟我們日常理解的意思有些微妙的差異<br>繼續暖手，Keep Learning!</p><p>我真的蠻喜歡 CodeWars 提交後可以看到很多人的 submit，一來自己透過 for 迴圈達成了複習的目的，二來又可以根據別人的答案學習到不同的撰寫方法，不懂的地方問 AI，讓我更熟悉 JavaScript 的語法，在複習上更有效率了！覺得愉悅</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天寫 JavaScript 用 CodeWars 暖暖手，年底到了，懂的都懂（？）&lt;br&gt;先從 8kyu 開始複習一下語法，平常寫自動化真的用不到太多原生函式，大多都是在處理測試邏輯和測試資料的整理，不然就是閱讀 RD&amp;#x2F;QA 們寫的 code&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://blogs.sqz777.com/tags/JavaScript/"/>
    
    <category term="CodeWars" scheme="https://blogs.sqz777.com/tags/CodeWars/"/>
    
    <category term="程式碼學習" scheme="https://blogs.sqz777.com/tags/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%AD%B8%E7%BF%92/"/>
    
  </entry>
  
  <entry>
    <title>我的 macbook 系統資料好大RRRRRRR</title>
    <link href="https://blogs.sqz777.com/2025/02/21/2025-mac-system-data-clean-up/"/>
    <id>https://blogs.sqz777.com/2025/02/21/2025-mac-system-data-clean-up/</id>
    <published>2025-02-21T16:44:21.000Z</published>
    <updated>2026-01-13T15:11:53.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h2><p>最近安裝 xcode 新的 simulator 時，我的 mac 出現了一個錯誤訊息是 <code>您的啟動硬碟將滿</code><br>於是我確認了一下整個硬碟空間的佔比，發現我的系統資料真的好大，竟然佔了一半(247.9GB)</p><p><img src="/img/2025-mac-system-data-clean-up/image1.png" alt="system-data"></p><p>：你的系統資料有多大？<br>：三、四層樓那麼大(X)</p><p><img src="/img/2025-mac-system-data-clean-up/gif1.gif" alt="alt text"></p><p>嘗試找呂布（Reboot）救援之後意外的少了 30GB</p><p><img src="/img/2025-mac-system-data-clean-up/image2.png" alt="system-data-after-reboot"></p><p>找 google 求救之後發現有很多工具和軟體可以使用，有些要付費有些則不需要，但本人我就比較奇葩，不喜歡裝一堆有的沒的，所以決定找看看有沒有不安裝軟體的解決方式</p><p>於是找到了這一篇 <a href="https://www.reddit.com/r/mac/comments/ynv4d0/system_data_taking_up_all_my_storage_how_do_i_fix/">reddit</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>簡單來說就是使用 <code>du</code> 和 <code>df</code> 指令來確認磁碟空間中使用最多的地方，然後再針對那些資料夾進行手動清理</p><p>df 指令如下，這行的目的是讓你了解目前硬碟空間的使用狀況，並且僅顯示 size 為 GB 層級的資訊</p><pre><code>df -h | grep Gi</code></pre><p>du 指令如下，這行指令會先用 du -h 計算 &#x2F;System&#x2F;Volumes&#x2F;Data 內所有檔案和資料夾的磁碟使用量（並以 KB、MB、GB 等易讀單位顯示）。接著 grep “G\t” 只篩選出顯示為 GB 的結果，再用 sort 進行排序，讓你能快速找出哪些資料夾或檔案最佔空間</p><pre><code>du -h /System/Volumes/Data | grep &quot;G\t&quot; | sort</code></pre><p>找到那些最佔空間的檔案之後就可以用 finder 手動找到他再自行判斷是否刪除<br>這一次我找到很多垃圾 image，還有一些不知道為什麼垃圾桶沒清空的內容<br>最後我總共刪了 100GB 左右的資料，真是清清爽爽</p><p><img src="/img/2025-mac-system-data-clean-up/image3.png"></p><p><img src="/img/2025-mac-system-data-clean-up/image4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;緣起&quot;&gt;&lt;a href=&quot;#緣起&quot; class=&quot;headerlink&quot; title=&quot;緣起&quot;&gt;&lt;/a&gt;緣起&lt;/h2&gt;&lt;p&gt;最近安裝 xcode 新的 simulator 時，我的 mac 出現了一個錯誤訊息是 &lt;code&gt;您的啟動硬碟將滿&lt;/code&gt;&lt;br&gt;於</summary>
      
    
    
    
    
    <category term="macOS" scheme="https://blogs.sqz777.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Playwright 攔截 request 簡易筆記和範例</title>
    <link href="https://blogs.sqz777.com/2024/09/08/2024-easy-playwright-intercept-note/"/>
    <id>https://blogs.sqz777.com/2024/09/08/2024-easy-playwright-intercept-note/</id>
    <published>2024-09-08T16:18:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p>工作上測試遇到了一個情境是測試 Web SDK，主要類似於 GA 的那種監控網頁事件來發送 request 的受測對象<br>Web SDK 會根據當下使用者的事件觸發順序而產生不同的 request 內容<br>今天準備了一個可以觸發 request 的 HTML、接收 request 的簡單 Node.js Backend API Server<br>還有筆記用的 Playwright 攔截 request 範例程式碼</p><p>所有程式碼都放在這: <a href="https://github.com/SQZ777/playwright-intercept-example">範例程式碼</a></p><p>這張圖應該能表達到今天文章範例中的攔截器概念(?)</p><p><img src="/../img/2024-easy-playwright-intercept-note/1.png" alt="interceptor_meme"></p><p>自動化的執行流程:</p><ol><li>啟動 server.js，讓 html 可以透過本地伺服器瀏覽</li><li>使用瀏覽器瀏覽 localhost:3000</li><li>點擊按鈕觸發 request 發送的動作</li><li>攔截 request 驗證 request 被發送的正確性</li></ol><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p><del>可能不算程式碼…? 沒有人:可是它裡面有 js</del></p><p>此 HTML 會在按下按鈕後擷取當下瀏覽器中的 timezone，將 timezone 夾帶進去 request 發送到 Backend Server</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Playwright Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Playwright Intercept Request Example&lt;/h1&gt;    &lt;button id=&quot;sendRequest&quot;&gt;Send Request&lt;/button&gt;    &lt;script&gt;        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;        document.getElementById(&#39;sendRequest&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;            fetch(&#39;/api/data&#39;, &#123;                method: &#39;POST&#39;,                headers: &#123;                    &#39;Content-Type&#39;: &#39;application/json&#39;                &#125;,                body: JSON.stringify(&#123; location: timezone &#125;)            &#125;)                .then(response =&gt; response.json())                .then(data =&gt; console.log(&#39;Response from server:&#39;, data))                .catch(error =&gt; console.error(&#39;Error:&#39;, error));        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接收 request 以及讓 HTML 可以被瀏覽</p><p>Node.js Server</p><pre><code>const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();const port = 3000;app.use(express.json());// 提供 public 資料夾中的靜態檔案app.use(express.static(path.join(__dirname, &#39;public&#39;)));app.post(&#39;/api/data&#39;, (req, res) =&gt; &#123;    console.log(&#39;Received data:&#39;, req.body);    res.json(&#123; message: &#39;Data received successfully&#39;, receivedData: req.body &#125;);&#125;);// 服務 index.htmlapp.get(&#39;/&#39;, (req, res) =&gt; &#123;    res.sendFile(path.join(__dirname, &#39;index.html&#39;));&#125;);app.listen(port, () =&gt; &#123;    console.log(`Server is running on http://localhost:$&#123;port&#125;`);&#125;);</code></pre><h2 id="Playwright-攔截範例"><a href="#Playwright-攔截範例" class="headerlink" title="Playwright 攔截範例"></a>Playwright 攔截範例</h2><p>先寫一個不改變瀏覽器 timezone 的案例，瀏覽器會依照使用者當前的機器設定來設定 timezone<br>我目前待在台灣，所以 timezone id 會是 <code>Asia/Taipei</code></p><pre><code class="javascript">const &#123; test, expect &#125; = require(&#39;@playwright/test&#39;);test.describe(&#39;test with local and no change&#39;, () =&gt; &#123;    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Asia/Taipei&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>再寫一個改變瀏覽器 timezone 的案例，這個案例會先將 timezone 改為 <code>Europe/Paris</code>，再執行瀏覽 HTML 的動作</p><pre><code class="javascript">test.describe(&#39;test with franch&#39;, () =&gt; &#123;    test.use(&#123; timezoneId: &#39;Europe/Paris&#39; &#125;);    test(&#39;test intercept request for no change&#39;, async (&#123; page &#125;) =&gt; &#123;        await page.route(&#39;**/api/data&#39;, (route, request) =&gt; &#123;            console.log(&#39;Intercepted request:&#39;, request.postData());            const postData = JSON.parse(request.postData());            expect(postData.location).toBe(&#39;Europe/Paris&#39;);            route.continue();        &#125;);            await page.goto(&#39;http://localhost:3000&#39;);        await page.click(&#39;#sendRequest&#39;);            // 讓時間留給網頁處理請求        await page.waitForTimeout(1000);    &#125;);&#125;);</code></pre><p>兩個案例執行完之後在 console 中可以見到以下結果</p><p><img src="/../img/2024-easy-playwright-intercept-note/2.png" alt="playwright_result"></p><h2 id="額外筆記"><a href="#額外筆記" class="headerlink" title="額外筆記"></a>額外筆記</h2><p>因為這一種會持續監聽瀏覽器事件的 Web SDK，是不會有 request 停止的一刻，所以選擇使用的是 <code>page.waitForTimeout(1000)</code><br>而非 <code>page.waitForLoadState(&#39;networkidle&#39;)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作上測試遇到了一個情境是測試 Web SDK，主要類似於 GA 的那種監控網頁事件來發送 request 的受測對象&lt;br&gt;Web SDK 會根據當下使用者的事件觸發順序而產生不同的 request 內容&lt;br&gt;今天準備了一個可以觸發 request 的 HTML、接收 </summary>
      
    
    
    
    
    <category term="Playwright" scheme="https://blogs.sqz777.com/tags/Playwright/"/>
    
    <category term="攔截Request" scheme="https://blogs.sqz777.com/tags/%E6%94%94%E6%88%AARequest/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile x Postgres：Materialized View 的 REFRESH 奇幻（？）之旅！</title>
    <link href="https://blogs.sqz777.com/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/"/>
    <id>https://blogs.sqz777.com/2024/06/18/2024-init-postgres-when-materialized-view-depends-on-remote-table/</id>
    <published>2024-06-18T16:18:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2024-init-postgres-when-materialized-view-depends-on-remote-table/image1.png" alt="我是小丑"></p><p>遇到這個 Issue 是因為測試上的需求，情境是要做 API Automation<br>而 SUT(System Under Test) 的 API 相依於 Postgres 中的某一個 Materialized View<br>又剛好，這個 Materialized View 會用到 remote table 的資料<br>再剛好，這個 remote table 也是你要做 init DB 的對象（在同一個 image）<br>執行 REFRESH MATERIALIZED VIEW 的時候發生的問題<br>所以就發生了這個問題，錯誤訊息如下</p><pre><code class="shell">2024-06-18 00:51:17.451 UTC [68] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-18 00:51:17.451 UTC [68] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?2024-06-18 00:51:17.451 UTC [68] STATEMENT:  REFRESH MATERIALIZED VIEW test2_db_schema.test2_mvERROR:  could not connect to server &quot;test1_db&quot;DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused    Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="這次-issue-的相關檔案"><a href="#這次-issue-的相關檔案" class="headerlink" title="這次 issue 的相關檔案"></a>這次 issue 的相關檔案</h2><p>想要在 local 重現的話，執行一次這裡提到的檔案就可以看到了~</p><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile:"></a>dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sqlCOPY init.sh /docker-entrypoint-initdb.d/init.sh</code></pre><h3 id="init-sh"><a href="#init-sh" class="headerlink" title="init.sh:"></a>init.sh:</h3><pre><code class="shell">psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;</code></pre><h3 id="test1-sql"><a href="#test1-sql" class="headerlink" title="test1.sql:"></a>test1.sql:</h3><pre><code class="sql">CREATE SCHEMA test1_db_schema AUTHORIZATION postgres;-- test1_db_schema.test1_table definition-- Drop table-- DROP TABLE test1_db_schema.test1_table;CREATE TABLE test1_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)</code></pre><h3 id="test2-sql"><a href="#test2-sql" class="headerlink" title="test2.sql:"></a>test2.sql:</h3><pre><code class="sql">CREATE SCHEMA test2_db_schema AUTHORIZATION postgres;CREATE EXTENSION postgres_fdw;CREATE SERVER test1_db        FOREIGN DATA WRAPPER postgres_fdw        OPTIONS (host &#39;localhost&#39;, port &#39;5432&#39;, dbname &#39;test1&#39;);CREATE USER MAPPING FOR postgresSERVER test1_dbOPTIONS (user &#39;postgres&#39;, password &#39;12345&#39;);-- test2_db_schema.test1_table definition-- Drop table-- DROP FOREIGN TABLE test2_db_schema.test1_table;CREATE FOREIGN TABLE test2_db_schema.test1_table (    id varchar(10) NOT NULL,    another_column varchar(50) NOT NULL)SERVER test1_dbOPTIONS (schema_name &#39;test1_db_schema&#39;, table_name &#39;test1_table&#39;);-- PermissionsALTER TABLE test2_db_schema.test1_table OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test1_table TO postgres;CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;-- View indexes:CREATE UNIQUE INDEX uix_test2_mv ON test2_db_schema.test2_mv USING btree (cupid_id, outer_id);-- PermissionsALTER TABLE test2_db_schema.test2_mv OWNER TO postgres;GRANT ALL ON TABLE test2_db_schema.test2_mv TO postgres;</code></pre><p>這裡特別提一下建立 Materialized View 時的細節，以下 script 擷取於上面提到的內容</p><pre><code>CREATE MATERIALIZED VIEW test2_db_schema.test2_mvTABLESPACE pg_defaultAS SELECT t.id,    t.another_column   FROM test2_db_schema.test1_table tWITH NO DATA;</code></pre><p>如果這裡寫的是 WITH DATA，報錯會報在這裡，而不是 REFRESH 的時候，錯誤訊息會像這樣</p><pre><code class="shell">2024-06-23 09:28:15.912 UTC [59] ERROR:  could not connect to server &quot;test1_db&quot;2024-06-23 09:28:15.912 UTC [59] DETAIL:  connection to server at &quot;localhost&quot; (::1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?    connection to server at &quot;localhost&quot; (127.0.0.1), port 5432 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?</code></pre><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>根據 <a href="https://github.com/docker-library/postgres/blob/master/Dockerfile-alpine.template#L216">postgres 在 github 上的 dockerfile</a>，可以注意到</p><ol><li>原始 postgres 的 docker-entrypoint.sh 放置於 <code>/usr/local/bin</code></li><li>你的 dockerfile 中，位於 <code>/docker-entrypoint-initdb.d/</code> 的 shell script，會早於 postgres 啟動的時間點</li></ol><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><ol><li>init.sh 中啟動 postgres，並確認 postgres 啟動後再執行我們的原本要執行的 script，並讓 image 保持啟動狀態</li><li>dockerfile 改為 <code>RUN init.sh</code>，而非原本將 init.sh 放進 <code>/docker-entrypoint-initdb.d/</code> 的方式</li></ol><h3 id="改變後的-init-sh："><a href="#改變後的-init-sh：" class="headerlink" title="改變後的 init.sh："></a>改變後的 init.sh：</h3><pre><code class="shell">#!/bin/bashecho &quot;Starting PostgreSQL...&quot;/usr/local/bin/docker-entrypoint.sh postgres &amp; # 將 postgres 啟動until pg_isready -h localhost -p 5432; do # 檢查 postgres 啟動狀態  echo &quot;Waiting for PostgreSQL to start...&quot;  sleep 1done# psql -U postgres -c &quot;CREATE DATABASE test1;&quot;psql -U postgres -c &quot;CREATE DATABASE test2;&quot;psql -U postgres -d test1 -a -f /test1.sqlpsql -U postgres -d test2 -a -f /test2.sqlpsql -U postgres -d test2 -c &quot;REFRESH MATERIALIZED VIEW test2_db_schema.test2_mv&quot;tail -f /dev/null # 讓 container 保持運作狀態</code></pre><h3 id="改變後的-dockerfile"><a href="#改變後的-dockerfile" class="headerlink" title="改變後的 dockerfile:"></a>改變後的 dockerfile:</h3><pre><code class="dockerfile">FROM postgres:14-alpineENV POSTGRES_USER=postgresENV POSTGRES_PASSWORD=12345ENV POSTGRES_DB=test1COPY test1.sql /test1.sqlCOPY test2.sql /test2.sql# COPY init.sh /docker-entrypoint-initdb.d/init.shCOPY init.sh /init.shRUN chmod +x /init.shCMD [&quot;/init.sh&quot;]</code></pre><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我真的沒想到會遇到這種問題，一開始單純只是想要快樂 init DB schema 而已，所以就單純放在 <code>/docker-entrypoint-initdb.d/</code> 裡面<br>這個過程讓我學到 Dockerhub 上的 image 中，他的 Dockerfile 是如何被執行的<br>以及我們自己放在 <code>/docker-entrypoint-initdb.d/</code> 裡面的 shell script 的執行順序</p><p>不過我不知道我這個解法到底是對的還是錯的 XD</p><p>所以，最後想問一下<br>透過 Dockerfile 建置 postgres DB schema 的 best practice 是什麼？<br><del>不要跟我說透過 dockerfile 建置 postgres DB 本身就是錯的 XDD</del></p><p>如果有更好的解法或是有寫錯的地方，歡迎告訴我<br>感謝大家</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2024-init-postgres-when-materialized-view-depends-on-remote-table/image1.png&quot; alt=&quot;我是小丑&quot;&gt;&lt;/p&gt;
&lt;p&gt;遇到這個 Issue 是因為測試上的需求，情</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://blogs.sqz777.com/tags/Docker/"/>
    
    <category term="Postgres" scheme="https://blogs.sqz777.com/tags/Postgres/"/>
    
  </entry>
  
  <entry>
    <title>【翻譯】5 件與測試有關的難搞事</title>
    <link href="https://blogs.sqz777.com/2024/06/10/2024-five-tricky-things-with-testing/"/>
    <id>https://blogs.sqz777.com/2024/06/10/2024-five-tricky-things-with-testing/</id>
    <published>2024-06-10T22:18:05.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../img/2024-five-tricky-things-with-testing/image.jpg"></p><p>這是一篇翻譯文，文末才會有一些個人的心得與見解<br>原文連結:<br><a href="https://thetesteye.com/blog/2016/09/five-tricky-things-with-testing/">Five Tricky Things With Testing - Rikard Edgren</a></p><h2 id="內文翻譯"><a href="#內文翻譯" class="headerlink" title="內文翻譯"></a>內文翻譯</h2><p>今天我去了哥德堡的 SAST Väst，進行了一個可以翻譯為 <em>5 件與測試有關的難搞事</em> 的<a href="https://thetesteye.com/presentations/Edgren_SASTVAST2016_FemBesvarligaSakerMedTestning.pdf">演講</a>。<br>這是一個非常愉快的日子，我見到了舊友和新朋友。這也是我好久以來第一次寫 Blogs 的機會，下面是非常簡潔的版本：</p><ol><li><p><strong>人們不懂測試</strong>，但都有自己的見解。<br>他們認為測試是一種成本，沒有考慮到它的價值。<br>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</p></li><li><p><strong>心理上的困難</strong><br>你找到的問題越多，完成的時間就會越長。<br>解決方法：強調長期利益，對自己和他人都一樣。</p></li><li><p><strong>你永遠不會完成</strong><br>總有更多的東西需要測試，但你必須停止。<br>解決方法：多與同事交流，進行更豐富的測試。</p></li><li><p><strong>隱性知識。</strong><br>極少數情況下，你能寫下如何測試，然後進行良好的測試。<br>解決方法：更多的深層的討論</p></li><li><p><strong>有需求，但薪水低。</strong><br>解決方法：用正確的詞語談論測試的價值，並用小的努力而不僅僅是找到漏洞來提供價值。</p></li></ol><p>總結：確保你的測試能提供價值，這也有助於測試社群。</p><p>演講中有一些好問題，其中一個特別困難：<br><strong>如何確保訊息傳達到應該接收的人？</strong></p><p>回答：對於離你近的人，這並不困難；從一開始就討論要報告哪些訊息以及如何報告。<br>我不喜歡模板，所以我通常為每個項目製作一個新模板，並詢問是否包含了正確的訊息。</p><p>但我猜你的意思是對於那些離你較遠的人，尤其是階層較高的人，這可能非常困難。這可能是一些你「不能」直接交談的人，你也不被邀請參加他們的會議。<br>我嘗試過的一個技巧是以一種容易傳播的格式報告，這樣很容易複製和貼上精華部分，使你的話語能夠傳達到你無法直接交談的參與者。</p><p>更好的答案需要你在自己的情境中找到。</p><p>作者: Rikard Edgren<br>日期: September 27, 2016</p><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>到了 2024 年，測試的工作仍然會遇到上面這些難搞事<br>測試相關的工作者永遠必須抱持的態度就是「持續溝通」<br>並且不斷地談論「測試價值」這件事</p><h3 id="關於第一點的個人看法"><a href="#關於第一點的個人看法" class="headerlink" title="關於第一點的個人看法"></a>關於第一點的個人看法</h3><blockquote><p><em>解決方法：討論資訊需求以及測試可以幫助人們了解的重要事項。</em></p></blockquote><p>這部分我個人認位作者想要表達的是測試人員應該不斷的與相關利益者或者團隊成員討論他們對於「測試結果」的需求，以及「測試」可以幫助他們瞭解的重要事項</p><p>這樣的討論就可以幫助到大家更好地理解測試的價值，而不單單只是將「測試」視為一種成本</p><h3 id="關於第四點的個人看法"><a href="#關於第四點的個人看法" class="headerlink" title="關於第四點的個人看法"></a>關於第四點的個人看法</h3><blockquote><p><em>「極少數情況下，你能寫下如何測試，然後進行良好的測試。」</em></p></blockquote><p>我認為非常的貼切，因為大部分的 bug，發生在你意料之外的地方，而不是你預想的地方<br>這一句話所代表的是，開發者在大多數的情況下，會依照功能的描述進行開發<br>測試者則必須同時保證功能描述與開發者的實作成果一致之外，還得探索功能以外的可能性<br>以確保功能在完成時給予客戶的是驚訝，而不是驚嚇</p><p>Photo by <a href="https://unsplash.com/@icons8?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Icons8 Team</a> on <a href="https://unsplash.com/photos/man-teaching-woman-while-pointing-on-gray-laptop-yTwXpLO5HAA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../img/2024-five-tricky-things-with-testing/image.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;這是一篇翻譯文，文末才會有一些個人的心得與見解&lt;br&gt;原文連結:&lt;br&gt;&lt;a href=&quot;https://thetesteye</summary>
      
    
    
    
    
    <category term="翻譯系列" scheme="https://blogs.sqz777.com/tags/%E7%BF%BB%E8%AD%AF%E7%B3%BB%E5%88%97/"/>
    
    <category term="測試相關" scheme="https://blogs.sqz777.com/tags/%E6%B8%AC%E8%A9%A6%E7%9B%B8%E9%97%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用 ChatGPT 進行部落格文章搬遷的我會被 AI 取代嗎?</title>
    <link href="https://blogs.sqz777.com/2024/06/08/2024-migrate-blog-by-chatgpt/"/>
    <id>https://blogs.sqz777.com/2024/06/08/2024-migrate-blog-by-chatgpt/</id>
    <published>2024-06-08T22:46:45.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-migrate-blog-by-chatgpt/image0.png"><br>圖是使用<a href="https://memes.tw/">梗圖產生器</a>產生的，AI 真的可以取代我們嗎? 讓我們繼續看下去</p><p>最近自己使用了 ChatGPT 進行部落格文章的搬遷<br>搬站的原因很膚淺，想知道的話再去<a href="https://sqz777.com/about/">關於我</a>看，就不多做贅述 🤣<br>原本這篇只是單純想記錄搬遷的過程，但剛好最近社團討論很熱烈就把文章的撰寫方式稍微改變一下<br>讓這篇可以更符合社團最近討論度很高的主題： </p><blockquote><p>因為 AI 的出現，工程師會不會失業?</p></blockquote><p><strong>本文使用的 ChatGPT 模型是 GPT-4o</strong></p><h2 id="正文開始，我的第一步是拆分需求"><a href="#正文開始，我的第一步是拆分需求" class="headerlink" title="正文開始，我的第一步是拆分需求"></a>正文開始，我的第一步是拆分需求</h2><p>需求很簡單</p><ul><li>提供 URL 將部落格的文章內容轉成 markdown</li><li>取得舊部落格的所有文章 URL</li><li>讓第一個需求可以批次處理</li></ul><p>這種一次性的 script，就不考慮維護性了<br>所以基本上所有 code 都讓 ChatGPT 產生再做細節的調整就好</p><h2 id="第二步，描述需求讓-ChatGPT-產生程式碼"><a href="#第二步，描述需求讓-ChatGPT-產生程式碼" class="headerlink" title="第二步，描述需求讓 ChatGPT 產生程式碼"></a>第二步，描述需求讓 ChatGPT 產生程式碼</h2><p>直接讓 ChatGPT 幫我產生一段關於文章內容轉成 markdown 的 Node.js Code</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image1.png"></p><p>以下是 ChatGPT 產生的 Node.js Code</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);const fs = require(&#39;fs&#39;);const URL = &#39;https://dotblogs.azurewebsites.net/Im_sqz777/2022/10/06/223559&#39;;axios.get(URL)  .then(response =&gt; &#123;    const html = response.data;    const $ = cheerio.load(html);    // 假設文章內容在 class 為 &#39;post-content&#39; 的元素中    const postContent = $(&#39;.post-content&#39;).html();    if (!postContent) &#123;      throw new Error(&#39;未能找到文章內容，請檢查選擇器是否正確&#39;);    &#125;    // 將 HTML 轉換為 Markdown 格式    const markdownContent = convertToMarkdown(postContent);    // 將 Markdown 內容寫入文件    fs.writeFileSync(&#39;article.md&#39;, markdownContent);    console.log(&#39;文章已成功轉換為 Markdown 格式並儲存至 article.md&#39;);  &#125;)  .catch(error =&gt; &#123;    console.error(&#39;發生錯誤:&#39;, error);  &#125;);function convertToMarkdown(html) &#123;  // 這裡使用 turndown 庫來轉換 HTML 為 Markdown  const TurndownService = require(&#39;turndown&#39;);  const turndownService = new TurndownService();  return turndownService.turndown(html);&#125;</code></pre><h2 id="第三步，修正-ChatGPT-的程式碼"><a href="#第三步，修正-ChatGPT-的程式碼" class="headerlink" title="第三步，修正 ChatGPT 的程式碼"></a>第三步，修正 ChatGPT 的程式碼</h2><p>我發現了 ChatGPT 提供的 code 中有一個「假設」</p><pre><code>// 假設文章內容在 class 為 &#39;post-content&#39; 的元素中const postContent = $(&#39;.post-content&#39;).html();</code></pre><p>這一個假設讓我需要回到文章的頁面中找到文章內容的 class 為 <code>article__content</code>，如圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image2.png"></p><p>將 <code>.post-content</code> 取代為 <code>.article__content</code> 了之後執行程式碼</p><blockquote><p>記得在<code>article__content</code>前面加上點: <code>.</code></p></blockquote><p>驗證產生出來的 markdown 有幾個小問題</p><ol><li>舊文章日期&#x2F;標籤&#x2F;標題，沒有被寫進我預期的格式中</li><li>檔案名稱是寫死的，舊文章產生的檔案名稱應該依照文章年份及對應名稱</li></ol><h2 id="第四步，修正小問題，讓-ChatGPT-重新產生程式碼"><a href="#第四步，修正小問題，讓-ChatGPT-重新產生程式碼" class="headerlink" title="第四步，修正小問題，讓 ChatGPT 重新產生程式碼"></a>第四步，修正小問題，讓 ChatGPT 重新產生程式碼</h2><p>依照小問題 1，我需要道舊文章中找到文章對應的標題&#x2F;標籤&#x2F;日期的 html，然後產生 prompt 讓 GPT 幫我改 code<br>prompt 如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image3.png"></p><p>避免文章太長，就不貼 GPT 產生的 code 了<br>接著再解小問題 2<br>這個問題很簡單，直接讓 GPT 修正並且改掉先前提到的文章內容 class 的問題</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image4.png"></p><p>小問題解完之後，執行了 script，確認 markdown 可以被 hexo 解析就可以進到下一步了</p><h2 id="第四步，讓-URL-可以批次輸入"><a href="#第四步，讓-URL-可以批次輸入" class="headerlink" title="第四步，讓 URL 可以批次輸入"></a>第四步，讓 URL 可以批次輸入</h2><p>為了讓舊站的連結可以透過 git 記錄，所以決定透過檔案的方式來進行批次處理<br>這樣一來我有紀錄的同時又可以透過檔案來進行文章的轉換，prompt 如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image5.png"></p><p>在檔案中隨便貼上兩個舊站的文章測試一下，確認沒問題之後就往下一步</p><h2 id="第五步，取得舊站所有文章的-URL"><a href="#第五步，取得舊站所有文章的-URL" class="headerlink" title="第五步，取得舊站所有文章的 URL"></a>第五步，取得舊站所有文章的 URL</h2><p>在舊站首頁中可以觀測到 title 的 class 為 <code>article__title</code><br>然後可以在 URL 觀測到頁面會因為尾數不同而換頁，URL 如下</p><blockquote><p><a href="https://dotblogs.com.tw/Im_sqz777/1">https://dotblogs.com.tw/Im_sqz777/1</a> &lt;&lt; 這個 1 就是頁數</p></blockquote><p>我們就可依照這個狀況產生對應的 prompt:</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image6.png"></p><p>產生的程式碼如下</p><pre><code>const axios = require(&#39;axios&#39;);const cheerio = require(&#39;cheerio&#39;);async function fetchArticleTitles(variable) &#123;    const url = `https://dotblogs.com.tw/Im_sqz777/$&#123;variable&#125;`;    try &#123;        const &#123; data &#125; = await axios.get(url);        const $ = cheerio.load(data);        // 選擇所有 class 為 article__title 的元素        $(&#39;.article__title a&#39;).each((index, element) =&gt; &#123;            const titleUrl = $(element).attr(&#39;href&#39;);            console.log(titleUrl);        &#125;);    &#125; catch (error) &#123;        console.error(`Error fetching data from $&#123;url&#125;:`, error);    &#125;&#125;// 迭代變數 1 到 8for (let i = 1; i &lt;= 8; i++) &#123;    fetchArticleTitles(i);&#125;</code></pre><p>接著執行產生的程式碼會發現他並沒有符合我們的需求，如下圖</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image7.png"></p><p>我們的需求是需要讓 text file 中描述 URL，所以只需要在第 14 行加入 <code>&#39;https://dotblogs.com.tw&#39; + </code> 就可以了<br>執行結果如下</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image8.png"></p><h2 id="第六步，修復-hexo-解析的問題"><a href="#第六步，修復-hexo-解析的問題" class="headerlink" title="第六步，修復 hexo 解析的問題"></a>第六步，修復 hexo 解析的問題</h2><p>接著就會發現 hexo 解析的 2 個錯誤</p><ol><li>title 格式的問題<br><img src="/img/2024-migrate-blog-by-chatgpt/image9.png"></li><li>舊文中出現大括弧 <code>&#123;&#125;</code> 時的解析問題</li></ol><p>title 的格式問題很簡單，在原程式碼中的 title 中加入單引號即可，如下</p><pre><code>---title: &#39;$&#123;title&#125;&#39;date: $&#123;date&#125;tags: $&#123;tags.map(tag =&gt; `  - $&#123;tag&#125;`).join(&#39;\n&#39;)&#125;---</code></pre><p>第 2 個問題直接讓 ChatGPT 解決</p><p><img src="/img/2024-migrate-blog-by-chatgpt/image10.png"><br>但是 ChatGPT 提供的程式碼有問題，關鍵程式碼如下</p><pre><code>  // 替換文章內容中的 &#123; 和 &#125; 字符  markdownContent = markdownContent.replace(/(&#123;|&#125;)/g, &#39;\\$1&#39;);</code></pre><p>我預期和描述的 prompt 斜線是 <code>/</code>，但 ChatGPT 睜眼說瞎話的寫成了 <code>\</code>，改掉之後確認解析沒問題後</p><p>還剩下一個細節的需求，是一開始需求分析時沒有寫到的:</p><ul><li>圖片應該要下載下來，並且在 markdown 中顯示</li></ul><p>但這一段 ChatGPT 完美的解決了我的問題，所以就不記錄了，想要看最後的程式碼的話可以到 Github 上看<br>連結附上</p><ul><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/dotblogTurnMarkdown.js">DotBlogs 文章轉 markdown</a></li><li><a href="https://github.com/SQZ777/sqz777-blog/blob/main/apps/getDotblogPostsURLs.js">取得 DotBlogs 的文章 URLs</a></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>總結一下透過 ChatGPT 搬遷 blogs 文章會需要的技能</p><ol><li>知道網站相關的知識<ul><li>知道在程式碼中描述 class 前面要加上 <code>.</code></li><li>知道 URL 中哪個值是對應頁數</li></ul></li><li>知道如何使用 Chrome 的開發者工具</li><li>知道 regex 的組成</li><li>知道錯誤訊息怎麼看<ul><li>如何快速定位哪一篇是發生錯誤的文章</li></ul></li><li>知道 hexo 解析錯誤的原因<ul><li>在 {} 前要加上 <code>/</code> 而非 <code>\</code></li><li>在標題中出現 <code>&#39;</code> 要在 script 中針對標題兩側加上 <code>&#39;</code></li></ul></li><li>…之後想到再補充</li></ol><p>以上程式碼的內容，要我自己寫是完全沒問題，有 AI 之後<br>原本可能要花 1 小時左右的時間，最後壓縮成 20 分鐘內甚至更短就解決了<br>依照今天這樣子的搬遷紀錄來看，我應該還不至於被「純粹的 AI 工具」或是「無基礎但使用 AI 工具的人」取代</p><p>不過要注意的是那些努力且能夠善用 AI 工具的人，這些人的生產力可能會是 AI 出現前的好幾倍</p><p>不說了，我要睡了，明早再修這個 blog theme 程式碼會置中的問題了 🙈🙈🙈<br>感謝大家收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-migrate-blog-by-chatgpt/image0.png&quot;&gt;&lt;br&gt;圖是使用&lt;a href=&quot;https://memes.tw/&quot;&gt;梗圖產生器&lt;/a&gt;產生的，AI 真的可以取代我們嗎? 讓我們繼續看下去&lt;/p&gt;
&lt;p&gt;最近</summary>
      
    
    
    
    
    <category term="AI" scheme="https://blogs.sqz777.com/tags/AI/"/>
    
    <category term="ChatGPT" scheme="https://blogs.sqz777.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>更改 Chrome 時區的方法</title>
    <link href="https://blogs.sqz777.com/2024/06/06/2024-how-to-change-time-zone-in-chrome/"/>
    <id>https://blogs.sqz777.com/2024/06/06/2024-how-to-change-time-zone-in-chrome/</id>
    <published>2024-06-06T22:29:10.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2024-how-to-change-time-zone-in-chrome/image.png" alt="checkTimeZone"></p><p>最近測試時遇到驗證不同時區狀況的需求</p><p>直覺上認為開啟 VPN 或是更改電腦的設定是不合理的<br>所以嘗試找看看 Chrome 有沒有辦法更改 Chrome 自身的時區設定<br>然後就讓我找到了 <a href="https://developer.chrome.com/docs/devtools/settings/locations?hl=zh-tw">Chrome 的文件</a> !</p><h2 id="設定前確認時區"><a href="#設定前確認時區" class="headerlink" title="設定前確認時區"></a>設定前確認時區</h2><p>更改之前，透過 F12 的 Console 來確認當前的時區</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image1.png" alt="checkTimeZone"></p><h2 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h2><p>於右上角三個點 &gt; More tools &gt; Sensors</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image2.png" alt="settingLocation"></p><p>接著在下方的 Sensors tab 就可以找到複寫 Location 的設定，我們這裡選擇 Tokyo</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image3.png" alt="settingLocation"></p><h2 id="確認結果"><a href="#確認結果" class="headerlink" title="確認結果"></a>確認結果</h2><p>在 Console 中確認時區是否已被覆寫</p><p><img src="/img/2024-how-to-change-time-zone-in-chrome/image4.png" alt="settingLocation"></p><p>這樣就可以完成時區的修改啦!<br>當前端會根據 Chrome 本身設定的時區進行時區顯示上的修改時，就會需要用到這一個 Chrome 的覆寫時區功能了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/2024-how-to-change-time-zone-in-chrome/image.png&quot; alt=&quot;checkTimeZone&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近測試時遇到驗證不同時區狀況的需求&lt;/p&gt;
&lt;p&gt;直覺上認為開啟 VPN 或是更改電腦</summary>
      
    
    
    
    
    <category term="Chrome" scheme="https://blogs.sqz777.com/tags/Chrome/"/>
    
    <category term="時區" scheme="https://blogs.sqz777.com/tags/%E6%99%82%E5%8D%80/"/>
    
  </entry>
  
  <entry>
    <title>API 自動化的技術選擇與 Modules 的分層思考</title>
    <link href="https://blogs.sqz777.com/2022/10/06/2022-223559/"/>
    <id>https://blogs.sqz777.com/2022/10/06/2022-223559/</id>
    <published>2022-10-06T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p>今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參考。</p><p><a href="https://github.com/SQZ777/jest-for-api-automation-template.git">https://github.com/SQZ777/jest-for-api-automation-template.git</a></p><p>各個 subtitle 如下</p><ul><li>為何不使用 Postman 來做 API Automation</li><li>語言選擇</li><li>測試框架選擇</li><li>Modules 的分層</li><li>各個 Modules 的介紹與實作</li><li>結語和本篇沒提到的事</li></ul><p>首先在使用程式碼撰寫 API 自動化的測試案例時，一定會先遇到這個問題</p><h2 id="為何不使用-Postman-來做-API-Automation？"><a href="#為何不使用-Postman-來做-API-Automation？" class="headerlink" title="為何不使用 Postman 來做 API Automation？"></a>為何不使用 Postman 來做 API Automation？</h2><p><img src="/img/2022-223559/1665066616.png.png"></p><p>所以就先來列一下 Postman 的優&#x2F;缺點吧</p><p>優點如下</p><ul><li>UI 介面容易使用，門檻極低</li><li>可以透過 JavaScript 來實作檢查 response 的 script</li><li>各個平台（Mac, Windows）都可以使用</li><li>可以透過 newman（CLI）來建置 CI 的流程</li></ul><p>接著列一下使用 Postman 執行管理自動化案例會遇到的問題</p><ul><li>大量自動化案例會產生極大的維護成本<ul><li>無法重用的 test script</li><li>受測 API 如果新增 required fields，會需要手動更新大量既有的 script</li></ul></li><li>執行 collection runner 再透過 csv 檔案來匯入測試資料的過程過於繁瑣</li></ul><p>Postman 在實作小型的 API 驗證時，是一個非常好用的工具，但需要實作大量 API 測試案例時，在 Postman 上管理這些案例會產生很大的維護成本，不信的話你可以試試，所以我們需要透過撰寫程式的方式來管理這些即將被實作的 API 測試案例。</p><h2 id="語言選擇"><a href="#語言選擇" class="headerlink" title="語言選擇"></a>語言選擇</h2><p>首先要選擇的是語言，依照公司內部現有的技術而選，策略是以不增加公司同事之間跨越職能障礙為主要目標，其次是這個語言的資源，再其次是學習的門檻，因為有尚未開發過自動化的 QA ，所以選擇語言起手的難易度也需要列為考量。</p><p><img src="/img/2022-223559/1665066630.png.png"></p><p>抱歉了 Java XD</p><p>公司內部的 backend 是 Java，而 front-end 則是 Vue.js，所以就剩下 JavaScript 及 Java 的選項能夠選擇，考量到學習的難易度與學習資源取得的容易度，就選了 JavaScript 了，其中考量到 JavaScript 的原因還有就是公司是有需要驗證 Web 上面顯示資料正確性的需求，所以如果學會了 JavaScript ，就可以 JavaScript 實作一些工具直接在 console 上執行來協助測試。</p><h2 id="測試框架選擇"><a href="#測試框架選擇" class="headerlink" title="測試框架選擇"></a>測試框架選擇</h2><p>接下來就可以找 JavaScript 在 2021 的統計，可以參考<a href="https://2021.stateofjs.com/en-US/">這個網站</a>，可以從圖表看到使用率最高的是 Jest。</p><p><img src="/img/2022-223559/1665066647.png.png"></p><p>使用率最高不代表他就是一個值得讓人使用的框架，所以再次參考了「時間推移體驗」這個數據，也可以觀察到 Jest 是一個會讓人願意再次使用的框架。</p><p><img src="/img/2022-223559/1665066655.png.png"></p><p>所以依照上面的數據，問了幾個身邊的朋友，得到的回饋也是好的，所以就選擇了 Jest 作為這次實作自動化的框架。</p><h2 id="Modules-的分層"><a href="#Modules-的分層" class="headerlink" title="Modules 的分層"></a>Modules 的分層</h2><p>為了解決 Postman 所遇到的痛點，所以我們需要</p><ul><li>tests 層<ul><li>使用其他 modules 來組成 test case 的地方</li></ul></li><li>request API 的部分要抽成 apis 的 module</li><li>request payloads 的部分要抽成 requestPayloads 的 module</li><li>有一些需要共用的 lib 抽成 common 的 module</li></ul><p>相依的關係可以畫成這個樣子</p><p><img src="/img/2022-223559/1665066676.png.png"></p><p>資料夾結構如下</p><pre><code>├─apis│      apis1.js│      apis2.js│      api/&#123;.../&#125;.js│      index.js│      requestHelper.js├─common│      jestExtend.js│          ├─requestPayloads│      apis1Request.js│      apis2Request.js│      apis/&#123;.../&#125;Request.js│      index.js│      └─tests    │   singleApi1.test.js    │   singleApi2.test.js    │   singleApi/&#123;.../&#125;.test.js    │          └─stories           stories.test.js</code></pre><h2 id="各個-Modules-的介紹與實作"><a href="#各個-Modules-的介紹與實作" class="headerlink" title="各個 Modules 的介紹與實作"></a>各個 Modules 的介紹與實作</h2><h3 id="requestPayloads-資料夾"><a href="#requestPayloads-資料夾" class="headerlink" title="requestPayloads 資料夾"></a>requestPayloads 資料夾</h3><p>requestPayloads 資料夾中的 indejx.js 是用來統整各個 API 的預設 request payloads</p><pre><code>const apis1= require(&#39;./apis1Request&#39;);const apis2= require(&#39;./apis2Request&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>預設 request payloads 的定義為：Server 不會回應「lack of fields response」的 payload</p><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis1Request.js 內容就會如下：</p><pre><code>const products = /&#123;  product_id: 1,  product_info: /&#123;    product_name: &#39;Car Engine&#39;,  /&#125;,/&#125;;module.exports = /&#123;  products,/&#125;;</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 4 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="apis-資料夾"><a href="#apis-資料夾" class="headerlink" title="apis 資料夾"></a>apis 資料夾</h3><p>apis 資料夾中的 index.js 是用來統整 apis1, apis2…等 api 的地方</p><pre><code>const apis1 = require(&#39;./apis1&#39;);const apis2 = require(&#39;./apis2&#39;);module.exports = /&#123;  apis1,  apis2,/&#125;;</code></pre><p>apis 資料夾中的 requestHelper.js 是用來管理 request API 的 HTTP method 的一層，如 get, post 等 在這一層會與 report 那一層作結合，多讓 jest 的 report 多帶一些在打 api request 的相關結果 程式碼單純以 post 為例子</p><pre><code>const axios = require(&#39;axios&#39;);/** * @param /&#123;string/&#125; baseURL for base URL * @param /&#123;object/&#125; headers for request headers * @param /&#123;object/&#125; data for request payload */async function postRequest(baseURL, headers, data) /&#123;  const result = await axios(/&#123;    method: &#39;post&#39;,    url: baseURL,    headers: headers,    data: data,  /&#125;)      .then((result) =&gt; /&#123;        return result;      /&#125;)      .catch((err) =&gt; /&#123;        console.log(err);      /&#125;);  return result;/&#125;module.exports = /&#123;  postRequest,/&#125;;</code></pre><p>以路徑 &#x2F;apis1&#x2F;products 為例子，會取 apis1 這個詞當作 file name，然後 products 當作 function name，apis.js 中則會引用到 requestHelper.js 來 request API，apis.js code 如下</p><pre><code>const /&#123;postRequest/&#125; = require(&#39;./requestHelper&#39;);require(&#39;dotenv&#39;).config();/** * @param /&#123;object/&#125; request payload * @return /&#123;object/&#125; response */**async function products(data) /&#123;  const result = await postRequest(      `$/&#123;configs.BASE_URL/&#125;/apis1/products`,      /&#123;        &#39;x-api-key&#39;: process.env.API_KEY,        &#39;content-type&#39;: &#39;application/json&#39;,      /&#125;,      data,  );  return result;/&#125;**</code></pre><p>假設 api 路徑為 &#x2F;apis1&#x2F;products，預期在 tests 中使用時則是這個樣子（第 5 行）</p><pre><code>const apis = require(&#39;../apis&#39;);const requestPayloads = require(&#39;../requestPayloads&#39;);const apis1ProductsRequest = requestPayloads.apis1.products;const result = await apis.apis1.products(apis1ProductsRequest );expect(result.productName).toBe(&#39;something that expected product name&#39;);</code></pre><h3 id="common-資料夾"><a href="#common-資料夾" class="headerlink" title="common 資料夾"></a>common 資料夾</h3><p>這一層主要是放一些官方沒有提供的 library 實作，或是共用的 function，以 jest 沒有提供的 object contain 為例，就會新增 jestExtend.js，其 code 如下，在 scenario API test 中將會用到。</p><pre><code>expect.extend(/&#123;  toContainObject(received, argument) /&#123;    const pass = this.equals(        received,        expect.arrayContaining([expect.objectContaining(argument)]),    );    if (pass) /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; not to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: true,      /&#125;;    /&#125; else /&#123;      return /&#123;        message: () =&gt;          `expected $/&#123;this.utils.printReceived(              received,          )/&#125; to contain object $/&#123;this.utils.printExpected(argument)/&#125;`,        pass: false,      /&#125;;    /&#125;  /&#125;,/&#125;);</code></pre><h3 id="tests-資料夾"><a href="#tests-資料夾" class="headerlink" title="tests 資料夾"></a>tests 資料夾</h3><p>這一層就是 Jest 的使用層了，會在這一層中使用各個 modules 來組成 test case。</p><p>API 測試種類大致上可以分成兩種</p><ul><li>單一 API 測試 (Single API test)</li><li>API 情境測試 (Scenario API test)</li></ul><p>單一 API 測試是指純粹只有這隻 API 是受測項目，完成測試的條件與其他 API 無關，是一個只需要使用單一一個 API 的測試項目，舉例來說 &#x2F;products API，帶給他 payload，其中會 lack fields，或是沒有帶 header，就稱之為 single API test。</p><p>API 情境測試是指要完成一個測試情境而需要用到多個 API，這裡就會需要引用到多個不同的 API 來達成某種目的，舉例來說 call &#x2F;prodcuts&#x2F;update 更新一個 product 然後再透過 &#x2F;products API 來取得預期被更新的 API，這邊就會引用到兩隻 API，這時候就稱之為 API 的情境測試。</p><p>Single API test，以 &#x2F;products API 為例子，其 code 如下</p><pre><code>const apis = require(&#39;../apis&#39;);test(&#39;Get products, should return 200&#39;, async () =&gt; /&#123;  const result = await apis.products.get();  expect(result.status).toBe(200);/&#125;);</code></pre><p>Scenario API test，以 &#x2F;products, &#x2F;products&#x2F;create 為例子，其 code 如下</p><pre><code>require(&#39;../../common/jestExtend&#39;);const apis = require(&#39;../../apis&#39;);const requestPayloads = require(&#39;../../requestPayloads&#39;);test(&#39;Create product, should get the product at /products&#39;, async () =&gt; /&#123;  const createResult = await apis.products.create(      requestPayloads.products.create,  );  expect(createResult.status).toBe(200);  const result = await apis.products.get();  expect(result.data).toContainObject(requestPayloads.products.create);/&#125;);</code></pre><h2 id="結語和本篇沒提到的事"><a href="#結語和本篇沒提到的事" class="headerlink" title="結語和本篇沒提到的事"></a>結語和本篇沒提到的事</h2><p>在這一篇中沒提到的有以下幾個事情</p><ul><li>json schema 的 validate</li><li>config</li></ul><p>依照目前的架構要擴充這兩件事情都可以很輕鬆，所以就沒有額外再寫出來記錄了</p><p>以上就是這一次整個 API automation 的思考與選擇的筆記<br>感謝各位大大看到這裡，如果有任何建議都可以跟我說，感謝 &lt;(_ _)&gt;</p><p>再次附上 repo: <a href="https://github.com/SQZ777/jest-for-api-automation-template">SQZ777&#x2F;jest-for-api-automation-template (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年是 2022 年，我加入了一間提供 API 服務為主的公司，有很多基礎建設都還沒有存在，這也意味著有很多東西是需要溝通與建構的，其中就包含了將 API 測試案例自動化的基本建置，於是就產生了這篇紀錄，如果不想看心路歷程只想看 code 的話可以直接到 Github 上參</summary>
      
    
    
    
    
    <category term="Automation" scheme="https://blogs.sqz777.com/tags/Automation/"/>
    
    <category term="API" scheme="https://blogs.sqz777.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Prettier ESLint 出現的錯誤：Error: r is not a constructor</title>
    <link href="https://blogs.sqz777.com/2022/02/25/2022-180145/"/>
    <id>https://blogs.sqz777.com/2022/02/25/2022-180145/</id>
    <published>2022-02-25T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p>最近做基礎建設踩到的雷</p><p>在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息</p><blockquote><p><strong>Error: r is not a constructor</strong></p></blockquote><p>目前在 github 上可以看到這個 issue ，而發生這個原因是因為目前 Prettier ESLint 還沒有支援到 eslint 8.0 以上，所以建議將版本降到 7.32.0，如圖</p><p><img src="/img/2022-180145/1645783122.png.png"></p><p><a href="https://github.com/idahogurl/vs-code-prettier-eslint/issues/26">官方的 GitHub issue</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做基礎建設踩到的雷&lt;/p&gt;
&lt;p&gt;在做 auto format 時遇到的問題，在 output 中可以看見錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Error: r is not a constructor&lt;/strong&gt;&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
    <category term="VSCode" scheme="https://blogs.sqz777.com/tags/VSCode/"/>
    
    <category term="vs-code-prettier-eslint" scheme="https://blogs.sqz777.com/tags/vs-code-prettier-eslint/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - Suite Setup V.S Test Setup</title>
    <link href="https://blogs.sqz777.com/2021/11/16/2021-224604/"/>
    <id>https://blogs.sqz777.com/2021/11/16/2021-224604/</id>
    <published>2021-11-16T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義</p><p>Test Setup</p><p><em><strong>a test setup is something that is executed before a test case, and a test teardown is executed after a test case.</strong></em></p><p>Suite Setup</p><p><em><strong>A suite setup is executed before any test cases or sub test suites in that test suite, and similarly a suite teardown is executed after them.</strong></em></p><p>原文連結：<a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#id594">Robot Framework User Guide #id594</a></p><p>簡單來說</p><ul><li>Test Setup 會在每次 case 開始前執行一次</li><li>Suite Setup 是 robot file 開始執行 test case 前執行一次</li></ul><p>Suite 單位為 .robot file<br>Test 的單位為 test case</p><p>廢話不多說，先上 code，Test Setup 的 code 如下</p><pre><code>*** Settings ***Test Setup    Log To Console    Setup in Test!*** Test Cases ***Test Setup 1    Log To Console    Test Case 1Test Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的 code 如下</p><pre><code>*** Settings ***Suite Setup    Log To Console   Setup in Suite!*** Test Cases ***Suite Setup 1    Log To Console    Test Case 1Suite Setup 2    Log To Console    Test Case 2</code></pre><p>Suite Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073888.png"></p><p>Test Setup 的執行結果：</p><p><img src="/img/2021-224604/1637073897.png"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從 Code 的執行結果來看，如果一個 robot file 中有多個 Test Case</p><ul><li>Suite Setup 只會被執行一次</li><li>Test Setup 會被執行多次</li></ul><p>以上為簡單的筆記，感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇將直接介紹兩者的差異，在了解差異之前先讀一下官方文件的定義&lt;/p&gt;
&lt;p&gt;Test Setup&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;a test setup is something that is executed before a test case, and a</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
    <category term="SuiteSetup" scheme="https://blogs.sqz777.com/tags/SuiteSetup/"/>
    
    <category term="TestSetup" scheme="https://blogs.sqz777.com/tags/TestSetup/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 使用 config.ini 管理環境變數</title>
    <link href="https://blogs.sqz777.com/2021/11/08/2021-204911/"/>
    <id>https://blogs.sqz777.com/2021/11/08/2021-204911/</id>
    <published>2021-11-08T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>這篇會介紹：</p><ul><li>為何要使用 config.ini</li><li>Variables 在 *** Settings ***</li><li>如何使用 config.ini</li></ul><p>安安 我來填坑了</p><p><img src="/img/2021-204911/1636375721.png"></p><h2 id="為什麼要使用-config-ini"><a href="#為什麼要使用-config-ini" class="headerlink" title="為什麼要使用 config.ini"></a>為什麼要使用 config.ini</h2><p>透過 config.ini 可以</p><ul><li>根據環境定義不同的環境變數</li><li>避免將機敏資料寫在程式碼中</li><li>避免第三方服務變更時，有大量的檔案需要被變更</li></ul><p>一般來說在開發任何的程式時都會有環境的區別，使用 config 檔案可以，除了環境的區別之外，還有不適合直接寫在程式碼中的資料例如：token、API 的 URL 等</p><h2 id="Variables-在-Settings"><a href="#Variables-在-Settings" class="headerlink" title="Variables 在 *** Settings ***"></a>Variables 在 *** Settings ***</h2><p>在知道如何使用 config.ini 之前須要先知道 Variables 在 Settings 中的作用是什麼</p><p>根據 <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variable-files">Robot Framework 的文件</a>可以看到 Variables 有兩種方式可以透過 .py 引入變數</p><ul><li>Getting variables directly from a module</li><li>Getting variables from a special function</li></ul><h3 id="Getting-variables-directly-from-a-module-的方式"><a href="#Getting-variables-directly-from-a-module-的方式" class="headerlink" title="Getting variables directly from a module 的方式"></a>Getting variables directly from a module 的方式</h3><p>官方定義：</p><p><em>Variables are specified as module attributes. In simple cases, the syntax is so simple that no real programming is needed. For example, creates a variable with the specified text as its value. One limitation of this approach is that it does not allow using arguments.MY_VAR &#x3D; ‘my value’$&#x2F;{MY_VAR&#x2F;}</em></p><p>以官方定義來說就可以直接看到這個方式的缺點就是沒有支援使用 arguments.MY_VAR 的方式使用變數</p><p>以範例來看使用這種方式的結果會是這樣</p><p>python 的程式碼：</p><pre><code>MY_NAME = &quot;SQZ777&quot;</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;_MY_NAME/&#125;</code></pre><p>執行結果就可以看到</p><p><img src="/img/2021-204911/1636374905.png"></p><h3 id="Getting-variables-from-a-special-function-的方法"><a href="#Getting-variables-from-a-special-function-的方法" class="headerlink" title="Getting variables from a special function 的方法"></a>Getting variables from a special function 的方法</h3><p>官方定義：</p><p><em>An alternative approach for getting variables is having a special function (also camelCase syntax is possible) in a variable file. If such a function exists, Robot Framework calls it and expects to receive variables as a Python dictionary or a Java with variable names as keys and variable values as values. Created variables can be used as scalars, lists, and dictionaries exactly like when getting variables directly from a module, and it is possible to use and prefixes to make creating list and dictionary variables more explicit. The example below is functionally identical to the first example related to getting variables directly from a module.get_variablesgetVariablesMapLIST__DICT__</em></p><p>簡單來說，透過這個方式就可以使變數有「環境」這一層的定義，除此之外還要注意的是，python 的檔案中要定義 function 的名稱為 <strong>get_variables</strong></p><p>直接來示範吧！</p><p>python 的程式碼：</p><pre><code>def get_variables():    var = &quot;BLOG_ENV.MY_NAME&quot;    variables = /&#123;/&#125;    variables[var] = &quot;SQZ777&quot;    return variables</code></pre><p>.robot 的程式碼如下</p><pre><code>*** Settings ***Variables    test_variables.py*** Test Cases ***Test variable in python    Log To Console    My Name In Python File Is $/&#123;BLOG_ENV.MY_NAME/&#125;</code></pre><p>在這裡就可以注意到我的變數已經可以隸屬於不同的環境了（BLOG_ENV 中的 MY_NAME）</p><h2 id="如何使用-config-ini"><a href="#如何使用-config-ini" class="headerlink" title="如何使用 config.ini"></a>如何使用 config.ini</h2><p>了解了兩種不同的引入環境變數的方式終於來到最後了解如何使用 config.ini 的部分啦！</p><p>透過 configparser 讀取 config.ini ，再將檔案中所有被定義好的變數回傳給 Robot Framework 就可以達成使用 config.ini 的方法</p><p>python 的程式碼：</p><pre><code>import configparserdef get_variables(config_path=&quot;./config.ini&quot;):    config = configparser.ConfigParser()    config.read(config_path)    variables = /&#123;/&#125;    print(config.sections)    for section in config.sections():        for key, value in config.items(section):            var = &quot;%s.%s&quot; % (section, key)            variables[var] = value    return variables</code></pre><p>config.ini 內容：</p><pre><code>[BLOG_ENV]MARVEL_URL = &lt;http://gateway.marvel.com/&gt;MARVEL_PUBLIC_KEY = 你的 public keyMARVEL_PRIVATE_KEY = 你的 private key</code></pre><p>在 robot 中使用 config，如下圖</p><p><img src="/img/2021-204911/1636374936.png"></p><p>在這裡就會出現一個疑問，這樣不就等於環境被寫死了嗎？</p><p><img src="/img/2021-204911/1636374948.png"></p><p>所以這邊為了讓使用上更方便，環境的定義可以透過 command line 來傳入，在執行 Robot Framework 時，代入參數，如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><p>而 .robot 的檔案則須要改成取用 ENV 這個在 command line 中傳入的變數。</p><p><img src="/img/2021-204911/1636374966.png"></p><p>這樣就能執行到指定的環境與變數囉!</p><p>感謝收看 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇會介紹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;為何要使用 config.ini&lt;/li&gt;
&lt;li&gt;Variables 在 *** Settings ***&lt;/li&gt;
&lt;li&gt;如何使用 config.ini&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安安 我來填坑了&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    
    <category term="config" scheme="https://blogs.sqz777.com/tags/config/"/>
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
    <category term="環境變數" scheme="https://blogs.sqz777.com/tags/%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework - 介紹一下</title>
    <link href="https://blogs.sqz777.com/2021/10/17/2021-191743/"/>
    <id>https://blogs.sqz777.com/2021/10/17/2021-191743/</id>
    <published>2021-10-17T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩</p><p>這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的</p><p><img src="/img/2021-191743/1634469178.png"></p><h2 id="介紹與使用場景"><a href="#介紹與使用場景" class="headerlink" title="介紹與使用場景"></a>介紹與使用場景</h2><p>Robot Framework 是一個基於 python 的 自動化框架，基本上可以用 python 達成的事情，Robot Framework 都可以做到，其應用的場景是 ATDD (Acceptance Test Driven Development)、BDD (Behavior Driven Development) 以及可以被機器化的流程。</p><p><img src="/img/2021-191743/1634469201.png"></p><h2 id="為何使用-Robot-Framework"><a href="#為何使用-Robot-Framework" class="headerlink" title="為何使用 Robot Framework?"></a>為何使用 Robot Framework?</h2><ul><li>學習資源易於取得</li><li>易於理解與學習的介面</li><li>已有豐富的 Keyword 可以使用</li></ul><p>Robot Framework 對於沒有程式基礎的人來說是「相對」易於理解的，因為他有最接近人類自然語言的介面讓人閱讀，在政治條件（？）上比較能夠說服他人使用這個工具。</p><p>你通常不太需要再自行開發 Keyword 就可以完成你需要執行的自動化流程，如果需要，你也能夠透過實作 Python 來完成你需要做的事。</p><h2 id="看懂-Robot-Framework"><a href="#看懂-Robot-Framework" class="headerlink" title="看懂 Robot Framework"></a>看懂 Robot Framework</h2><p>先來張圖，這張圖是 Robot Framework 的文件，紅框的部分：</p><p><img src="/img/2021-191743/1634469224.png"></p><h2 id="Settings"><a href="#Settings" class="headerlink" title="*** Settings ***"></a>*** Settings ***</h2><p>這裡是引入 library 以及初始化的地方</p><p><img src="/img/2021-191743/1634469248.png"></p><ul><li>如果你在別的 .robot 中定義好了需要被引入的 library 或是 Keywords 可以透過 Resource 來達成引入的動作</li><li>Suite Setup 則是在測試跑起來時會做的初始化動作</li></ul><p>這邊幫自己挖個坑，會再發一篇 Suite Setup 跟 Test Setup 的差別。<br>此坑已補上： <a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Robot Framework - Suite Setup V.S Test Setup | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a>  </p><p><img src="/img/2021-191743/1634469266.png"></p><p>看一下 settings.robot</p><p><img src="/img/2021-191743/1634469282.png"></p><p>會使用 settings.robot 來統一引入 library 的原因是為了避免 .robot 的檔案多了，每一個檔案都要重新引入那些 library 實在是麻煩，所以乾脆由一個 file 來控制需要被引入的 library，這樣簡單得多。<br>Variables 讓你可以直接透過檔案的形式讓你引入環境變數<br>Library 則是讓你可以引入 python 或是 Robot Framework 的 library<br>RequestsLibrary 是別人開發好的 Robot Framework 的 Library，需要使用以下指令安裝後才能使用，這個 library 可以讓我們省掉開發 Requests Keyword 的時間。</p><pre><code>python -m pip install robotframework-requests</code></pre><p><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html">RequestsLibrary Keyword 使用方法的文件點我</a></p><h2 id="Variables"><a href="#Variables" class="headerlink" title="*** Variables ***"></a>*** Variables ***</h2><p>這裡是定義這個檔案中會用到的常數</p><p><img src="/img/2021-191743/1634469327.png"></p><p>通常這裡的變數不會直接寫死在這裡，而是會在另一個檔案中定義 config.ini 之類的然後在透過變數來做取用</p><p>所以我這邊也是再挖一個坑，會再發一篇如何定義 config.ini 然後在 robot 裡面中引用那個環境變數<br>此坑已補上：<a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">Robot Framework - 使用 config.ini 管理環境變數 | sqz777 der 技術小本本 - 點部落 (dotblogs.com.tw)</a></p><p><img src="/img/2021-191743/1634469353.png"></p><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="*** Keywords ***"></a>*** Keywords ***</h2><p>這裡是自定義關鍵字的地方，可以在這裡定義好關鍵字後，在 Test Case 中使用</p><p><img src="/img/2021-191743/1634469372.png"></p><p>Get Character With Beginning Of The Name，這個是 Keyword 的名稱</p><p>[Arguments] 讓 Keyword 被定義成是可以被傳入參數的，而這個參數名稱是 character_name，定義完成後即可在 Test Case 中使用</p><p>而 Keyword 再往下一層則是 python 的程式碼，以圖中行號 13 的 Get Md5 Hash 為例，這個 Get Md5 Hash 是我自行實作在 <a href="http://common.py/">common.py</a> 的一段 python code</p><p>P.S. <a href="http://common.py/">common.py</a> 已在 settings.robot 中引入。</p><pre><code>import hashlibdef get_md5_hash(data):    hasher = hashlib.md5()    hasher.update(data.encode(&quot;utf-8&quot;))    return hasher.hexdigest()</code></pre><p>以此為例，你可以使用 Get Md5 Hash 或是 get_md5_hash 都可以，只要文件內有統一的格式即可。</p><p>其他的 Keyword 對應官方文件有</p><ul><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Get%20Time">Get Time</a><br>可以指定格式取得 Datetime</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Create%20Dictionary">Create Dictionary</a><br>建立 Dictionary</li><li><a href="https://marketsquare.github.io/robotframework-requests/doc/RequestsLibrary.html#GET%20On%20Session">Get On Session</a><br>建立於 Session 上來 request 其方法為 Get</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Return%20From%20Keyword">Return From Keyword</a><br>Get Character With Beginning Of The Name 這一個 Keyword 即將返回的值</li><li><a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal%20As%20Strings">Should Be Equal As Strings</a><br>斷言（Assert）兩個值的型態為 string 時會是相同的。</li></ul><h2 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="*** Test Cases ***"></a><strong>*** Test Cases ***</strong></h2><p>這裡是定義 Test Case 的地方，會透過使用 Keyword 來組合成需要被自動化的流程</p><p><img src="/img/2021-191743/1634469384.png"></p><h2 id="開發準備"><a href="#開發準備" class="headerlink" title="開發準備"></a><strong>開發準備</strong></h2><p>開發前要準備的就是環境啦</p><ul><li><p>python</p></li><li><p>python package: robotframework</p></li><li><p>python package: robotframework-requests</p><p>python -m pip install robotframework robotframework-requests</p></li></ul><h2 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h2><p>package 安裝完成後，就可以開始寫一些需要自動化的項目了，開始寫之前先決定要做的自動化項目是什麼</p><ul><li>準備 request 過去 Marvel API 的 token 資訊，Marvel API 的 token 申請，可以參考 repo 中的 readme </li><li>透過 Marvel 的 API 取得角色名稱開頭為 “Tony” 的角色資訊</li><li>唯一一個角色開頭為 “Tony” 的人就是 Tony Stark 所以必須要能取得 Tony Stark 這個名字</li></ul><p>robot 的 Test Suite 如下</p><pre><code>*** Settings ***Resource    settings.robotSuite Setup    Create Session    MARVEL_API    $/&#123;$/&#123;ENV/&#125;.MARVEL_URL/&#125;*** Variables ***$/&#123;api_private_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PRIVATE_KEY/&#125;$/&#123;api_public_key/&#125;=    $/&#123;$/&#123;ENV/&#125;.MARVEL_PUBLIC_KEY/&#125;*** Keywords ***Get Character With Beginning Of The Name    [Arguments]    $/&#123;character_name/&#125;    $/&#123;timestamp/&#125;=    Get Time    epoch    $/&#123;hash/&#125;=    Get Md5 Hash    $/&#123;timestamp/&#125;$/&#123;api_private_key/&#125;$/&#123;api_public_key/&#125;    $/&#123;params/&#125;=    Create Dictionary    ts=$/&#123;timestamp/&#125;    apikey=$/&#123;api_public_key/&#125;    hash=$/&#123;hash/&#125;    nameStartsWith=$/&#123;character_name/&#125;    $/&#123;response/&#125;=    Get On Session    alias=MARVEL_API    url=/v1/public/characters    params=$/&#123;params/&#125;    expected_status=200    Return From Keyword    $/&#123;response/&#125;*** Test Cases ***Get Beginning With Tony&#39;s Character Name Info    $/&#123;result/&#125;=    Get Character With Beginning Of The Name    Tony    Should Be Equal As Strings    $/&#123;result.json()[&quot;data&quot;][&quot;results&quot;][0][&quot;name&quot;]/&#125;    Tony Stark</code></pre><h2 id="Repo-點我"><a href="#Repo-點我" class="headerlink" title="Repo 點我"></a><a href="https://github.com/SQZ777/robotframework-marvel">Repo 點我</a></h2><h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><p>若要執行指令如下</p><pre><code>python -m robot --variable ENV:BLOG_ENV marvel.robot</code></pre><h2 id="執行中"><a href="#執行中" class="headerlink" title="執行中"></a>執行中</h2><p><img src="/img/2021-191743/1637074430.png"></p><h2 id="執行後"><a href="#執行後" class="headerlink" title="執行後"></a>執行後</h2><p>在執行後可以看到 Robot Framework 產出的 report</p><p><img src="/img/2021-191743/1637074439.png"></p><p>在 report 中可以看到執行的時間與成功數量等，除此之外，你也能夠透過 report 看見執行的細節，例如 API 的 response json、該步驟的執行時間等</p><p><img src="/img/2021-191743/1637074452.png"></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這一篇介紹了為何要使用 Robot Framework，再到如何看懂 Robot Framework 的文件，希望大家可以因為這篇而看得懂 Robot Framework &lt;(_ _)&gt;</p><p>已補坑：</p><ul><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/16/224604">Suite Setup V.S. Test Setup</a></li><li><a href="https://dotblogs.com.tw/Im_sqz777/2021/11/08/204911">在 Robot Framework 中，使用 config.ini 的檔案定義環境變數</a></li></ul><p>2021&#x2F;11&#x2F;16：補充執行所需的環境準備以及實際的題目應用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近要介紹新人 Robot Framework 的時候發現自己居然沒寫過這個已經用很久的工具，所以決定來介紹一下 Robot Framework 🤩&lt;/p&gt;
&lt;p&gt;這篇目的是讓一般人能夠看懂 Robot Framework 的文件並了解其中各個部分的目的&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
    <category term="RobotFramework" scheme="https://blogs.sqz777.com/tags/RobotFramework/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 4/17 技術管理者論壇－商業與技術的平衡</title>
    <link href="https://blogs.sqz777.com/2021/04/18/2021-235858/"/>
    <id>https://blogs.sqz777.com/2021/04/18/2021-235858/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>好久沒參加社群了，筆記一下！ </p><p>昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了</p><p>這天講的內容印象最深刻有 2 個+1個</p><ul><li>Gipi 講的上游理論</li><li>91 來我們這組討論</li><li>我自己提出的問題（群組沒討論，但是我自己想了一輪 XD）</li></ul><h2 id="上游理論"><a href="#上游理論" class="headerlink" title="上游理論"></a>上游理論</h2><p>Gipi 描述了問了大家一個問題</p><blockquote><p>「今天你待的地方是在中游，有一天你發現上游的人開始丟垃圾、拉屎在河裡，讓你平常用的水變成垃圾水、糞水，請問你們會怎麼做？」</p></blockquote><p>台下的人很踴躍的回答了</p><p>「找上游的人理論」</p><p>「烙下游的人一起去找上游的人理論」</p><p>「找別條河」</p><p>．．．</p><p>最後有一個人回答了關鍵的答案 我猜是樁腳</p><blockquote><p>「去幫助上游的人」</p></blockquote><h3 id="為什麼是去幫助上游的人？"><a href="#為什麼是去幫助上游的人？" class="headerlink" title="為什麼是去幫助上游的人？"></a>為什麼是去幫助上游的人？</h3><p>因為上游的人讓河流變髒了，肯定是有原因的，沒有人平白無故把珍貴的資產－河流變糟<br>在幫助他們時，你就必須去了解他為什麼要把這些垃圾、排泄物丟進河裡 這會使你更能體諒他們為何這樣做，也會讓他們知道你不是來出一張嘴的</p><h3 id="和他們一起解決問題是最容易的"><a href="#和他們一起解決問題是最容易的" class="headerlink" title="和他們一起解決問題是最容易的"></a>和他們一起解決問題是最容易的</h3><p>就算你最後沒辦法和他們一同解決這些問題，你仍然能夠在這個幫助的過程中獲得一些經驗，而這些難得的經驗能夠成為你在抵達下一條河流時的養分。<br>千萬不要在發現河流中出現異樣時，只抱怨，不做事，這樣不但沒辦法改變現狀，也無法學習到任何事情。 上述所提到的河流可以替換成公司，中游則是你自己在公司所代表的角色，而上層可以替換成任何與你合作的對象。</p><h2 id="小組討論"><a href="#小組討論" class="headerlink" title="小組討論"></a>小組討論</h2><p>我們這組提到了不少問題，其中有被拿出來討論的就是</p><blockquote><p>如何讓技術能夠量化並且順利推動？</p></blockquote><p>91：「你要做到的是用他的語言來去描述你想做的事情，你所提出的事情要能夠打到他在意的點，舉例來說你要推 CI&#x2F;CD、TDD，商業的人，像是業務、老闆要怎麼懂？」<br>「你要做的是『你跟老闆說你做 OOXX 事情，目的可以節省多少時間』，而使用這個節省的時間來推算能夠節省的金錢」<br>「如果某些提出來的功能很急而影響到你目前的實作進度，你也可以透過埋 log、埋 GA，觀察他所謂『很急』的功能的使用率，讓數據說話」</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li>用對方在乎的事情解釋<ul><li>用時間推算金錢成本，花下去的成本用多少時間可以回收？</li></ul></li></ul><h2 id="我自己提出的問題"><a href="#我自己提出的問題" class="headerlink" title="我自己提出的問題"></a>我自己提出的問題</h2><p>我提出的問題沒有被我們這一組的其他人選擇，因為我自己提出的問題比較沒有符合今天的主題「商業與技術的平衡」（也許是因為菜味十足的我還沒碰到技術與商業平衡的問題 🤡🤡）</p><p>因為最近才剛開始在團隊中整理一些程式碼，幫忙寫一些 Unit Test，在這個過程中發現了一些現象，所以我提出的問題是</p><blockquote><p>如何讓團隊有一個更完整（良好）的開發規範</p></blockquote><p>例如：在 C# 中偏好使用 var 來做變數的宣告等…</p><p>這兩天我思考了一下，我覺得像這樣的程式語言的「使用偏好」，比較像是「傳教」，而不是商業與技術中的平衡，所以沒被拿出來很正常w</p><p><img src="/img/2021-235858/artworks-000118550301-1jpyp5-t500x500.jpg" alt="玖壹壹- 歪國人( 小八2015.5.25 ReMiX - ) by Dj小八Taiwan"></p><p>今天跟我弟討論了一輪，在對話的過程中，我找到了一個…出入，或許說是一個…題目？</p><blockquote><p>如何傳教成功？</p></blockquote><p>首先我必須先認知到傳教不是吵架辯論，而是你認為這個東西超讚，所以你覺得其他人也應該要跟我一起信仰他<br>如果我透過吵架辯論的方式，我應該永遠無法傳教成功，甚至會把他推得更遠（尤其是這個跟我辯論的人，是我的同事）<br>你應該很難想像騎腳踏車上路的傳教士跟機車騎士在路邊爭論打架吧？  </p><p>在這邊先打住，在這邊列一下今天我跟我弟的討論內容</p><p>我：「你覺得到底該怎麼樣，才能讓團隊裡面的人使用到這些偏好？」<br>他：「我覺得沒有必要推這件事，這件事（以偏好使用 var 來說）對於最後所產出的價值並不會影響到很大」<br>我：「所以你的意思是說這些偏好其實都是沒有價值的嗎？」<br>他：「也不能這樣說，舉個我前公司的例子，他們有一個規範是為了方便找到這個 Function 所以在 Class 中的所有 Function 排序是有一定規則的，當我問到我的 Team Lead 時，他就是這麼跟我解釋的，所以我也會認同這件事，因為這個規範就已經是存在，而且我們團隊的人都認同這件事。」 <br>我：「也就是說如果有一個規範，他是由團隊內德高望重的人在專案中使用，那他就會被大家遵守囉？」<br>他：「是」<br>我：「那假設你今天是團隊中德高望重的人，你要怎麼讓大家使用這些偏好？」<br>他、我：「…」</p><p>這個空氣靜默的時間很短，大概有一秒那麼長</p><p>我就想出了一個解答並說：</p><blockquote><p>「這件事並不是由團隊中德高望重的人來讓大家使用，而是在你做這件事情的時候，大家也都認同，在這個情況之下，你也不用『讓』大家使用這些偏好了，他們自己就會『自動』使用這些偏好了」</p></blockquote><p>所以最後的問題就不會是「如何傳教成功？」了</p><p>而是</p><blockquote><p>你在團隊中如何建立 Credit，影響到其他人？</p></blockquote><p>知道真正的問題是這個，做法就變得顯而易見了！</p><p>雖然心中有一些答案但是仍然想問大家的就是，我最後所提到的問題</p><p><strong>你在團隊中如何建立 Credit，影響到其他人？</strong></p><p>以上是今天的筆記，感謝大家收看，如有錯誤麻煩提出來讓我修正 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久沒參加社群了，筆記一下！ &lt;/p&gt;
&lt;p&gt;昨天社群結束之後，因為去喝了一些酒，所以就沒有在昨天 output 了&lt;/p&gt;
&lt;p&gt;這天講的內容印象最深刻有 2 個+1個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gipi 講的上游理論&lt;/li&gt;
&lt;li&gt;91 來我們這組討論&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="社群" scheme="https://blogs.sqz777.com/tags/%E7%A4%BE%E7%BE%A4/"/>
    
    <category term="筆記" scheme="https://blogs.sqz777.com/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="商業與技術" scheme="https://blogs.sqz777.com/tags/%E5%95%86%E6%A5%AD%E8%88%87%E6%8A%80%E8%A1%93/"/>
    
  </entry>
  
  <entry>
    <title>筆記－什麼是時序耦合（Temporal Coupling）？</title>
    <link href="https://blogs.sqz777.com/2021/04/18/2021-what-is-temporal-coupling/"/>
    <id>https://blogs.sqz777.com/2021/04/18/2021-what-is-temporal-coupling/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.132Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式</a><br>其中第四章提到了時序耦合（Temporal Coupling）<br>覺得是一個值得寫下來筆記的東西，所以就產出了這篇。</p><p>第一次看到時序耦合這個詞的時候還以為是…Dio?</p><p><img src="/img/2021-what-is-temporal-coupling/1618680807.png"></p><p>結果並不是，讓我太失望了（並沒有失望）</p><h2 id="正文開始"><a href="#正文開始" class="headerlink" title="正文開始"></a>正文開始</h2><p><strong>耦合是指程式中模組及模組之間資訊或參數依賴的程度。</strong><br><strong>其相對的一個概念的詞叫做聚合性，也就是說低耦合性代表高內聚性。</strong></p><p>時序耦合是多種耦合分類中的其中一種　<a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>時序耦合指的是這個 Class 中含有的 Functions 有隱性的「先後順序」的耦合性，這是一個「Design Smell」<br>舉參考資料的程式碼為例</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public void Initialize(string fileName)  /&#123;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>使用這個程式碼，會是這樣</p><pre><code>var fileName = &quot;C:\test.txt&quot;;var fileLogger = new FileLogger();fileLogger.Initialize(fileName);fileLogger.Write(&quot;Log message.&quot;);</code></pre><p>假設這個 fileLogger 沒有在呼叫 Write 這個 Function 之前先呼叫 Initialize 就會造成 fileLogger 在 Write 訊息的時候造成無法找到檔案名稱的錯誤<br>而這樣子的程式碼所造成的結果就稱之為時序耦合。</p><h2 id="如何避免時序耦合"><a href="#如何避免時序耦合" class="headerlink" title="如何避免時序耦合?"></a>如何避免時序耦合?</h2><h3 id="透過-Constructor-Injection-的方式"><a href="#透過-Constructor-Injection-的方式" class="headerlink" title="透過 Constructor Injection 的方式"></a>透過 Constructor Injection 的方式</h3><p>在這個案例中，可以透過 Constructor Injection 的方式進行注入 fileName 即可<br>範例程式碼</p><pre><code>public class FileLogger/&#123;  private readonly string _fileName;  public FileLoger(string fileName)  /&#123;    if(string.IsNullOrEmpty(fileName))    /&#123;      throw new ArgumentNullException(&quot;fileName&quot;);    /&#125;    _fileName = fileName;  /&#125;  public void Write(string message)  /&#123;    // dependency with _fileName code  /&#125; /&#125;</code></pre><p>這樣的方式除了可以避免時序耦合之外，也能夠減少外部呼叫的次數（不需要再呼叫 Initialize）。<br>另外也能夠透過建構子的方式觀察到這個 FileLogger 本身所依賴的事情有哪些。</p><p>參考資料：<br><a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br><a href="https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw">依賴注入：原理、實作與設計模式 (Dependency Injection: Principles, Practices, Patterns, 2&#x2F;e)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合性 (電腦科學) - 維基百科，自由的百科全書 (wikipedia.org)</a></p><p>備註：<a href="https://www.infoworld.com/article/3239347/how-to-avoid-temporal-coupling-in-c-sharp.html">How to avoid temporal coupling in C# | InfoWorld</a><br>這篇當中有提到另一個避免時序耦合的方式（抽象工廠 <strong>abstract factory</strong>），但如果沒有特殊限制的話，我會比較偏好使用本篇所記錄的 constructor injection 的方式來避免時序耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看 &lt;a href=&quot;https://www.tenlong.com.tw/products/9789864344987?list_name=i-r-zh_tw&quot;&gt;依賴注入：原理、實作與設計模式&lt;/a&gt;&lt;br&gt;其中第四章提到了時序耦合（Temporal Couplin</summary>
      
    
    
    
    
    <category term="筆記" scheme="https://blogs.sqz777.com/tags/%E7%AD%86%E8%A8%98/"/>
    
    <category term="DI" scheme="https://blogs.sqz777.com/tags/DI/"/>
    
    <category term="CodeSmell" scheme="https://blogs.sqz777.com/tags/CodeSmell/"/>
    
  </entry>
  
  <entry>
    <title>C# - Dotnet core 的 DI 如何在註冊時帶給建構子未註冊進 DI 的服務</title>
    <link href="https://blogs.sqz777.com/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/"/>
    <id>https://blogs.sqz777.com/2021/03/18/2021-DotnetCoreDIConstructorWithParameters/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體</p><h2 id="註冊已經註冊進-DI-的實體"><a href="#註冊已經註冊進-DI-的實體" class="headerlink" title="註冊已經註冊進 DI 的實體"></a>註冊已經註冊進 DI 的實體</h2><h2 id="程式碼準備"><a href="#程式碼準備" class="headerlink" title="程式碼準備"></a>程式碼準備</h2><p>準備 interface IAction 跟 class Action</p><pre><code>public interface IAction/&#123;    void ShakeHands();/&#125;public class Action : IAction/&#123;    public void Dance()    /&#123;        Console.WriteLine(&quot;Dancing!&quot;);    /&#125;/&#125;</code></pre><p>準備一個 dog 的 interface 跟 他的 class，並且需要透過建構子注入 IAction 這個服務</p><pre><code>public interface IDog/&#123;    void DogDance();/&#125;public class Dog : IDog/&#123;    IAction _action;    public Dog(IAction action)    /&#123;        _action = action;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;/&#125;</code></pre><p>蛤? 你說狗不會跳舞怎麼可以繼承 IAction 然後 Dance?</p><p>這不是在跳了嗎(誤</p><p>主程式碼 長這個樣子</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog, Dog&gt;();    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();/&#125;</code></pre><p>就可以看到執行結果</p><pre><code>Dog isDancing!</code></pre><p>如果是已經註冊進 DI 的服務，服務在啟動時會自動幫忙注入已經註冊的實體，所以只要<code>serviceCollection.AddScoped&lt;IDog, Dog&gt;();</code>即可</p><h2 id="註冊時，代入未註冊進-DI-的實體"><a href="#註冊時，代入未註冊進-DI-的實體" class="headerlink" title="註冊時，代入未註冊進 DI 的實體"></a>註冊時，代入未註冊進 DI 的實體</h2><p>這時就需要將原本的 Dog 多新增一點需要依賴的服務啦，最近 Cyberpunk 2077 很紅，那就讓它變成機器狗吧</p><p><img src="/img/2021-DotnetCoreDIConstructorWithParameters/4137968e6d4fab392ba7db14017ec100.jpg" alt="Dogenator | Cyberpunk, Cyberpunk 2077, Dog communication"></p><p>所以就先定義一個 Machine 的 class 吧!</p><pre><code>public class Machine/&#123;    public void Glow()    /&#123;        Console.WriteLine(&quot;Glowing!&quot;);    /&#125;/&#125;</code></pre><p>機器人的特色就是會發光 所以就讓他可以 Glow!</p><p>接下來將狗的 Constructor 變成需要多依賴 Machine 這個 class 吧!</p><pre><code>public interface IDog/&#123;    void DogDance();    void DogGlow();/&#125;public class Dog : IDog/&#123;    IAction _action;    Machine _machine;    public Dog(IAction action, Machine machine)    /&#123;        _action = action;        _machine = machine;    /&#125;    public void DogDance()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _action.Dance();    /&#125;    public void DogGlow()    /&#123;        Console.WriteLine(&quot;Dog is&quot;);        _machine.Glow();    /&#125;/&#125;</code></pre><p>主程式碼修改成這樣</p><pre><code>static void Main(string[] args)/&#123;    var serviceCollection = new ServiceCollection();    serviceCollection.AddScoped&lt;IAction, Action&gt;();    serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));    var serviceProvider = serviceCollection.BuildServiceProvider();    var dog = serviceProvider.GetService&lt;IDog&gt;();    dog.DogDance();    dog.DogGlow();/&#125;</code></pre><p>關鍵在於這一行，</p><pre><code>serviceCollection.AddScoped&lt;IDog&gt;(svc =&gt; new Dog(svc.GetService&lt;IAction&gt;(), new Machine()));</code></pre><p><code>svc</code> 的類別是 <code>IServiceProvider</code><br><code>new Dog</code> 的意思可以理解為 將 Dog 註冊至 IDog 中<br>而<code>svc.GetService&lt;IAction&gt;(), new Machine()</code>這部分可以理解為取得已經註冊的實體並注入進 new Dog 的這個 constructor 中</p><p>就可以看到執行結果</p><pre><code>Dog isDancing!Dog isGlowing!</code></pre><p>以上為今天的筆記<br>感謝收看!</p><p>本篇的 github 連結:<br><a href="https://github.com/SQZ777/DotnetCoreDIWithParamter">SQZ777&#x2F;DotnetCoreDIWithParamter (github.com)</a><br>Refrence:<br><a href="https://blog.darkthread.net/blog/aspnet-core-di-notes/">筆記 - 不可不知的 ASP.NET Core 依賴注入-黑暗執行緒 (darkthread.net)</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped?view=dotnet-plat-ext-5.0&WT.mc_id=DOP-MVP-37580#Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_AddScoped__1_Microsoft_Extensions_DependencyInjection_IServiceCollection_System_Func_System_IServiceProvider___0__">ServiceCollectionServiceExtensions.AddScoped 方法 (Microsoft.Extensions.DependencyInjection) | Microsoft Docs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為要用 AWS lambda function 的緣故，所以有時候會需要在註冊服務時代入還沒註冊好的實體&lt;/p&gt;
&lt;h2 id=&quot;註冊已經註冊進-DI-的實體&quot;&gt;&lt;a href=&quot;#註冊已經註冊進-DI-的實體&quot; class=&quot;headerlink&quot; title=&quot;註冊已</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://blogs.sqz777.com/tags/NetCore/"/>
    
    <category term="Constructor" scheme="https://blogs.sqz777.com/tags/Constructor/"/>
    
    <category term="DI" scheme="https://blogs.sqz777.com/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>C# - 如何在 AWS lambda 裡面使用 dotnet core 的 DI</title>
    <link href="https://blogs.sqz777.com/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/"/>
    <id>https://blogs.sqz777.com/2021/03/14/2021-AWSLambdaUseDotnetCoreDI/</id>
    <published>2021-03-14T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>dotnet core 的 DI 很好用</p><p>所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI</p><p>首先先建立一個 interface, 就叫 ITalkService 好了~</p><pre><code>namespace AWSLambdaAndDI/&#123;    public interface ITalkService    /&#123;        string SayHello(string name);    /&#125;/&#125;</code></pre><p>再寫一個他的實體 TalkService</p><pre><code>namespace AWSLambdaAndDI/&#123;    public class TalkService : ITalkService    /&#123;        public string SayHello(string name)        /&#123;            return name + &quot;: hello!&quot;;        /&#125;    /&#125;/&#125;</code></pre><p>這樣一來我們已經有了 interface 也有實作他的 class，接下來就來看一下如何在一般的 function 使用 dotnet core 的 DI 吧</p><p>首先需要使用 dotnet core CLI 來新增 package</p><pre><code>dotnet add package Microsoft.Extensions.DependencyInjection</code></pre><p>裝完之後就可以看到相依性裡面的套件出現 Microsoft.Extensions.DependencyInjection</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615732181.png"></p><p>我使用了 Visual Studio 來建立了一個 AWS Lambda 的專案，初始的程式碼會長這樣，並將這個 lambda 的 function 相依於前面已經實作好的 interface</p><pre><code>using Amazon.Lambda.Core;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    private readonly ITalkService _talkService;    public class Function    /&#123;                /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return input?.ToUpper();        /&#125;    /&#125;/&#125;</code></pre><p>如果要加入 DI ，需要在 constructor 中將需要用的 instance 跟對應到的 interface 進行註冊</p><p>constructor 的 code 會長這個樣子</p><pre><code>public Function()/&#123;  // 建立 DI  var serviceCollection = new ServiceCollection();  // 將 TalkService 註冊進 DI  serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();  var serviceProvider = serviceCollection.BuildServiceProvider();  // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface  this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();/&#125;</code></pre><p>確定好 talkService 註冊並且注入進 this._talkService 之後，就將 talkService 放進 FunctionHandler 中吧!<br>目前的 Lambda Function code 就會長這個樣子</p><pre><code>using Amazon.Lambda.Core;using Microsoft.Extensions.DependencyInjection;// Assembly attribute to enable the Lambda function&#39;s JSON input to be converted into a .NET class.[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]namespace AWSLambdaAndDI/&#123;    public class Function    /&#123;        private readonly ITalkService _talkService;        public Function()        /&#123;            // 建立 DI            var serviceCollection = new ServiceCollection();            // 將 TalkService 註冊進 DI            serviceCollection.AddTransient&lt;ITalkService, TalkService&gt;();            var serviceProvider = serviceCollection.BuildServiceProvider();            // 將註冊進 DI 的 talkService 注入 _talkService 這個 interface            this._talkService = serviceProvider.GetService&lt;ITalkService&gt;();        /&#125;        // 如果需要 unit test 可以利用這個 constructor 來進行 mock talkService        public Function(ITalkService talkService)        /&#123;            this._talkService = talkService;        /&#125;        /// &lt;summary&gt;        /// A simple function that takes a string and does a ToUpper        /// &lt;/summary&gt;        /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public string FunctionHandler(string input, ILambdaContext context)        /&#123;            return this._talkService.SayHello(input);        /&#125;    /&#125;/&#125;</code></pre><p>接著來使用 Mock Lambda Test Tool 來執行看看吧</p><p><img src="/img/2021-AWSLambdaUseDotnetCoreDI/1615734335.png"></p><p>以上就可以看到結果囉 “SQZ777: hello!”</p><p>如果以上訊息有任何錯誤麻煩告知 感謝各位大大 &lt;(_ _)&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dotnet core 的 DI 很好用&lt;/p&gt;
&lt;p&gt;所以筆記一下如何在 AWS Lambda 裡面也使用 dotnet core 的 DI&lt;/p&gt;
&lt;p&gt;首先先建立一個 interface, 就叫 ITalkService 好了~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name</summary>
      
    
    
    
    
    <category term=".NetCore" scheme="https://blogs.sqz777.com/tags/NetCore/"/>
    
    <category term="awsLambda" scheme="https://blogs.sqz777.com/tags/awsLambda/"/>
    
    <category term="dependencyInjection" scheme="https://blogs.sqz777.com/tags/dependencyInjection/"/>
    
  </entry>
  
  <entry>
    <title>筆記 - 將自己做好的 Discord bot 放在 Heroku 上</title>
    <link href="https://blogs.sqz777.com/2020/11/24/2020-putDiscordBotToHeroku/"/>
    <id>https://blogs.sqz777.com/2020/11/24/2020-putDiscordBotToHeroku/</id>
    <published>2020-11-24T00:00:00.000Z</published>
    <updated>2026-01-13T15:11:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子</p><p>這一篇以 Discord bot 為示範</p><p>首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972847.png"></p><p>點選 Create new app，命名自己的 app</p><p><img src="/img/2020-putDiscordBotToHeroku/1605972936.png"></p><p>新增完畢之後就可以看到這個畫面，接著點選 GitHub</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973124.png"></p><p>這邊要輸入自己要建置的 bot repo name然後按下 Search 之後再按下旁邊那個 Connect 的按鈕<br><a href="https://dotblogs.com.tw/Im_sqz777/2020/11/21/DiscordSetupHelloWorld">如何建置 Discord bot 點這裡</a></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973433.png"></p><p>連結完畢之後會看到這個畫面，下面那個 Deploy Branch 按下去就是把機器人建置起來了<br><strong>但是先等一下!!!</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973597.png"></p><p>這邊需要先設定環境變數，我的機器人範例程式碼是這樣寫的，可以看到我需要環境變數 <strong>DISCORD_TOKEN</strong></p><p><img src="/img/2020-putDiscordBotToHeroku/1605973739.png"></p><p>所以我需要在 Heroku 上面設定 <strong>DISCORD_TOKEN</strong> 這個環境變數，在上面那排欄位中找到 Settings 進來之後點選 Reveal Config Vars</p><p><img src="/img/2020-putDiscordBotToHeroku/1605973843.png"></p><p>點完之後，輸入變數名稱跟變數的值按下 Add 就可以成功新增環境變數</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974007.png"></p><p>在按下 Deploy 前請先確定自己的 package.json 中，有沒有設定好 npm start 要建置的 js file，如下</p><p>Heroku 在 Node.js 的專案中會執行 npm start 來執行專案</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974115.png"></p><p>確認完畢之後就可以回到這個頁面按下 Deploy Branch 囉!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974271.png"></p><p>回到 Discord 就可以看到自己的機器人上線啦!!</p><p><img src="/img/2020-putDiscordBotToHeroku/1605974342.png"></p><h2 id="澳門首家線上賭場上線啦"><a href="#澳門首家線上賭場上線啦" class="headerlink" title="澳門首家線上賭場上線啦"></a>澳門首家線上賭場上線啦</h2><p>以上是今天的筆記 感謝大家。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Heroku 是一個雲端服務平台，你可以把程式碼放上去，他可以依照你寫好的步驟建置成你想要的樣子&lt;/p&gt;
&lt;p&gt;這一篇以 Discord bot 為示範&lt;/p&gt;
&lt;p&gt;首先你需要有一個 Heroku 的帳號，創完登入之後會看到這個畫面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i</summary>
      
    
    
    
    
    <category term="discord" scheme="https://blogs.sqz777.com/tags/discord/"/>
    
    <category term="heroku" scheme="https://blogs.sqz777.com/tags/heroku/"/>
    
    <category term="nodejs" scheme="https://blogs.sqz777.com/tags/nodejs/"/>
    
  </entry>
  
</feed>
